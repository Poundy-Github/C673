/*! @file ******************************************************************
  COMPANY:                Continental AG, BU ADAS, A.D.C. GmbH
 
  PROJECT:                MFC4xx

  COMPONENT:              HLA

  MODULNAME:              hla_output_checks.c

  DESCRIPTION:            Headlight assist output checks.

  CREATION DATE:          2016-10-01
  
  CPU:                    Independent

  VERSION:                $Revision: 1.10 $
**************************************************************************** */
/* PRQA S 3120 EOF # 2019-05-28 A.Fischer: magic number justified in this file */
/* PRQA S 3121 EOF # 2019-05-28 A.Fischer: magic number justified in this file */
/* PRQA S 7004 EOF # 2019-05-28 M.Mutschler: Most of the stuff of this file is generated by a script. Therefore, we accept so many executable lines and cyclomatic complexity. */

/*****************************************************************************
  INCLUDES
*****************************************************************************/
#include "hla_defs.h"
#include "hla_output_checks.h"
#include "hla_errorhandling.h"

/*****************************************************************************
  SYMBOLIC CONSTANTS 
*****************************************************************************/

/****************************************************************************
* LOCAL TYPEDEFS
*****************************************************************************/
 
/****************************************************************************
* GLOBAL VARIABLES
*****************************************************************************/
 
/****************************************************************************
* LOCAL FUNCTIONS DECLARATION
*****************************************************************************/
static void HLA_OutputCheck_CompState(AlgoCompState_t* const pCompState);
static void HLA_OutputCheck_SignalHeader_t(const SignalHeader_t* const pSigHeader);

/*//\\START_GENERATED_FUNCTIONS_DECLARATION//\\*/
static void HLA_OutputCheck_RangeHeadlightControl(RTE_HLAF_HeadlightControl_t* const pHeadlightControl);
static void HLA_OutputCheck_FunctionStatus(RTE_HLAF_FunctionStatus* const pHlaFunctionStatus);
static void HLA_OutputCheck_HeadlightControl_Common(RTE_HLAF_HeadlightControl_Common_t* const pHeadlightControl_Common);
static void HLA_OutputCheck_TrafficStyle(RTE_HLA_TrafficStyle* const pTrafficStyle);
static void HLA_OutputCheck_CityState(RTE_HLAR_CityState* const pCityState);
static void HLA_OutputCheck_WeatherState(RTE_HLAR_WeatherState* const pWeatherState);
static void HLA_OutputCheck_Tunnel(RTE_HLAR_Tunnel* const pTunnelState);
static void HLA_OutputCheck_MotorwayState(RTE_HLAF_MotorwayState* const pMotorwayState);
static void HLA_OutputCheck_BrightnessState(RTE_HLAR_BrightnessState* const pBrightnessState);
static void HLA_OutputCheck_SensMode(RTE_HLA_SensMode* const pSensMode);
static void HLA_OutputCheck_SpeedState(RTE_HLAF_SpeedState* const pSpeedState);
static void HLA_OutputCheck_SceneInfo(RTE_HLA_SceneInfo* const pSceneInfo);
static void HLA_OutputCheck_Matrix(RTE_HLAF_Matrix_t* const pMatrix);
static void HLA_OutputCheck_SignalStatus(RTE_HLAF_SignalStatus* const pGFAStatus);
static void HLA_OutputCheck_HighBeamState(RTE_HLAF_HighBeamState* const pHighBeamState);
static void HLA_OutputCheck_ObjStatus(RTE_HLAF_ObjStatus* const pLowBeam_Status);
static void HLA_OutputCheck_MatrixTurnOffReason(RTE_HLAF_MatrixTurnOffReason* const pTurnOffReason);
static void HLA_OutputCheck_MatrixGFA(RTE_HLAF_MatrixGFA_t* const pMatrixGFA);
static void HLA_OutputCheck_DistState(RTE_HLAF_DistState* const pBndryLeft_DistState);
static void HLA_OutputCheck_DistReliability(RTE_HLA_DistReliability* const pBndryLeft_DistReliability);
static void HLA_OutputCheck_TTBStatus(RTE_HLAF_TTBStatus* const pTtb18Left_Status);
static void HLA_OutputCheck_LightDimming(RTE_HLAF_LightDimming_t* const pLightDimming);
static void HLA_OutputCheck_DimmingStatus(RTE_HLAF_DimmingStatus* const pDimmingStatus);
static void HLA_OutputCheck_DimmingLevel(RTE_HLAF_DimmingLevel* const pDimmingArea);
/*//\\END_GENERATED_FUNCTIONS_DECLARATION//\\*/

/****************************************************************************
* GLOBAL FUNCTIONS DEFINTION
*****************************************************************************/

/* *******************************************************************************
  Checks all outputs of HLA if they are in valid ranges.
******************************************************************************** */
void HLA_OutputChecks(proHlaPrtList_t* const pProPorts)
{
  /* ALGO COMP STATE */
  if(pProPorts->pAlgoCompState->sSigHeader.eSigStatus != (uint8)AL_SIG_STATE_INVALID)
  {
    HLA_OutputCheck_CompState(pProPorts->pAlgoCompState);
  }

  
/*//\\START_GENERATED_MAIN_FUNCTIONS_CALL//\\*/
  HLA_OutputCheck_RangeHeadlightControl(pProPorts->pHlaf_HeadlightControl);
/*//\\END_GENERATED_MAIN_FUNCTIONS_CALL//\\*/
}

/****************************************************************************
* LOCAL FUNCTIONS DEFINTION
*****************************************************************************/

/* *******************************************************************************
  @fn             HLA_OutputCheck_CompState                                  */ /*!
 
  @brief          Checks algo comp state whether its elements are in valid ranges.
 
  @description    For algo component state all elements are checked against valid
                  ranges. 
 
  @param[in]      pCompState       Pointer to algo component state
 
  @return         void
******************************************************************************** */
static void HLA_OutputCheck_CompState(AlgoCompState_t* const pCompState)
{
  /* ALGO INTERFACE VERSION NUMBER */
  if(pCompState->uiVersionNumber != (AlgoInterfaceVersionNumber_t)COMP_STATE_INTFVER)
  {
    /* Repair algo interface version number */
    pCompState->uiVersionNumber = (AlgoInterfaceVersionNumber_t)COMP_STATE_INTFVER;

    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_COMP_STATE_INTERFACE_VERSION);
  }

  /* SIGNAL HEADER */
  /* uiTimeStamp
   * uiMeasurementCounter
   * uiCycleCounter
   * can take full range
   */
  switch(pCompState->sSigHeader.eSigStatus)
  {
    case (uint8)AL_SIG_STATE_INIT:
    case (uint8)AL_SIG_STATE_OK:
    /* HLA_OutputChecks() prevents that this function is called with eSigStatus is set to invalid */
    /* case AL_SIG_STATE_INVALID: */
      break;
    default:
      /* Error case -> repair signal. Comp state must always be valid */
      pCompState->sSigHeader.eSigStatus = AL_SIG_STATE_OK;

      HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_COMP_STATE_SIG_STATE);
      break;
  }

  /* uiAlgoVersionNumber
   * uiApplicationNumber
   * AlgoVersionInfo
   * can take full range
   */

  /* COMP STATE */
  switch(pCompState->eCompState)
  {
    case (uint8)COMP_STATE_NOT_INITIALIZED:
    case (uint8)COMP_STATE_RUNNING:
    case (uint8)COMP_STATE_TEMPORARY_ERROR:
    case (uint8)COMP_STATE_PERMANENT_ERROR:
    case (uint8)COMP_STATE_SUCCESS:
    case (uint8)COMP_STATE_REDUCED_AVAILABILITY:
    case (uint8)COMP_STATE_NOT_RUNNING:
      break;
    default:
      /* Error case -> repair comp state */
      pCompState->eCompState = COMP_STATE_TEMPORARY_ERROR;

      HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_COMP_STATE_COMP_STATE);
      break;
  }

  /* SCHEDULER SUB-MODE REQUEST */
  switch(pCompState->eShedulerSubModeRequest)
  {
    case (uint8)BASE_SSM_NONE:
    case (uint8)BASE_SSM_BLOCKAGE:
    case (uint8)BASE_SSM_DEGRADED:
    case (uint8)BASE_SSM_STANDALONE:
    case (uint8)BASE_SSM_PARALLEL:
    case (uint8)BASE_SSM_NOT_CALIBRATED:
      break;
    default:
      /* Error case -> repair scheduler sub-mode request */
      pCompState->eShedulerSubModeRequest = BASE_SSM_NONE;

      HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_COMP_STATE_SCHEDULER_SUBMODE_REQUEST);
      break;
  }

  /* eErrorCode can take full range although it is an enum */

  /* ALGO QUALIFIER - bit field */
  if(pCompState->eGenAlgoQualifier >= ((GenAlgoQualifiers_t)ALGO_QUAL_CALIBRATION_RUNNING * 2u))
  {
    /* Error case -> repair signal */
    pCompState->eGenAlgoQualifier = ALGO_QUAL_OK;
    CML_SetBit(pCompState->eGenAlgoQualifier, (GenAlgoQualifiers_t)ALGO_QUAL_GENERAL_FUNCTION_ERROR);

    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_COMP_STATE_ALGO_QUALIFIER);
  }
}

/* *******************************************************************************
  @fn             HLA_OutputCheck_SignalHeader_t                             */ /*!
 
  @brief          Checks signal header values to be in valid ranges.
 
  @description    For signal headers only signal status field can be checked. All
                  other fields can take whole range of type.\n
                  Signal status cannot be repaired. Hence, if it is out of range an
                  error is issued.
 
  @param[in]      pSigHeader       Pointer to signal header under test
 
  @return         void
******************************************************************************** */
static void HLA_OutputCheck_SignalHeader_t(const SignalHeader_t* const pSigHeader)
{
  /* Range checks not applicable for SignalHeader_t members:
   * - uiTimeStamp
   * - uiMeasurementCounter
   * - uiCycleCounter
   */
  
  /* Check signal header enum */
  switch(pSigHeader->eSigStatus)
  {
    case (uint8)AL_SIG_STATE_INIT:
    case (uint8)AL_SIG_STATE_OK:
    case (uint8)AL_SIG_STATE_INVALID:
      break;
    default:
      /* Error case */
      HLA_ErrorHandling_SetError(HLA_ERROR_OUTPUT_CHECK_SIG_STATE);
      break;
  }
}



/*//\\START_GENERATED_FUNCTIONS_DEFINITION//\\*/

/** ************************************************************************************************
  \brief              Headlight Control data

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pHeadlightControl    Field under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_RangeHeadlightControl(RTE_HLAF_HeadlightControl_t* const pHeadlightControl)
{
  const uint8 numErrors = HLA_ErrorHandling_GetNumErrors();
  HLA_OutputCheck_SignalHeader_t(&(pHeadlightControl->sSigHeader));
  HLA_OutputCheck_FunctionStatus(&(pHeadlightControl->hlaFunctionStatus));
  HLA_OutputCheck_HeadlightControl_Common(&(pHeadlightControl->Common));
  HLA_OutputCheck_Matrix(&(pHeadlightControl->Matrix));
  HLA_OutputCheck_LightDimming(&(pHeadlightControl->Dimming));
  if(HLA_ErrorHandling_GetNumErrors() != numErrors)
  {
    pHeadlightControl->sSigHeader.eSigStatus = AL_SIG_STATE_INVALID;
    HLA_ErrorHandling_SetError(HLA_ERROR_OUTPUT_CHECK_HEADLIGHTCONTROL);
  }

}


/** ************************************************************************************************
  \brief              Status of HLA chain, mainly mapping of HLA component state

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pHlaFunctionStatus    Field (type: RTE_HLAF_FunctionStatus) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_FunctionStatus(RTE_HLAF_FunctionStatus* const pHlaFunctionStatus)
{
  switch(*pHlaFunctionStatus)
  {
  case (RTE_HLAF_FunctionStatus)RTE_HLAF_FUNCTION_STATUS_TEMPORARY_OFF:
  case (RTE_HLAF_FunctionStatus)RTE_HLAF_FUNCTION_STATUS_PERMANENT_OFF:
  case (RTE_HLAF_FunctionStatus)RTE_HLAF_FUNCTION_STATUS_RUNNING:
  case (RTE_HLAF_FunctionStatus)RTE_HLAF_FUNCTION_STATUS_INVALID:
    break;
  default:
    *pHlaFunctionStatus = RTE_HLAF_FUNCTION_STATUS_INVALID;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_HEADLIGHTCONTROL_HLAFUNCTIONSTATUS);
    break;
  }

}


/** ************************************************************************************************
  \brief              Common HLA output signals

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pHeadlightControl_Common    Field under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_HeadlightControl_Common(RTE_HLAF_HeadlightControl_Common_t* const pHeadlightControl_Common)
{
  HLA_OutputCheck_TrafficStyle(&(pHeadlightControl_Common->TrafficStyle));
  HLA_OutputCheck_CityState(&(pHeadlightControl_Common->CityState));
  HLA_OutputCheck_WeatherState(&(pHeadlightControl_Common->WeatherState));
  HLA_OutputCheck_Tunnel(&(pHeadlightControl_Common->TunnelState));
  HLA_OutputCheck_MotorwayState(&(pHeadlightControl_Common->MotorwayState));
  HLA_OutputCheck_BrightnessState(&(pHeadlightControl_Common->BrightnessState));
  HLA_OutputCheck_SensMode(&(pHeadlightControl_Common->SensMode));
  HLA_OutputCheck_SpeedState(&(pHeadlightControl_Common->SpeedState));
  HLA_OutputCheck_SceneInfo(&(pHeadlightControl_Common->SceneInfo));
}


/** ************************************************************************************************
  \brief              HLA right/left hand traffic style

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pTrafficStyle    Field (type: RTE_HLA_TrafficStyle) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_TrafficStyle(RTE_HLA_TrafficStyle* const pTrafficStyle)
{
  switch(*pTrafficStyle)
  {
  case (RTE_HLA_TrafficStyle)RTE_HLA_TRAFFIC_STYLE_UNKNOWN:
  case (RTE_HLA_TrafficStyle)RTE_HLA_TRAFFIC_STYLE_RHT:
  case (RTE_HLA_TrafficStyle)RTE_HLA_TRAFFIC_STYLE_LHT:
  case (RTE_HLA_TrafficStyle)RTE_HLA_TRAFFIC_STYLE_INVALID:
    break;
  default:
    *pTrafficStyle = RTE_HLA_TRAFFIC_STYLE_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_HEADLIGHTCONTROL_COMMON_TRAFFICSTYLE);
    break;
  }

}


/** ************************************************************************************************
  \brief              HLA city detection

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pCityState    Field (type: RTE_HLAR_CityState) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_CityState(RTE_HLAR_CityState* const pCityState)
{
  switch(*pCityState)
  {
  case (RTE_HLAR_CityState)RTE_HLAR_CITY_UNKNOWN:
  case (RTE_HLAR_CityState)RTE_HLAR_CITY_NOT_DTCD:
  case (RTE_HLAR_CityState)RTE_HLAR_CITY_DTCD:
  case (RTE_HLAR_CityState)RTE_HLAR_CITY_MAYBE:
  case (RTE_HLAR_CityState)RTE_HLAR_CITY_INVALID:
    break;
  default:
    *pCityState = RTE_HLAR_CITY_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_HEADLIGHTCONTROL_COMMON_CITYSTATE);
    break;
  }

}


/** ************************************************************************************************
  \brief              HLA weather detection

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pWeatherState    Field (type: RTE_HLAR_WeatherState) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_WeatherState(RTE_HLAR_WeatherState* const pWeatherState)
{
  switch(*pWeatherState)
  {
  case (RTE_HLAR_WeatherState)RTE_HLAR_WEATHER_UNKNOWN:
  case (RTE_HLAR_WeatherState)RTE_HLAR_WEATHER_GOOD:
  case (RTE_HLAR_WeatherState)RTE_HLAR_WEATHER_BAD:
  case (RTE_HLAR_WeatherState)RTE_HLAR_WEATHER_LIGHT_FOG:
  case (RTE_HLAR_WeatherState)RTE_HLAR_WEATHER_MEDIUM_FOG:
  case (RTE_HLAR_WeatherState)RTE_HLAR_WEATHER_HEAVY_FOG:
  case (RTE_HLAR_WeatherState)RTE_HLAR_WEATHER_INVALID:
    break;
  default:
    *pWeatherState = RTE_HLAR_WEATHER_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_HEADLIGHTCONTROL_COMMON_WEATHERSTATE);
    break;
  }

}


/** ************************************************************************************************
  \brief              HLA tunnel detection

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pTunnelState    Field (type: RTE_HLAR_Tunnel) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_Tunnel(RTE_HLAR_Tunnel* const pTunnelState)
{
  switch(*pTunnelState)
  {
  case (RTE_HLAR_Tunnel)RTE_HLAR_TUNNEL_UNKNOWN:
  case (RTE_HLAR_Tunnel)RTE_HLAR_TUNNEL_NOT_DTCD:
  case (RTE_HLAR_Tunnel)RTE_HLAR_TUNNEL_UPFRONT:
  case (RTE_HLAR_Tunnel)RTE_HLAR_TUNNEL_INSIDE:
  case (RTE_HLAR_Tunnel)RTE_HLAR_TUNNEL_INVALID:
    break;
  default:
    *pTunnelState = RTE_HLAR_TUNNEL_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_HEADLIGHTCONTROL_COMMON_TUNNELSTATE);
    break;
  }

}


/** ************************************************************************************************
  \brief              HLA motorway detection

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pMotorwayState    Field (type: RTE_HLAF_MotorwayState) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_MotorwayState(RTE_HLAF_MotorwayState* const pMotorwayState)
{
  switch(*pMotorwayState)
  {
  case (RTE_HLAF_MotorwayState)RTE_HLAF_MTWY_UNKNOWN:
  case (RTE_HLAF_MotorwayState)RTE_HLAF_MTWY_COUNTRY:
  case (RTE_HLAF_MotorwayState)RTE_HLAF_MTWY_MOTORWAY:
  case (RTE_HLAF_MotorwayState)RTE_HLAF_MTWY_INVALID:
    break;
  default:
    *pMotorwayState = RTE_HLAF_MTWY_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_HEADLIGHTCONTROL_COMMON_MOTORWAYSTATE);
    break;
  }

}


/** ************************************************************************************************
  \brief              HLA brightness detection

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pBrightnessState    Field (type: RTE_HLAR_BrightnessState) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_BrightnessState(RTE_HLAR_BrightnessState* const pBrightnessState)
{
  switch(*pBrightnessState)
  {
  case (RTE_HLAR_BrightnessState)RTE_HLAR_BRT_UNKNOWN:
  case (RTE_HLAR_BrightnessState)RTE_HLAR_BRT_DAY:
  case (RTE_HLAR_BrightnessState)RTE_HLAR_BRT_TWLGT_1:
  case (RTE_HLAR_BrightnessState)RTE_HLAR_BRT_TWLGT_2:
  case (RTE_HLAR_BrightnessState)RTE_HLAR_BRT_TWLGT_3:
  case (RTE_HLAR_BrightnessState)RTE_HLAR_BRT_NIGHT:
  case (RTE_HLAR_BrightnessState)RTE_HLAR_BRT_INVALID:
    break;
  default:
    *pBrightnessState = RTE_HLAR_BRT_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_HEADLIGHTCONTROL_COMMON_BRIGHTNESSSTATE);
    break;
  }

}


/** ************************************************************************************************
  \brief              Sensitivity modes normal or e.g. for US

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pSensMode    Field (type: RTE_HLA_SensMode) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_SensMode(RTE_HLA_SensMode* const pSensMode)
{
  switch(*pSensMode)
  {
  case (RTE_HLA_SensMode)RTE_HLA_SENSMODE_UNKNOWN:
  case (RTE_HLA_SensMode)RTE_HLA_SENSMODE_NORMAL:
  case (RTE_HLA_SensMode)RTE_HLA_SENSMODE_US:
  case (RTE_HLA_SensMode)RTE_HLA_SENSMODE_INVALID:
    break;
  default:
    *pSensMode = RTE_HLA_SENSMODE_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_HEADLIGHTCONTROL_COMMON_SENSMODE);
    break;
  }

}


/** ************************************************************************************************
  \brief              If speed is higher/lower than (De)ActivateSpeed (CPAR) which defines when to tur
                    n on/off high beam

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pSpeedState    Field (type: RTE_HLAF_SpeedState) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_SpeedState(RTE_HLAF_SpeedState* const pSpeedState)
{
  switch(*pSpeedState)
  {
  case (RTE_HLAF_SpeedState)RTE_HLAF_SPEEDSTATE_UNKNOWN:
  case (RTE_HLAF_SpeedState)RTE_HLAF_SPEEDSTATE_TOO_LOW:
  case (RTE_HLAF_SpeedState)RTE_HLAF_SPEEDSTATE_IN_RANGE:
  case (RTE_HLAF_SpeedState)RTE_HLAF_SPEEDSTATE_TOO_HIGH:
  case (RTE_HLAF_SpeedState)RTE_HLAF_SPEEDSTATE_INVALID:
    break;
  default:
    *pSpeedState = RTE_HLAF_SPEEDSTATE_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_HEADLIGHTCONTROL_COMMON_SPEEDSTATE);
    break;
  }

}


/** ************************************************************************************************
  \brief              If oncoming vehicle is directly passing or preceding vehicle is overtaken 
                    directly this output is used to trigger very fast highbeam turn on

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pSceneInfo    Field (type: RTE_HLA_SceneInfo) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_SceneInfo(RTE_HLA_SceneInfo* const pSceneInfo)
{
  switch(*pSceneInfo)
  {
  case (RTE_HLA_SceneInfo)RTE_HLA_SCENEINFO_UNKNOWN:
  case (RTE_HLA_SceneInfo)RTE_HLA_SCENEINFO_ONCOMING_PASSING:
  case (RTE_HLA_SceneInfo)RTE_HLA_SCENEINFO_PRECEDING_OVERTAKING:
  case (RTE_HLA_SceneInfo)RTE_HLA_SCENEINFO_INVALID:
    break;
  default:
    *pSceneInfo = RTE_HLA_SCENEINFO_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_HEADLIGHTCONTROL_COMMON_SCENEINFO);
    break;
  }

}


/** ************************************************************************************************
  \brief              HLA Matrix beam signals (glare free areas (GFA))

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pMatrix    Field under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_Matrix(RTE_HLAF_Matrix_t* const pMatrix)
{
  uint32 i;
  for(i = 0u; i < (uint32)RTE_HLAF_MATRIX_MAX_NUM_GLARE_FREE_AREAS; i++)
  {
    HLA_OutputCheck_MatrixGFA(&(pMatrix->GFA[i]));
  }

  if(pMatrix->nGFA > (uint8)RTE_HLAF_MATRIX_MAX_NUM_GLARE_FREE_AREAS)
  {
    pMatrix->nGFA = 0u;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIX_NGFA);
  }

  HLA_OutputCheck_SignalStatus(&(pMatrix->GFAStatus));
  HLA_OutputCheck_HighBeamState(&(pMatrix->HighBeamState));
  if(CML_f_IsInRange(0.0f, 600.0f, pMatrix->LowBeam_Dist) == b_FALSE)
  {
    pMatrix->LowBeam_Dist = CML_f_MinMax(0.0f, 600.0f, pMatrix->LowBeam_Dist);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIX_LOWBEAM_DIST);
  }

  if(CML_f_IsInRange(CML_Deg2Rad(-20.0f), CML_Deg2Rad(20.0f), pMatrix->LowBeam_Ang) == b_FALSE)
  {
    pMatrix->LowBeam_Ang = CML_f_MinMax(CML_Deg2Rad(-20.0f), CML_Deg2Rad(20.0f), pMatrix->LowBeam_Ang);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIX_LOWBEAM_ANG);
  }

  HLA_OutputCheck_ObjStatus(&(pMatrix->LowBeam_Status));
  HLA_OutputCheck_MatrixTurnOffReason(&(pMatrix->TurnOffReason));
}


/** ************************************************************************************************
  \brief              glare free area status

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pGFAStatus    Field (type: RTE_HLAF_SignalStatus) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_SignalStatus(RTE_HLAF_SignalStatus* const pGFAStatus)
{
  switch(*pGFAStatus)
  {
  case (RTE_HLAF_SignalStatus)RTE_HLAF_SIGSTAT_UNKNOWN:
  case (RTE_HLAF_SignalStatus)RTE_HLAF_SIGSTAT_INIT:
  case (RTE_HLAF_SignalStatus)RTE_HLAF_SIGSTAT_DATA_VALID:
  case (RTE_HLAF_SignalStatus)RTE_HLAF_SIGSTAT_DATA_INVALID:
  case (RTE_HLAF_SignalStatus)RTE_HLAF_SIGSTAT_INVALID:
    break;
  default:
    *pGFAStatus = RTE_HLAF_SIGSTAT_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIX_GFASTATUS);
    break;
  }

}


/** ************************************************************************************************
  \brief              high beam state recommendation

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pHighBeamState    Field (type: RTE_HLAF_HighBeamState) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_HighBeamState(RTE_HLAF_HighBeamState* const pHighBeamState)
{
  switch(*pHighBeamState)
  {
  case (RTE_HLAF_HighBeamState)RTE_HLAF_HB_STATE_UNKNOWN:
  case (RTE_HLAF_HighBeamState)RTE_HLAF_HB_STATE_OFF:
  case (RTE_HLAF_HighBeamState)RTE_HLAF_HB_STATE_FULL_ON:
  case (RTE_HLAF_HighBeamState)RTE_HLAF_HB_STATE_PARTIAL:
  case (RTE_HLAF_HighBeamState)RTE_HLAF_HB_STATE_SPOT:
  case (RTE_HLAF_HighBeamState)RTE_HLAF_HB_STATE_INVALID:
    break;
  default:
    *pHighBeamState = RTE_HLAF_HB_STATE_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIX_HIGHBEAMSTATE);
    break;
  }

}


/** ************************************************************************************************
  \brief              object status of the vehicle which defines the low beam distance (preceding 
                    oncoming car)

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pLowBeam_Status    Field (type: RTE_HLAF_ObjStatus) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_ObjStatus(RTE_HLAF_ObjStatus* const pLowBeam_Status)
{
  switch(*pLowBeam_Status)
  {
  case (RTE_HLAF_ObjStatus)RTE_HLAF_OBJSTA_UNKNOWN:
  case (RTE_HLAF_ObjStatus)RTE_HLAF_OBJSTA_NO_OBJ:
  case (RTE_HLAF_ObjStatus)RTE_HLAF_OBJSTA_UNKNOWN_OBJ:
  case (RTE_HLAF_ObjStatus)RTE_HLAF_OBJSTA_PREC_OBJ:
  case (RTE_HLAF_ObjStatus)RTE_HLAF_OBJSTA_ONC_OBJ:
  case (RTE_HLAF_ObjStatus)RTE_HLAF_OBJSTA_INVALID:
    break;
  default:
    *pLowBeam_Status = RTE_HLAF_OBJSTA_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIX_LOWBEAM_STATUS);
    break;
  }

}


/** ************************************************************************************************
  \brief              HLA turn off reason

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pTurnOffReason    Field (type: RTE_HLAF_MatrixTurnOffReason) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_MatrixTurnOffReason(RTE_HLAF_MatrixTurnOffReason* const pTurnOffReason)
{
  if(*pTurnOffReason > 2047u)
  {
    *pTurnOffReason = RTE_HLAF_TURNOFFREASON_ERROR;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIX_TURNOFFREASON);
  }

}


/** ************************************************************************************************
  \brief              HLA Glare Free Area definition

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pMatrixGFA    Field under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_MatrixGFA(RTE_HLAF_MatrixGFA_t* const pMatrixGFA)
{
  if(CML_f_IsInRange(CML_Deg2Rad(-25.0f), CML_Deg2Rad(25.0f), pMatrixGFA->BndryLeft_Ang) == b_FALSE)
  {
    pMatrixGFA->BndryLeft_Ang = CML_f_MinMax(CML_Deg2Rad(-25.0f), CML_Deg2Rad(25.0f), pMatrixGFA->BndryLeft_Ang);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_BNDRYLEFT_ANG);
  }

  if(CML_f_IsInRange(0.0f, 655.35f, pMatrixGFA->BndryLeft_Dist) == b_FALSE)
  {
    pMatrixGFA->BndryLeft_Dist = CML_f_MinMax(0.0f, 655.35f, pMatrixGFA->BndryLeft_Dist);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_BNDRYLEFT_DIST);
  }

  if(CML_f_IsInRange(CML_Deg2Rad(-25.0f), CML_Deg2Rad(25.0f), pMatrixGFA->BndryLeft_Ang_Cam) == b_FALSE)
  {
    pMatrixGFA->BndryLeft_Ang_Cam = CML_f_MinMax(CML_Deg2Rad(-25.0f), CML_Deg2Rad(25.0f), pMatrixGFA->BndryLeft_Ang_Cam);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_BNDRYLEFT_ANG_CAM);
  }

  HLA_OutputCheck_ObjStatus(&(pMatrixGFA->BndryLeft_Status));
  if(pMatrixGFA->BndryLeft_ObjId > ((uint8)LSD_LIGHT_OBJECT_LIST_LENGTH - 1u))
  {
    HLA_ErrorHandling_SetError(HLA_ERROR_OUTPUT_CHECK_MATRIXGFA_BNDRYLEFT_OBJID);
  }

  HLA_OutputCheck_DistState(&(pMatrixGFA->BndryLeft_DistState));
  HLA_OutputCheck_DistReliability(&(pMatrixGFA->BndryLeft_DistReliability));
  if(CML_f_IsInRange(CML_Deg2Rad(-25.0f), CML_Deg2Rad(25.0f), pMatrixGFA->BndryRight_Ang) == b_FALSE)
  {
    pMatrixGFA->BndryRight_Ang = CML_f_MinMax(CML_Deg2Rad(-25.0f), CML_Deg2Rad(25.0f), pMatrixGFA->BndryRight_Ang);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_BNDRYRIGHT_ANG);
  }

  if(CML_f_IsInRange(0.0f, 655.35f, pMatrixGFA->BndryRight_Dist) == b_FALSE)
  {
    pMatrixGFA->BndryRight_Dist = CML_f_MinMax(0.0f, 655.35f, pMatrixGFA->BndryRight_Dist);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_BNDRYRIGHT_DIST);
  }

  if(CML_f_IsInRange(CML_Deg2Rad(-25.0f), CML_Deg2Rad(25.0f), pMatrixGFA->BndryRight_Ang_Cam) == b_FALSE)
  {
    pMatrixGFA->BndryRight_Ang_Cam = CML_f_MinMax(CML_Deg2Rad(-25.0f), CML_Deg2Rad(25.0f), pMatrixGFA->BndryRight_Ang_Cam);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_BNDRYRIGHT_ANG_CAM);
  }

  HLA_OutputCheck_ObjStatus(&(pMatrixGFA->BndryRight_Status));
  if(pMatrixGFA->BndryRight_ObjId > ((uint8)LSD_LIGHT_OBJECT_LIST_LENGTH - 1u))
  {
    HLA_ErrorHandling_SetError(HLA_ERROR_OUTPUT_CHECK_MATRIXGFA_BNDRYRIGHT_OBJID);
  }

  HLA_OutputCheck_DistState(&(pMatrixGFA->BndryRight_DistState));
  HLA_OutputCheck_DistReliability(&(pMatrixGFA->BndryRight_DistReliability));
  if(CML_f_IsInRange(CML_Deg2Rad(-5.0f), CML_Deg2Rad(5.0f), pMatrixGFA->BndryLower_Ang_Cam) == b_FALSE)
  {
    pMatrixGFA->BndryLower_Ang_Cam = CML_f_MinMax(CML_Deg2Rad(-5.0f), CML_Deg2Rad(5.0f), pMatrixGFA->BndryLower_Ang_Cam);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_BNDRYLOWER_ANG_CAM);
  }

  HLA_OutputCheck_ObjStatus(&(pMatrixGFA->BndryLower_Status));
  if(pMatrixGFA->BndryLower_ObjId > ((uint8)LSD_LIGHT_OBJECT_LIST_LENGTH - 1u))
  {
    HLA_ErrorHandling_SetError(HLA_ERROR_OUTPUT_CHECK_MATRIXGFA_BNDRYLOWER_OBJID);
  }

  HLA_OutputCheck_DistState(&(pMatrixGFA->BndryLower_DistState));
  HLA_OutputCheck_DistReliability(&(pMatrixGFA->BndryLower_DistReliability));
  if(CML_f_IsInRange(CML_Deg2Rad(-10.0f), CML_Deg2Rad(5.0f), pMatrixGFA->BndryUpper_Ang_Cam) == b_FALSE)
  {
    pMatrixGFA->BndryUpper_Ang_Cam = CML_f_MinMax(CML_Deg2Rad(-10.0f), CML_Deg2Rad(5.0f), pMatrixGFA->BndryUpper_Ang_Cam);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_BNDRYUPPER_ANG_CAM);
  }

  HLA_OutputCheck_ObjStatus(&(pMatrixGFA->BndryUpper_Status));
  if(pMatrixGFA->BndryUpper_ObjId > ((uint8)LSD_LIGHT_OBJECT_LIST_LENGTH - 1u))
  {
    HLA_ErrorHandling_SetError(HLA_ERROR_OUTPUT_CHECK_MATRIXGFA_BNDRYUPPER_OBJID);
  }

  HLA_OutputCheck_DistState(&(pMatrixGFA->BndryUpper_DistState));
  HLA_OutputCheck_DistReliability(&(pMatrixGFA->BndryUpper_DistReliability));
  if(CML_f_IsInRange(0.0f, 655.35f, pMatrixGFA->ClosestObj_Dist) == b_FALSE)
  {
    pMatrixGFA->ClosestObj_Dist = CML_f_MinMax(0.0f, 655.35f, pMatrixGFA->ClosestObj_Dist);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_CLOSESTOBJ_DIST);
  }

  if(CML_f_IsInRange(CML_Deg2Rad(-20.0f), CML_Deg2Rad(20.0f), pMatrixGFA->ClosestObj_Ang) == b_FALSE)
  {
    pMatrixGFA->ClosestObj_Ang = CML_f_MinMax(CML_Deg2Rad(-20.0f), CML_Deg2Rad(20.0f), pMatrixGFA->ClosestObj_Ang);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_CLOSESTOBJ_ANG);
  }

  HLA_OutputCheck_ObjStatus(&(pMatrixGFA->ClosestObj_Status));
  if(pMatrixGFA->ClosestObj_ObjId > ((uint8)LSD_LIGHT_OBJECT_LIST_LENGTH - 1u))
  {
    HLA_ErrorHandling_SetError(HLA_ERROR_OUTPUT_CHECK_MATRIXGFA_CLOSESTOBJ_OBJID);
  }

  HLA_OutputCheck_DistState(&(pMatrixGFA->ClosestObj_DistState));
  HLA_OutputCheck_DistReliability(&(pMatrixGFA->ClosestObj_DistReliability));
  if(CML_f_IsInRange(0.0f, 655.35f, pMatrixGFA->MinLight_Dist) == b_FALSE)
  {
    pMatrixGFA->MinLight_Dist = CML_f_MinMax(0.0f, 655.35f, pMatrixGFA->MinLight_Dist);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_MINLIGHT_DIST);
  }

  if(CML_f_IsInRange(CML_Deg2Rad(-20.0f), CML_Deg2Rad(20.0f), pMatrixGFA->MinLight_Ang) == b_FALSE)
  {
    pMatrixGFA->MinLight_Ang = CML_f_MinMax(CML_Deg2Rad(-20.0f), CML_Deg2Rad(20.0f), pMatrixGFA->MinLight_Ang);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_MINLIGHT_ANG);
  }

  HLA_OutputCheck_ObjStatus(&(pMatrixGFA->MinLight_Status));
  if(pMatrixGFA->MinLight_ObjId > ((uint8)LSD_LIGHT_OBJECT_LIST_LENGTH - 1u))
  {
    HLA_ErrorHandling_SetError(HLA_ERROR_OUTPUT_CHECK_MATRIXGFA_MINLIGHT_OBJID);
  }

  HLA_OutputCheck_DistState(&(pMatrixGFA->MinLight_DistState));
  if(CML_f_IsInRange(0.0f, 10.0f, pMatrixGFA->ttb18Left) == b_FALSE)
  {
    pMatrixGFA->ttb18Left = CML_f_MinMax(0.0f, 10.0f, pMatrixGFA->ttb18Left);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_TTB18LEFT);
  }

  HLA_OutputCheck_TTBStatus(&(pMatrixGFA->ttb18Left_Status));
  if(CML_f_IsInRange(0.0f, 10.0f, pMatrixGFA->ttb18Right) == b_FALSE)
  {
    pMatrixGFA->ttb18Right = CML_f_MinMax(0.0f, 10.0f, pMatrixGFA->ttb18Right);
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_TTB18RIGHT);
  }

  HLA_OutputCheck_TTBStatus(&(pMatrixGFA->ttb18Right_Status));
  if(pMatrixGFA->ExistenceProb > 100u)
  {
    pMatrixGFA->ExistenceProb = 100u;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_EXISTENCEPROB);
  }

}


/** ************************************************************************************************
  \brief              specifies whether distance is measured from single or pair light

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pBndryLeft_DistState    Field (type: RTE_HLAF_DistState) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_DistState(RTE_HLAF_DistState* const pBndryLeft_DistState)
{
  switch(*pBndryLeft_DistState)
  {
  case (RTE_HLAF_DistState)RTE_HLAF_DISTSTATE_UNKNOWN:
  case (RTE_HLAF_DistState)RTE_HLAF_DISTSTATE_SINGLELIGHT:
  case (RTE_HLAF_DistState)RTE_HLAF_DISTSTATE_PAIRLIGHT:
  case (RTE_HLAF_DistState)RTE_HLAF_DISTSTATE_PAIRLIGHT_WIDE:
  case (RTE_HLAF_DistState)RTE_HLAF_DISTSTATE_INVALID:
    break;
  default:
    *pBndryLeft_DistState = RTE_HLAF_DISTSTATE_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_BNDRYLEFT_DISTSTATE);
    break;
  }

}


/** ************************************************************************************************
  \brief              Reliability of the distance estimation for the object which defines the left 
                    border

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pBndryLeft_DistReliability    Field (type: RTE_HLA_DistReliability) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_DistReliability(RTE_HLA_DistReliability* const pBndryLeft_DistReliability)
{
  switch(*pBndryLeft_DistReliability)
  {
  case (RTE_HLA_DistReliability)RTE_HLA_DISTANCE_RELIABILITY_UNKNOWN:
  case (RTE_HLA_DistReliability)RTE_HLA_DISTANCE_RELIABILITY_LOW:
  case (RTE_HLA_DistReliability)RTE_HLA_DISTANCE_RELIABILITY_MID:
  case (RTE_HLA_DistReliability)RTE_HLA_DISTANCE_RELIABILITY_HIGH:
  case (RTE_HLA_DistReliability)RTE_HLA_DISTANCE_RELIABILITY_INVALID:
    break;
  default:
    *pBndryLeft_DistReliability = RTE_HLA_DISTANCE_RELIABILITY_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_BNDRYLEFT_DISTRELIABILITY);
    break;
  }

}


/** ************************************************************************************************
  \brief              Status of ttb18Left (moving direction)

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pTtb18Left_Status    Field (type: RTE_HLAF_TTBStatus) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_TTBStatus(RTE_HLAF_TTBStatus* const pTtb18Left_Status)
{
  switch(*pTtb18Left_Status)
  {
  case (RTE_HLAF_TTBStatus)RTE_HLAF_TTBSTA_UNKNOWN:
  case (RTE_HLAF_TTBStatus)RTE_HLAF_TTBSTA_NO_OBJ:
  case (RTE_HLAF_TTBStatus)RTE_HLAF_TTBSTA_DIR_UNKNOWN:
  case (RTE_HLAF_TTBStatus)RTE_HLAF_TTBSTA_DIR_LEFT:
  case (RTE_HLAF_TTBStatus)RTE_HLAF_TTBSTA_DIR_RIGHT:
  case (RTE_HLAF_TTBStatus)RTE_HLAF_TTBSTA_INVALID:
    break;
  default:
    *pTtb18Left_Status = RTE_HLAF_TTBSTA_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_MATRIXGFA_TTB18LEFT_STATUS);
    break;
  }

}


/** ************************************************************************************************
  \brief              HLA light dim down area signals (for bright reflecting areas)

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pLightDimming    Field under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_LightDimming(RTE_HLAF_LightDimming_t* const pLightDimming)
{
  uint32 i;
  HLA_OutputCheck_DimmingStatus(&(pLightDimming->DimmingStatus));
  for(i = 0u; i < (uint32)RTE_HLA_NUM_DIMM_AREAS; i++)
  {
    HLA_OutputCheck_DimmingLevel(&(pLightDimming->DimmingArea[i]));
  }

}


/** ************************************************************************************************
  \brief              Status of the dimming function

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pDimmingStatus    Field (type: RTE_HLAF_DimmingStatus) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_DimmingStatus(RTE_HLAF_DimmingStatus* const pDimmingStatus)
{
  switch(*pDimmingStatus)
  {
  case (RTE_HLAF_DimmingStatus)RTE_HLAF_DIMM_STATE_UNKNOWN:
  case (RTE_HLAF_DimmingStatus)RTE_HLAF_DIMM_STATE_AVL:
  case (RTE_HLAF_DimmingStatus)RTE_HLAF_DIMM_STATE_LIMITED:
  case (RTE_HLAF_DimmingStatus)RTE_HLAF_DIMM_STATE_NAVL:
  case (RTE_HLAF_DimmingStatus)RTE_HLAF_DIMM_STATE_ERROR:
  case (RTE_HLAF_DimmingStatus)RTE_HLAF_DIMM_STATE_INVALID:
    break;
  default:
    *pDimmingStatus = RTE_HLAF_DIMM_STATE_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_LIGHTDIMMING_DIMMINGSTATUS);
    break;
  }

}


/** ************************************************************************************************
  \brief              List which holds the dimming areas

  \pre                None

  \post               In case of a failed check corresponding error or warning is set.

  \param[in]          pDimmingArea    Field (type: RTE_HLAF_DimmingLevel) under test.

  \return             void

  \globals
                      None

  \InOutCorrelation
                      Check output ranges and set appropriate error or warning bit respectively  if a 
                    value is out of range. Value also is set to fallback if provided.

  \callsequence       

  \testmethod         

  \traceability       
***************************************************************************************************/
static void HLA_OutputCheck_DimmingLevel(RTE_HLAF_DimmingLevel* const pDimmingArea)
{
  switch(*pDimmingArea)
  {
  case (RTE_HLAF_DimmingLevel)RTE_HLAF_DIMM_LEVEL_UNKNOWN:
  case (RTE_HLAF_DimmingLevel)RTE_HLAF_DIMM_LEVEL_NO_REDUCT:
  case (RTE_HLAF_DimmingLevel)RTE_HLAF_DIMM_LEVEL_REDUCT_1:
  case (RTE_HLAF_DimmingLevel)RTE_HLAF_DIMM_LEVEL_REDUCT_2:
  case (RTE_HLAF_DimmingLevel)RTE_HLAF_DIMM_LEVEL_INVALID:
    break;
  default:
    *pDimmingArea = RTE_HLAF_DIMM_LEVEL_UNKNOWN;
    HLA_ErrorHandling_SetWarning(HLA_WARNING_OUTPUT_CHECK_LIGHTDIMMING_DIMMINGAREA);
    break;
  }

}

/*//\\END_GENERATED_FUNCTIONS_DEFINITION//\\*/
