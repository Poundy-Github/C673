/*! \file **********************************************************************

COMPANY:                   COPYRIGHT (C) Continental AG

PROJECT:                   Mainstream

CPU:                       CPU-Independent

COMPONENT:                 HEAD (Hypothesis Evaluation And Decision)

PACKAGENAME:               head_spm.c

DESCRIPTION:               Implementation of the signal performance monitor of the HEAD module

AUTHOR:                    $Author: Muddaveeraiah, Nalina (uidn6869) $

CREATION DATE:             $Date: 2020/06/17 13:52:18CEST $

VERSION:                   $Revision: 1.15 $

LEGACY VERSION:            1.22
  
**************************************************************************** */
/**
@defgroup head_spm HEAD SPM
@ingroup Medic_head
@{ **/
/*****************************************************************************
  INCLUDES
*****************************************************************************/
#include "frame_medic/medic_int.h"

#if !(MEDIC_CFG_HEAD20)
#include "head/head_int.h"

#if (MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION)
/*PRQA S 2016 EOF #date: 2020-06-02, reviewer: Nalina M, reason: Defensive programming*/
/*****************************************************************************
  SYMBOLIC CONSTANTS
*****************************************************************************/

/*****************************************************************************
  MACROS
*****************************************************************************/

/*****************************************************************************
  TYPEDEFS
*****************************************************************************/

/*****************************************************************************
  CONSTS
*****************************************************************************/

/*****************************************************************************
  VARIABLES
*****************************************************************************/

/*****************************************************************************
  PROTOTYPES
*****************************************************************************/
static eGDBError_t HEADSPMCheckCondition(boolean bCondition, HEADSPMCheck_t *pRule, uint32 rgQoSSate[], uint32 rgRepErrorSate[], float32 fCycleTime);
static void HEADSPMEvaluate_sint32(const HEADSPMCheck_t *pThisRule, const sint32 *pVal, boolean *bResult);
static void HEADSPMEvaluate_uint32(const HEADSPMCheck_t *pThisRule, const uint32 *pVal, boolean *bResult);
static void HEADSPMEvaluate_float32(const HEADSPMCheck_t *pThisRule, const float32 *pVal, boolean *bResult);
static void HEADSPMEvaluate_boolean(const HEADSPMCheck_t *pThisRule, const boolean *pVal, boolean *bResult);
static void HEADSPMFunctionCheck_sint32(const HEADSPMCheck_t *pThisRule, sint32 *pVal);
static void HEADSPMFunctionCheck_uint32(const HEADSPMCheck_t *pThisRule, uint32 *pVal);
static void HEADSPMFunctionCheck_float32(const HEADSPMCheck_t *pThisRule, float32 *pVal);
/*************************************************************************************************************************
  Functionname:         HEADSPMAddSigCheck                                                                        */ /*!

  @brief                Adds a new rule to the spm array

  @description           This function is used to add the SPM rules generated by Autocoder to SPM rules array
                        @startuml
                        Start
                        If(Is New rule number is within the total number of SPM rules?)then (yes)
                            :Fetch the location in SPM rules array 
                            corresponding to new rule number.;
                            :Add the content of the New rule 
                            to SPM rules array;
                            Note left
                                If the value of any expected parameter is 
                                less than or greater than the valid range 
                                then clip it to Min or Max value respectively, 
                                and update corresponding Error.
                            End note
                        else(no)
                            :Error message:
                            the SPM rules array index is out of bounds;
                        endif
                        Stop
                        @enduml

  @return               eGDBError_t         :GDB error type is returned

  @param[in]            pRules              : Stores all the HEAD SPM check rules
  @param[in]            uiRuleNr            : HEAD SPM rule number
  @param[in]            pSignal             : Pointer to HEAD input signals
  @param[in]            eHEADMTSInSigIdent  : HEAD MTS signal identifier
  @param[in]            eCheckSignal        : Whether the signal or state  to be checked
  @param[in]            eCheckOperator      : The HEAD signal operation 
  @param[in]            eCheckFunction      : The HEAD module signal to be used by the function
  @param[in]            eCheckStdDev        : The HEAD module signal for standard deviation
  @param[in]            fValue              : float value to update the current value 
  @param[in]            fNeededTime         : float value to stores needed time 
  @param[in]            bitModules          : Bits which modules are affected by this rule
  @param[in]            eDesiredQoS         :HEAD module desired QoS mode
  @param[in]            eReportedError      : HEAD Module SPM reported error types
  
  @glob_in              None
  @glob_out             None

  @c_switch_part        
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION   

  @pre                  None
  @post                 None

  @InOutCorrelation     Not defined
  
  @testmethod           Test of output data (dynamic module test) 

  @traceability         Design Decision
  
  @author               Armin Vogl | armin.vogl@continental-corporation.com  
*************************************************************************************************************************/
eGDBError_t HEADSPMAddSigCheck(const HEADSPMRules_t *pRules, uint32 uiRuleNr, struct HEADInputValue_t *pSignal,
                               HEADMTSInSigIdent_t eHEADMTSInSigIdent, eHEADSPMCheckBitsSignal_t eCheckSignal,
                               eHEADSPMCheckBitsOp_t eCheckOperator, eHEADSPMCheckBitsFunction_t eCheckFunction,
                               eHEADSPMCheckBitsStdDeviation_t eCheckStdDev, float32 fValue, float32 fNeededTime,
                               uint32 bitModules, eHEADModuleQoS_t eDesiredQoS, eHEADModuleRepError_t eReportedError)
{
  eGDBError_t eError = GDB_ERROR_NONE;
  if ((pRules != NULL) && (pSignal != NULL))
  {
    if(uiRuleNr < pRules->uiNrOfSPMRules)
    {
      HEADSPMCheck_t *pCurrRule = HEADSPMGetRule(pRules->rgSPMRules, uiRuleNr);
      
      pCurrRule->bitModules = bitModules;
      pCurrRule->bitCheckType = (uint8) ( HEADSPMSetBitsStdDeviation(eCheckStdDev) 
                                        | HEADSPMSetBitsFunction(eCheckFunction) 
                                        | HEADSPMSetBitsOperator(eCheckOperator) 
                                        | HEADSPMSetBitsSignal(eCheckSignal)
                                        );
      pCurrRule->eHEADMTSInSigIdent = eHEADMTSInSigIdent;
      pCurrRule->eQOS = (HEADModuleQoS_t)eDesiredQoS;
      pCurrRule->eReportedError = (HEADModuleRepError_t)eReportedError;
      pCurrRule->uiCurrentTimer = 0u;
      
      if(fNeededTime < 0.0f)
      {
        eError = GDB_ERROR_CAST_VALUE_TO_LOW;
        pCurrRule->uiNeededTime = 0u;
      }
      else if ((fNeededTime * (float32)HEADTimeScale) > (float32)HEADTimeMax)
      {
        eError = GDB_ERROR_CAST_VALUE_TO_HIGH;
        pCurrRule->uiNeededTime = (uint16)HEADTimeMax;
      }
      else
      {
        float32 fTime;
        fTime = fNeededTime * (float32)HEADTimeScale;
        pCurrRule->uiNeededTime = (uint16)fTime;
      }
 
      if(fValue > (float32)HEADParameterRawValue_Max)
      {
        fValue = (float32)HEADParameterRawValue_Max;
        eError = GDB_ERROR_CAST_VALUE_TO_HIGH;
      }
      else 
      {
        if(fValue < -((float32)HEADParameterRawValue_Max))
        {
          fValue = (float32)(-HEADParameterRawValue_Max);
          eError = GDB_ERROR_CAST_VALUE_TO_LOW;
        }
      }
      pCurrRule->f16Value = HEADConvf32Tof16(fValue);
      pCurrRule->pInputSignal = pSignal;
    }
    else
    {
      eError = GDB_ERROR_ARRAY_OVERFLOW;
    }
  }
  else
  {
    eError = GDB_ERROR_POINTER_NULL;
  }
  return eError;
}


/* ***********************************************************************************************************************
  Functionname:         HEADSPMCheckCondition                                                                       */ /*! 

  @brief                The function checks a condition and updates the spm QoS array

  @description          The function checks a condition and updates the spm QoS array
  
                        @startuml
                        Start
                            If(is condition true?) then (Yes)
                            :assign zero to local condition;
                            If(check current timer is >= needed time) then (Yes)
                            :assign true to local condition;
                            Else
                            :assign zero to local condition;
                            Endif
                            If(Check QoS is higher than maximum Qos) then (Yes)
                            :update return type as array of index is out of bounds;
                            endif
                            If(Check reported Error higher than maximum reported Error) then (Yes)
                            :update return type as array of index is out of bounds;
                            Endif
                            If(check error is none error) then (Yes)
                            if(check local condition) then (True)
                            if(Is Qos Normal Running state?) then (No)
                            : affected modules updated in corresponding bit;
                            Endif
                            if(check Reported Error is No Error) then (No)
                            : affected modules error updated in corresponding bit;
                            Endif
                            else
                            if(Is Qos Normal Running state?) then (Yes)
                            : affected modules updated in corresponding bit;
                            Endif
                            if(check Reported Error is No Error) then (Yes)
                            : Affected module errors are updated in corresponding bit;
                            Endif
                            Endif
                            Endif
                            If(Is timer value more than maximum timer value?) then (No)
                            :update increased timer value;  
                            Else 
                            :update maximum timer value;
                            Endif
                            Else 
                            :Reset the current timer;
                            Endif
                            :return error type;
                        stop
                        @enduml

  @return               eGDBError_t    :GDB error type is returned
  
  @param[in]            bCondition     : flag of the the condition
  @param[in,out]        pRule          : Pointer to HEAD SPM check rules
  @param[out]           rgQoSSate      : Modules QoS state value are stored
  @param[out]           rgRepErrorSate : Affected modules error types will be reported
  @param[in]            fCycleTime     : The function cycle time
  
  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  NONE
  @post                 NONE
  
  @InOutCorrelation     Not defined
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         Design Decision

  @author               Robert Thiel | robert.thiel@contiautomotive.com
**************************************************************************************************************************/
static eGDBError_t HEADSPMCheckCondition(boolean bCondition, HEADSPMCheck_t *pRule, uint32 rgQoSSate[], 
                                         uint32 rgRepErrorSate[], float32 fCycleTime)
{
  eGDBError_t eError = GDB_ERROR_NONE;
  uint32 uiTemp;
  float32 fTemp;

  if (bCondition != b_FALSE)
  {
    boolean bLocalCondition = b_FALSE;
    if(pRule->uiCurrentTimer >= pRule->uiNeededTime)
    {
      /* condition TRUE */
      bLocalCondition = b_TRUE;
    }
    else
    {
      bLocalCondition = b_FALSE;
    }

    if (pRule->eQOS >= (HEADModuleQoS_t) HEADModuleQoS_Max)
    {
      eError = GDB_ERROR_ARRAY_OVERFLOW;
    }
    if(pRule->eReportedError >= (HEADModuleRepError_t) HEADModuleRepError_Max)
    {
      eError = GDB_ERROR_ARRAY_OVERFLOW;
    }

    if(eError == GDB_ERROR_NONE)
    {
      if(bLocalCondition == b_TRUE)
      {
        /*condition fulfilled*/
        /*use OR for non-OK cases*/
        if(pRule->eQOS != (HEADModuleQoS_t) HEADModuleQoS_NormalRunning)
        {
          (rgQoSSate[pRule->eQOS])|= pRule->bitModules;
        }
        
        if(pRule->eReportedError != (HEADModuleRepError_t)HEADModuleRepError_NoError)
        {
          (rgRepErrorSate[pRule->eReportedError])|= pRule->bitModules;
        }
      }
      else
      {
        /*condition not fulfilled*/
        /*use AND for OK cases*/
        if(pRule->eQOS == (HEADModuleQoS_t) HEADModuleQoS_NormalRunning)
        {
          (rgQoSSate[pRule->eQOS]) &= (~(pRule->bitModules));
        }

        if(pRule->eReportedError == (HEADModuleRepError_t) HEADModuleRepError_NoError)
        {
          (rgRepErrorSate[pRule->eReportedError])&= (~(pRule->bitModules));
        }
      }
    }

    /* Convert from float ms to integer seconds */
    fTemp = fCycleTime * (float32)HEADTimeScale;
    uiTemp = ROUND_TO_UINT((float32)pRule->uiCurrentTimer + fTemp);
    
    if(uiTemp < HEADTimeMax)
    {
      /* increase timer by current cycle time */
      pRule->uiCurrentTimer = (uint16)uiTemp;
    }
    else
    {
      /* keep maximum allowed value */
      pRule->uiCurrentTimer = (uint16) HEADTimeMax;
    }
  }
  else
  {
    /* set timer to 0*/
    pRule->uiCurrentTimer = 0u;
  }
  return eError;
}/* PRQA S 7002 *//*suppressing cyclomatic complexity for better code maintainability*/


/*************************************************************************************************************************
  Functionname:         HEADSPMRunCheck                                                                             */ /*!

  @brief                Run check over all SPM rules and update state of modules

  @description          This function Evaluates all configured SPM rules and apply state to modules

                        @startuml
                        Start
                            If(check for spm rules and module list availability) then (Yes)
                            While(check for rule is less than the maximum number of Qos) is (Yes)
                            : set all QoS to False for all modules;
                            Endwhile(No)
                            Note left
                            It is 32-bit register array each register representing
                            different states of the Qos, and each bit in a register
                            representing different module.
                            End note
                            :set bits for normal mode to 1 per default;
                            Note right
                            Set all the modules in normal mode
                            (i.e,.set all the bits of register corresponding to normal mode)
                            End note
                            While(check for rule is less than the maximum reported error) is (Yes)
                            :set all reported errors to False for all modules;
                            Endwhile(No)
                            Note left
                            It is 32-bit register array each register representing
                            different states of the SPM reported error, and each
                            bit in a register representing different module.
                            End note
                            :set bits for no error to 1 per default;
                            Note right
                            Set all the modules SPM reported error as no error
                            (i.e,.set all the bits of register corresponding to no error)
                            End note
                            partition RunThroughAllRules {
                            while (Is Rule number is valid?) is (yes)
                            :Fetch the Rule;
                            Note right
                            The Rule Describes the type of HEAD SPM check rules and how to handle them.
                            End note
                            if(check for input signal availability) then (Yes)
                            :Fetch Input Signal from current Rule;
                            Note right
                            Fetch based on Check Signal Bit,the Check Signal Bit define
                            whether the signal or its state needs to be checked
                            End note
                            If(Is it signal state?) then (Yes)
                            : Signal state has to be tested;
                            Else
                            : Signal value has to be tested;
                            Endif
                            Note left
                            Based on Check Function Bits and Check StdDeviation Bits do the
                            necessary Modification to the input signal.
                            (e.g,.Absolute value conversion or apply standard deviation if necessary)
                            End note
                            : Evaluate SPM signal;
                            Note left
                            Compare the Input signal with the Parameter value from HEAD GUI
                            and Update the Result based on the condition is satisfied or not.
                            End note
                            : check the Result and update QoS, Reported error
                            and the internal time counter;
                            Note right
                            For non-OK cases:
                            If the Result is True and it is holding True for the Specific time
                            then we need to update QoS, Reported error as per HEAD configuration.
                            For OK cases :
                            we don't need to wait to update the Qos to Normal Running or
                            Reported error as No error.
                            Update the internal time counter for each cycle.
                            End note
                            endif
                            Endwhile (no)
                            }
                            partition GoThroughQoSandReportedError_SetSevereOne {
                            if(check for error is no error type) then(Yes)
                            while(check for module is less than the number of modules) is (Yes)
                            :fetch the current module;
                            While(check for Qos state is less than maximum Qos state and \nmaximum Qos state is equal to desired state) is (Yes)
                            : QoS stste is set;
                            Endwhile(no)
                            : set Module to desired state;
                            Note left
                            Go through the QoS-State and set the most severe one for each module.
                            End note
                            While(check for reported error state is less than maximum reported \nerror state and maximum reported error state is equal to desired error state) is (Yes)
                            : reported error state is set;
                            Endwhile(no)
                            : set Module to desired error;
                            Note right
                            Go through the Reported Errors and set the most severe one for each module.
                            End note
                            Endwhile(no)
                            endif
                            }
                            Else
                            :update the error type;
                            Endif
                            :return the error type;
                        Stop
                        @enduml

  @return               eGDBError_t  :GDB error type is returned

  @param[in]            pRules       : Stores all the HEAD SPM check rules
  @param[in]            pModuleList  : pointer to module list
  @param[in]            fCycleTime   : The function cycle time
  
  @glob_in              None
  @glob_out             None

  @c_switch_part        
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION   

  @pre                  None
  @post                 None

  @InOutCorrelation     Not defined
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         Design Decision
  
  @author               Armin Vogl | armin.vogl@continental-corporation.com 
*************************************************************************************************************************/
eGDBError_t HEADSPMRunCheck(const HEADSPMRules_t *pRules, const HEADModuleList_t *pModuleList, float32 fCycleTime)
{
  eGDBError_t eError = GDB_ERROR_NONE;  
  uint32 uiModule;
  static const uint32 UINT32_ALL_BITS_ONE = 0xFFFFFFFFu;

  if ((pRules != NULL) && (pModuleList != NULL))
  {
    uint32 uiRule;
    uint32 rgQoSSate[HEADModuleQoS_Max]; /*!< defines if a QoS was set as a bitfield (each bit defines the set sate of a different module */
    uint32 rgRepErrorSate[HEADModuleRepError_Max]; /*!< defines if a reported error was set as a bitfield (each bit defines the set sate of a different module*/

    /* set all QoS to False for all modules*/
    for(uiRule = 0u; uiRule < (uint32)HEADModuleQoS_Max; uiRule++)
    {
      rgQoSSate[uiRule] = 0u;
    }
    /* set bits for normal mode to 1 per default*/
    rgQoSSate[HEADModuleQoS_NormalRunning] = UINT32_ALL_BITS_ONE;

    /* set all reported errors to False for all modules */
    for(uiRule = 0u; uiRule < (uint32)HEADModuleRepError_Max; uiRule++)
    {
      rgRepErrorSate[uiRule] = 0u;
    }
    
    /*set bits for no error to 1 per default*/
    rgRepErrorSate[HEADModuleRepError_NoError] = UINT32_ALL_BITS_ONE;

    /*run through all rules and update the times*/
    for(uiRule = 0u; uiRule < pRules->uiNrOfSPMRules; uiRule++)
    {
      HEADSPMCheck_t *pThisRule = HEADSPMGetRule(pRules->rgSPMRules, uiRule);

      if(pThisRule->pInputSignal != NULL)
      {
        /* PRQA S 1482 1 */ /* This cast to enum type is valid */
        eHEADSPMCheckBitsSignal_t eCheckSignal = (eHEADSPMCheckBitsSignal_t)HEADSPMGetBitsSignal(pThisRule->bitCheckType);

        boolean bResult = b_FALSE;

        if(eCheckSignal == HEADSPMCheckBitsSignal_SigState)
        {
          /* Signal state has to be tested */
          sint32 iVal = (sint32) pThisRule->pInputSignal->eSignalQuality;
          HEADSPMFunctionCheck_sint32(pThisRule, &iVal);
          HEADSPMEvaluate_sint32(pThisRule, &iVal, &bResult);
        }
        else
        {
          /* Signal value has to be tested */
          switch (pThisRule->pInputSignal->eSignalType)
          {
          case HEADInputSignalType_SignedInt:
            {
              sint32 iVal;
              (void)HEADGetInputValue_sint32((*(pThisRule->pInputSignal)), 0, &iVal);
              HEADSPMFunctionCheck_sint32(pThisRule, &iVal);
              HEADSPMEvaluate_sint32(pThisRule, &iVal, &bResult);
            }
            break;
          case HEADInputSignalType_UnsignedInt:
            {
              uint32 uiVal;
              (void)HEADGetInputValue_uint32((*(pThisRule->pInputSignal)), 0, &uiVal);
              HEADSPMFunctionCheck_uint32(pThisRule, &uiVal);
              HEADSPMEvaluate_uint32(pThisRule, &uiVal, &bResult);
            }
            break;          
          case HEADInputSignalType_Float:
            {
              float32 fVal;
              (void)HEADGetInputValue_float32((*(pThisRule->pInputSignal)), 0.0f, &fVal);
              HEADSPMFunctionCheck_float32(pThisRule, &fVal);
              HEADSPMEvaluate_float32(pThisRule, &fVal, &bResult);
            }
            break;
          case HEADInputSignalType_Bool:
            {
              boolean bVal;
              (void)HEADGetInputValue_boolean((*(pThisRule->pInputSignal)), b_FALSE, &bVal);
              HEADSPMEvaluate_boolean(pThisRule, &bVal, &bResult);
            }
            break;
          default:
            eError = GDB_ERROR_UNKNOWN_TYPE; /*PRQA S 2982 #date: 2020-06-02, reviewer: Nalina M, reason: No side effect, Generic Implementation */
            break;
          }
        }
        /* call the handler */
        eError = HEADSPMCheckCondition(bResult, pThisRule, &rgQoSSate[0], &rgRepErrorSate[0], fCycleTime);
      }
    } /*for*/

    if(eError == GDB_ERROR_NONE)
    {
      /*now go through the QoS-State and set the most severe one for each module*/
      for(uiModule = 0u; uiModule < pModuleList->uiNrOfModules; uiModule++)
      {
        uint32 uiQoS;
        eHEADModuleQoS_t eDesiredState = HEADModuleQoS_Max; /*default -> no QoS State*/
        eHEADModuleRepError_t eDesiredError = HEADModuleRepError_Max;
        uint32 uiCurrentModuleBit;
        HEADModule_t *pCurrModule;

        uiCurrentModuleBit = ((uint32)1) << uiModule;
        pCurrModule = HEADGetModule(pModuleList, uiModule);

        /*loop over the rules, and stop if a QoS is set*/
        for(uiQoS = 0u; (uiQoS < (uint32)HEADModuleQoS_Max) && (eDesiredState == HEADModuleQoS_Max); uiQoS++)
        {
          /*if the bit is set, save QoS state*/
          if ((rgQoSSate[uiQoS] & uiCurrentModuleBit) != FALSE)
          {
            /* PRQA S 1482 1 */ /* HEADModuleQoS_Max ensures valid cast to enum type */
            eDesiredState = (eHEADModuleQoS_t)uiQoS; 
          }
        }
        /*QoS State for this module found?*/
        if(eDesiredState != HEADModuleQoS_Max)
        {
          /*set Module to desired state*/
          pCurrModule->eQoS = eDesiredState;
        } /*else keep last qos state*/

        /*loop over the rules, and stop if a RepError is set*/
        for(uiQoS = 0u; (uiQoS < (uint32)HEADModuleRepError_Max) && (eDesiredError == HEADModuleRepError_Max); uiQoS++)
        {
          /*if the bit is set, save QoS state*/
          if ((rgRepErrorSate[uiQoS] & uiCurrentModuleBit) != FALSE)
          {
            /* PRQA S 1482 1 */ /* HEADModuleRepError_Max ensures valid cast to enum type */
            eDesiredError = (eHEADModuleRepError_t)uiQoS;
          } /* else keep last error state */
        }
        /*QoS State for this module found?*/
        if(eDesiredError != HEADModuleRepError_Max)
        {
          /*set Module to desired state*/
          pCurrModule->eReportedError = eDesiredError;
        }
      }
    }
  }
  else
  {
    eError = GDB_ERROR_POINTER_NULL;
  }

  return eError;
}/* PRQA S 7002 *//*suppressing cyclomatic complexity for better code maintainability*/

/* ***********************************************************************************************************************
  Functionname:         HEADSPMEvaluate_sint32                                                                      */ /*! 

  @brief                Evaluate SPM signal of type signed integer

  @description          Evaluate SPM signal of type signed integer
  
                        @startuml
                        Start
                            :get operator type;
                            If(Check Operator type) then (True)
                            If( check for operator is equal to smaller  or Equal type) then (yes)
                            note left
                            Remaining operator  (Smaller, Greater Or Equal, Greater and not equal) type will be checked for same
                            End note
                            If(check  for parameter value is equal to SPM check rules parameter value) then (Yes)
                            : updated result is true;
                            Else 
                            : updated result is false;
                            Endif
                            endif
                            :update operator type in particular bit;
                            note left
                            Any one of the operator  (Smaller, Smaller Or Equal,
                            Greater Or Equal, Greater and not equal) type will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void

  @param[in]            pThisRule : pointer to head spm check rules
  @param[in]            pVal      : pointer to local value
  @param[out]           bResult   : pointer to store result

  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     Not defined
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         Design Decision

  @author               Robert Thiel | robert.thiel@contiautomotive.com
***************************************************************************************************************************/
static void HEADSPMEvaluate_sint32(const HEADSPMCheck_t *pThisRule, const sint32 *pVal, boolean *bResult)
{
  /* PRQA S 1482 1 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsOp_t eCheckOperator = (eHEADSPMCheckBitsOp_t)HEADSPMGetBitsOperator(pThisRule->bitCheckType);
  float32 f32Value = HEADConvf16Tof32(pThisRule->f16Value);
  {
    const sint32 i32Value = ROUND_TO_INT(f32Value);
    switch(eCheckOperator)
    {
      case HEADSPMCheckBitsOp_Equals:
        *bResult = (*pVal == i32Value)? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_EqualsNot:
        *bResult = (*pVal != i32Value)? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_Greater:
        *bResult = (*pVal > i32Value)? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_GreaterOrEqual:
        *bResult = (*pVal >= i32Value)? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_Smaller:
        *bResult = (*pVal < i32Value) ? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_SmallerOrEqual:
        *bResult = (*pVal <= i32Value) ? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_Max:
      default:
        break;
    }
  }
}

/* ***********************************************************************************************************************
  Functionname:         HEADSPMEvaluate_uint32                                                                      */ /*! 

  @brief                Evaluate SPM signal of type unsigned integer

  @description          Evaluate SPM signal of type unsigned integer
  
                        @startuml
                        Start
                            :get operator type;
                            If(Check Operator type) then (True)
                            If( check for operator is equal to smaller  or Equal type) then (yes)
                            note left
                            Remaining operator  (Smaller, Greater Or Equal, Greater and not equal) type will be checked for same
                            End note
                            If(check  for parameter value is equal to SPM check rules parameter value) then (Yes)
                            : updated result is true;
                            Else 
                            : updated result is false;
                            Endif
                            endif
                            :update operator type in particular bit;
                            note left
                            Any one of the operator  (Smaller, Smaller Or Equal,
                            Greater Or Equal, Greater and not equal) type will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void
  
  @param[in]            pThisRule : Pointer to head spm check rules
  @param[in]            pVal      : Pointer to local value
  @param[out]           bResult   : Pointer to store result

  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     Not defined
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         Design Decision

  @author               Robert Thiel robert.thiel@contiautomotive.com
**************************************************************************************************************************/
static void HEADSPMEvaluate_uint32(const HEADSPMCheck_t *pThisRule,const uint32 *pVal, boolean *bResult)
{
  /* PRQA S 1482 1 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsOp_t eCheckOperator = (eHEADSPMCheckBitsOp_t)HEADSPMGetBitsOperator(pThisRule->bitCheckType);
  float32 f32Value = HEADConvf16Tof32(pThisRule->f16Value);
  const uint32 ui32Value = ROUND_TO_UINT(f32Value);
  switch(eCheckOperator)
  {
    case HEADSPMCheckBitsOp_Equals:
      *bResult = (*pVal == ui32Value)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_EqualsNot:
      *bResult = (*pVal != ui32Value)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Greater:
      *bResult = (*pVal > ui32Value)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_GreaterOrEqual:
      *bResult = (*pVal >= ui32Value)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Smaller:
      *bResult = (*pVal < ui32Value) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_SmallerOrEqual:
      *bResult = (*pVal <= ui32Value) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Max:
    default:
      break;
  }
}

/* ***********************************************************************************************************************
  Functionname:         HEADSPMEvaluate_float32                                                                     */ /*! 

  @brief                Evaluate SPM signal of type float

  @description          Evaluate SPM signal of type float
  
                        @startuml
                        Start
                            :get operator type;
                            If(Check Operator type) then (True)
                            If( check for operator is equal to smaller  or Equal type) then (yes)
                            note left
                            Remaining operator  (Smaller, Greater Or Equal, Greater and not equal) type will be checked for same
                            End note
                            If(check  for parameter value is equal to SPM check rules parameter value) then (Yes)
                            : updated result is true;
                            Else 
                            : updated result is false;
                            Endif
                            endif
                            :update operator type in particular bit;
                            note left
                            Any one of the operator  (Smaller, Smaller Or Equal,
                            Greater Or Equal, Greater and not equal) type will be updated
                            End note
                            endif
                        stop
                        @enduml
                        
  @return               void                        

  @param[in]            pThisRule : Pointer to head spm check rules
  @param[in]            pVal      : Pointer to local value
  @param[out]           bResult   : Pointer to store result

  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     Not defined
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         Design Decision

  @author               Robert Thiel robert.thiel@contiautomotive.com
*****************************************************************************************************************************/
static void HEADSPMEvaluate_float32(const HEADSPMCheck_t *pThisRule, const float32 *pVal, boolean *bResult)
{
  /* PRQA S 1482 1 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsOp_t  eCheckOperator = (eHEADSPMCheckBitsOp_t)HEADSPMGetBitsOperator(pThisRule->bitCheckType);
  const float32 tmpCompareValue = HEADConvf16Tof32(pThisRule->f16Value);
  switch(eCheckOperator)
  {
    case HEADSPMCheckBitsOp_Equals:
      *bResult = (F32_IS_ZERO(*pVal - tmpCompareValue)) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_EqualsNot:
      *bResult = (F32_IS_NZERO(*pVal - tmpCompareValue)) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Greater:
      *bResult = (*pVal > tmpCompareValue) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_GreaterOrEqual:
      *bResult = (*pVal >= tmpCompareValue)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Smaller:
      *bResult = (*pVal < tmpCompareValue)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_SmallerOrEqual:
      *bResult = (*pVal <= tmpCompareValue)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Max:
    default: 
      break;
  }
}

/* ***********************************************************************************************************************
  Functionname:         HEADSPMEvaluate_boolean                                                                     */ /*! 

  @brief                Evaluate SPM signal of type boolean

  @description          Evaluate SPM signal of type boolean
  
                        @startuml
                        Start
                            :get operator type;
                            If(Check Operator type) then (True)
                            If( check for operator is equal to smaller  or Equal type) then (yes)
                            note left
                            Remaining operator  (Smaller, Greater Or Equal, Greater and not equal) type will be checked for same
                            End note
                            If(check  for parameter value is equal to SPM check rules parameter value) then (Yes)
                            : updated result is true;
                            Else 
                            : updated result is false;
                            Endif
                            endif
                            :update operator type in particular bit;
                            note left
                            Any one of the operator  (Smaller, Smaller Or Equal,
                            Greater Or Equal, Greater and not equal) type will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void
  
  @param[in]            pThisRule : Pointer to head spm check rules
  @param[in]            pVal      : Pointer to local value
  @param[out]           bResult   : Pointer to store result

  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     Not defined
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         Design Decision

  @author               Robert Thiel robert.thiel@contiautomotive.com
***************************************************************************************************************************/
static void HEADSPMEvaluate_boolean(const HEADSPMCheck_t *pThisRule, const boolean *pVal, boolean *bResult)
{
  /* PRQA S 1482 1 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsOp_t eCheckOperator = (eHEADSPMCheckBitsOp_t)HEADSPMGetBitsOperator(pThisRule->bitCheckType);
  float32 f32Value = HEADConvf16Tof32(pThisRule->f16Value);
  const uint32 ui32Value = ROUND_TO_UINT(f32Value);
  boolean bTemp = (ui32Value > 0u)? b_TRUE : b_FALSE;
  /*consistent to Autocoder - some operators are nonsens for bool*/
  switch(eCheckOperator)
  {
    case HEADSPMCheckBitsOp_Equals:
      *bResult = (*pVal == bTemp)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_EqualsNot:
      *bResult = (*pVal != bTemp)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Greater:
      *bResult = (*pVal > bTemp)? b_TRUE : b_FALSE;/*PRQA S 4505 9 #date: 2020-06-02, reviewer: Nalina M, reason: Supressing void pointer conversions*/
      break;
    case HEADSPMCheckBitsOp_GreaterOrEqual:
      *bResult = (*pVal >= bTemp)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Smaller:
      *bResult = (*pVal < bTemp) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_SmallerOrEqual:
      *bResult = (*pVal <= bTemp) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Max:
    default:
      break;
  }
}

/*************************************************************************************************************************
  Functionname:         HEADSPMFunctionCheck_sint32                                                                 */ /*!

  @brief                Do functional check of SPM signal of type signed integer

  @description          Do functional check of SPM signal of type signed integer
  
                        @startuml
                        Start
                            :get type of function and standard deviation;
                            If(Is funtion ABS type) then (Yes)
                            :update parameter value;
                            Endif
                            If(check standard deviation type ) then (True)
                            :update standard deviation in parameter variable;
                            note left
                            Incremented, decremented or not modified Standard 
                            deviation value will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void

  @param[in]            pThisRule : Pointer to head spm check rules
  @param[in,out]        pVal      : Pointer to local value
  
  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     Not defined
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         Design Decision

  @author               Armin Vogl | armin.vogl@continental-corporation.com                  
*************************************************************************************************************************/
static void HEADSPMFunctionCheck_sint32(const HEADSPMCheck_t *pThisRule, sint32 *pVal)
{
  /* PRQA S 1482 2 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsStdDeviation_t eCheckStdDev   = (eHEADSPMCheckBitsStdDeviation_t) HEADSPMGetBitsStdDeviation(pThisRule->bitCheckType);
  eHEADSPMCheckBitsFunction_t     eCheckFunction = (eHEADSPMCheckBitsFunction_t)HEADSPMGetBitsFunction(pThisRule->bitCheckType);
        
  if (eCheckFunction == HEADSPMCheckBitsFunction_ABS)
  {
    *pVal = ABS(*pVal);
  }
    /* apply standard deviation if necessary */
  switch(eCheckStdDev)
  {
    case HEADSPMCheckBitsStdDeviation_Minus:
      *pVal-= (sint32)HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_Plus:
      *pVal+= (sint32)HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_No:
    case HEADSPMCheckBitsStdDeviation_Max:
    default: /*PRQA S 2016 #date: 2020-06-02, reviewer: Nalina M, reason: Defensive programming*/
      break;
  }
}

/*************************************************************************************************************************
  Functionname:         HEADSPMFunctionCheck_uint32                                                                  */ /*!

  @brief                Do functional check of SPM signal of type unsigned integer

  @description          Do functional check of SPM signal of type unsigned integer

                        @startuml
                         Start
                            :get type of standard deviation;                         
                            If(check standard deviation type ) then (True)
                            : update standard deviation in parameter variable;
                            note left
                            Incremented, decremented or not modified Standard 
                            deviation value will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void

  @param[in]            pThisRule : Pointer to head spm check rules
  @param[in,out]        pVal      : Pointer to local value
  
  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     Not defined
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         Design Decision

  @author               Armin Vogl | armin.vogl@continental-corporation.com        
*************************************************************************************************************************/
static void HEADSPMFunctionCheck_uint32(const HEADSPMCheck_t *pThisRule, uint32 *pVal)
{
  /* PRQA S 1482 1 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsStdDeviation_t eCheckStdDev   = (eHEADSPMCheckBitsStdDeviation_t) HEADSPMGetBitsStdDeviation(pThisRule->bitCheckType);
  
  /* apply standard deviation if necessary */
  switch(eCheckStdDev)
  {
    case HEADSPMCheckBitsStdDeviation_Minus:
      *pVal-= (uint32)HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_Plus:
      *pVal+= (uint32)HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_No:
    case HEADSPMCheckBitsStdDeviation_Max:
    default: 
      break;
  }
}

/*************************************************************************************************************************
  Functionname:         HEADSPMFunctionCheck_float32                                                                */ /*!

  @brief                Do functional check of the SPM signal of type float

  @description          Do functional check of the SPM signal of type float

                        @startuml
                        Start
                            :get type of function and standard deviation;
                            If(Is funtion ABS type) then (Yes)
                            :update parameter value;
                            Endif
                            If(check standard deviation type ) then (True)
                            :update standard deviation in parameter variable;
                            note left
                            Incremented, decremented or not modified Standard 
                            deviation value will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void

  @param[in]            pThisRule : pointer to head spm check rules
  @param[in,out]        pVal      : pointer to local value
  
  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     Not defined
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         Design Decision

  @author               Armin Vogl | armin.vogl@continental-corporation.com      
  *************************************************************************************************************************/
static void HEADSPMFunctionCheck_float32(const HEADSPMCheck_t *pThisRule, float32 *pVal)
{
  /* PRQA S 1482 2 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsStdDeviation_t eCheckStdDev   = (eHEADSPMCheckBitsStdDeviation_t) HEADSPMGetBitsStdDeviation(pThisRule->bitCheckType);
  eHEADSPMCheckBitsFunction_t     eCheckFunction = (eHEADSPMCheckBitsFunction_t)HEADSPMGetBitsFunction(pThisRule->bitCheckType);
  
  if (eCheckFunction == HEADSPMCheckBitsFunction_ABS)
  {
    *pVal = fABS(*pVal);
  }
  /* apply standard deviation if necessary */
  switch(eCheckStdDev)
  {
    case HEADSPMCheckBitsStdDeviation_Minus:
      *pVal-= HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_Plus:
      *pVal+= HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_No:
    case HEADSPMCheckBitsStdDeviation_Max:
    default: 
      break;
  }
}

#endif /* #if (MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION) */
#endif /* !(MEDIC_CFG_HEAD20) */

/**@}*/
