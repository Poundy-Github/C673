/**
 * \file
 *
 * \brief AUTOSAR EcuM
 *
 * This file contains the implementation of the AUTOSAR
 * module EcuM.
 *
 * \version 5.15.8
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2021 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
/* !LINKSTO EcuM.Config.EcuMMainFunctionPeriod, 1 */





/*==================[inclusions]============================================*/

#include <Mcu.h>          /* MCU module types                  */
/* Macro for preventing redundant declarations of EcuM_MainFunction(),
 * since the function prototype is also generated by the SchM. */
#define ECUM_INTERNAL_USE
#include <EcuM.h>
#include <EcuM_Int.h>     /* EcuM private header               */
#include <EcuM_Cfg.h>
#include <SchM_EcuM.h>           /* SchM API for EcuM */
#include <SchM_EcuM_1_Core_1.h>
#include <SchM_EcuM_1_Core_2.h>
#include <SchM_EcuM_1_Core_3.h>

#include <Det.h>
#include <Dem.h>
#include <Eb_Intgr_McuArchClockInit.h>
#include <PbcfgM.h>
#include <Port.h>
#include <Spi.h>
#include <Wdg_17_Scu.h>
#include <Adc.h>
#include <Icu_17_TimerIp.h>
#include <Pwm_17_GtmCcu6.h>
#include <Dma.h>
#include <I2c.h>
#include <Smu.h>
#include <EcuM_UserCallout.h>



/*------------------[MultiCore variables]-----------------------------------------------*/


#if(defined ECUM_GET_CORE_ID)
#error ECUM_GET_CORE_ID already defined
#endif
#if (ECUM_MULTICORE_ENABLED == TRUE)
/** \brief Returns the core ID that is currently active. */
#define ECUM_GET_CORE_ID() GetCoreID()
#else
#define ECUM_GET_CORE_ID() 0U
#endif /* (ECUM_MULTICORE_ENABLED == TRUE) */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_0 (void);
STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_0 (void);
STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_1 (void);
STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_1 (void);
STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_2 (void);
STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_2 (void);
STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_3 (void);
STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_3 (void);

STATIC FUNC(void, ECUM_CODE) EcuM_DriverInitListOneCall(uint8 id);

#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

/*==================[external constants]====================================*/
#define ECUM_START_SEC_CONST_8
#include <EcuM_MemMap.h>

/* Wake-up Source ID mapping */
CONST(uint8, ECUM_CONST) EcuM_WksMapping[ECUM_WKS_ID_MAXVAL + 1U] =
{
  0U,
  1U,
  2U,
  3U,
  4U,
  5U,
  6U,
};

#define ECUM_STOP_SEC_CONST_8
#include <EcuM_MemMap.h>


#define ECUM_START_SEC_CONST_16
#include <EcuM_MemMap.h>

/* !LINKSTO EcuM4004,1 */
/* timeout for wakeup source */
CONST(uint16, ECUM_CONST) EcuM_WksValTimeout[ECUM_WKSCONFIGNUM] =
{
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_POWER */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_RESET */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_INTERNAL_RESET */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_INTERNAL_WDG */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_EXTERNAL_WDG */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_STANDBY_RESET */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_PUBLIC_CAN */
};

#define ECUM_STOP_SEC_CONST_16
#include <EcuM_MemMap.h>

#define ECUM_START_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>


/*------------------[Wakeup Sources]----------------------------------------*/

/* configurations of Wakeup Sources */
CONST(EcuM_WksConfigType, ECUM_CONST) EcuM_WksConfigList[ECUM_WKSCONFIGNUM] =
{
/* !LINKSTO EcuM2166,1 */
  /* ECUM_WKSOURCE_POWER */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_POWER_ON_RESET,   /* Reset Reason */
    0U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_RESET */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* Reset Reason */
    1U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_INTERNAL_RESET */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* Reset Reason */
    2U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_INTERNAL_WDG */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_SUPPLY_WDOG_RESET,   /* Reset Reason */
    3U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_EXTERNAL_WDG */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* Reset Reason */
    4U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_STANDBY_RESET */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_STBYR_RESET,   /* Reset Reason */
    5U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_PUBLIC_CAN */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* No valid Reset Reason */
    6U   /* Wakeup Source Id */
  },
};

/*------------------[Sleep Modes]-------------------------------------------*/
CONST(EcuM_SleepModeConfigType, ECUM_CONST) EcuM_SleepModeConfigList[ECUM_SLEEPMODECONFIGNUM] =
{

  {
    
    ECUM_EcuMSleepMode_0_WKUP_MASK, /* Wakeup event mask of sleep mode EcuMSleepMode_0 */
    /* Sleep mode: EcuMSleepMode_0, ID: 0 */
    #if (defined McuConf_McuModeSettingConf_McuModeSettingConf_0)
    McuConf_McuModeSettingConf_McuModeSettingConf_0,
    #else
    McuModeSettingConf_0,
    #endif
    TRUE/* Suspend flag */
  },

};

/*------------------[Errors reporting to Dem]-------------------------------------------*/

CONST(Dem_EventIdType, ECUM_CONST) EcuM_DemErrRamChkFailed =
  87U;  /* Error for Ram check failure */


#define ECUM_STOP_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>

#define ECUM_START_SEC_CONST_8
#include <EcuM_MemMap.h>

/*------------------[EcuMShutdownCause]-------------------------------------------*/

#if (ECUM_DEV_ERROR_DETECT == STD_ON)
/* Array holding the configured values of Shutdown Causes */
CONST(EcuM_ShutdownCauseType, ECUM_CONST)
   EcuM_ValidShutdownCause[ECUM_SHUTDOWNCAUSECONFIGNUM] =
{
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_UNKNOWN,
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_ECU_STATE,
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_WDGM,
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_DCM,
};
#endif

#define ECUM_STOP_SEC_CONST_8
#include <EcuM_MemMap.h> 

#define ECUM_START_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>
/** \brief The initial core context for a single core. */
CONST(EcuM_CoreContextType, ECUM_CONST) EcuM_InitialContext =
{
  {
    /* WAKEUP STATUS */
    ECUM_WKSMASKALL,  /* Disabled */
    0U, /* None */
    0U, /* Pending */
    0U, /* Validated */
    0U, /* Expired */
    0U, /* Started */
    0U, /* Stopped */
  },
  {
    /* WAKEUP INDICATION */
    0U, /* Disabled */
    0U, /* Expired */
    0U, /* None */
    0U, /* Pending */
    0U, /* Validated */
  },
  0U, /* WAKEUP SOURCE VALIDATION COUNTER */
  0U, /* EcuM State */
  0U,  /* EcuM Sleep Mode */
};


#define ECUM_STOP_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>
/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*------------[EcuM Multi-Core internal data]---------------*/

/* !LINKSTO EcuM.Impl.MemoryMapping.InstanceData,1 */
#define ECUM_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_MemMap.h>

/** \brief The EcuM core specific context data.
 **
 ** This variable holds the core-specific run time data of the EcuM
 ** master core. */
STATIC VAR(EcuM_CoreContextType, ECUM_VAR) EcuM_Core0_Context;

#define ECUM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_MemMap.h>

#define ECUM_1_Core_1_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_1_Core_1_MemMap.h>

/** \brief The EcuM core specific context data.
 **
 ** This variable holds the core-specific run time data of each EcuM
 ** slave core. */
STATIC VAR(EcuM_CoreContextType, ECUM_VAR) EcuM_Core1_Context;

#define ECUM_1_Core_1_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_1_Core_1_MemMap.h>

#define ECUM_1_Core_2_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_1_Core_2_MemMap.h>

/** \brief The EcuM core specific context data.
 **
 ** This variable holds the core-specific run time data of each EcuM
 ** slave core. */
STATIC VAR(EcuM_CoreContextType, ECUM_VAR) EcuM_Core2_Context;

#define ECUM_1_Core_2_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_1_Core_2_MemMap.h>

#define ECUM_1_Core_3_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_1_Core_3_MemMap.h>

/** \brief The EcuM core specific context data.
 **
 ** This variable holds the core-specific run time data of each EcuM
 ** slave core. */
STATIC VAR(EcuM_CoreContextType, ECUM_VAR) EcuM_Core3_Context;

#define ECUM_1_Core_3_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_1_Core_3_MemMap.h>


#define ECUM_START_SEC_INTERNAL_VAR_POWER_ON_INIT_UNSPECIFIED
#include <EcuM_MemMap.h>

VAR(EcuM_ShutdownInfoType, ECUM_VAR_POWER_ON_INIT)
  EcuM_ShutdownInfo[ECUM_STORED_SHUTDOWN_OPERATIONS] = {
    {0U, 0U, 0U, 0U}
  };

#define ECUM_STOP_SEC_INTERNAL_VAR_POWER_ON_INIT_UNSPECIFIED
#include <EcuM_MemMap.h>

/*==================[external function definitions]=========================*/
#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>
/*------------------[Callouts from STARTUP state]---------------------------*/

/* Configured Initialization List Zero items */
FUNC(void, ECUM_CODE) EcuM_DefaultInitListZero(void)
{
  /* *** Call service Init of module Det *** */
  Det_Init();
}


/* Configured Initialization List One items */
FUNC(void, ECUM_CODE) EcuM_DefaultInitListOne(void)
{
  uint8 i;

  for (i = 0; i < ECUM_NUM_DRIVERS_INIT_LIST_ONE; i++ )
  {
    EcuM_DriverInitListOneCall(ECUM_DRIVER_INIT_LIST_ONE(i));
  }
}

/*------------------[Callouts from SLEEP state]--------------------------*/
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>
/*==================[internal function definitions]=========================*/

/*------------[EcuM Multi-Core internal function definitions]---------------*/

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

FUNC(void, ECUM_CODE) EcuM_EnterExclusiveArea(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
    case 0:
    {
      EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_0();
      break;
    }
    case 1:
    {
      EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_1();
      break;
    }
    case 2:
    {
      EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_2();
      break;
    }
    case 3:
    {
      EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_3();
      break;
    }
    default:
    {
      /* ERROR */
      break;
    }
  }
}

FUNC(void, ECUM_CODE) EcuM_ExitExclusiveArea(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
    case 0:
    {
      EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_0();
      break;
    }
    case 1:
    {
      EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_1();
      break;
    }
    case 2:
    {
      EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_2();
      break;
    }
    case 3:
    {
      EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_3();
      break;
    }
    default:
    {
      /* ERROR */
      break;
    }
  }
}

STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_0 (void)
{
  /* SchM function has no return value */
  SchM_Enter_EcuM_SCHM_ECUM_EXCLUSIVE_AREA_0();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_0 (void)
{
  /* SchM function has no return value */
  SchM_Exit_EcuM_SCHM_ECUM_EXCLUSIVE_AREA_0();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_1 (void)
{
  /* SchM function has no return value */
  SchM_Enter_EcuM_1_Core_1_SCHM_ECUM_EXCLUSIVE_AREA_1();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_1 (void)
{
  /* SchM function has no return value */
  SchM_Exit_EcuM_1_Core_1_SCHM_ECUM_EXCLUSIVE_AREA_1();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_2 (void)
{
  /* SchM function has no return value */
  SchM_Enter_EcuM_1_Core_2_SCHM_ECUM_EXCLUSIVE_AREA_2();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_2 (void)
{
  /* SchM function has no return value */
  SchM_Exit_EcuM_1_Core_2_SCHM_ECUM_EXCLUSIVE_AREA_2();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_3 (void)
{
  /* SchM function has no return value */
  SchM_Enter_EcuM_1_Core_3_SCHM_ECUM_EXCLUSIVE_AREA_3();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_3 (void)
{
  /* SchM function has no return value */
  SchM_Exit_EcuM_1_Core_3_SCHM_ECUM_EXCLUSIVE_AREA_3();
}


#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

#if (ECUM_MULTICORE_ENABLED == TRUE)

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

FUNC(void, ECUM_CODE) EcuM_GetResourceScheduler(void)
{
#ifdef OS_AUTOSAROS_VER
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();
#endif

#ifndef OS_AUTOSAROS_VER
  (void)GetResource(RES_SCHEDULER);
#else
  switch(coreID)
  {
    case 0:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)GetResource(RES_SCHEDULER);
#else
      (void)GetResource(RES_SCHEDULER_0);
#endif
       break;
    }
    case 1:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)GetResource(RES_SCHEDULER);
#else
      (void)GetResource(RES_SCHEDULER_1);
#endif
       break;
    }
    case 2:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)GetResource(RES_SCHEDULER);
#else
      (void)GetResource(RES_SCHEDULER_2);
#endif
       break;
    }
    case 3:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)GetResource(RES_SCHEDULER);
#else
      (void)GetResource(RES_SCHEDULER_3);
#endif
       break;
    }
    default:
    {
      /* ERROR */
      break;
    }
  }
#endif /* #ifndef OS_AUTOSAROS_VER */
}

FUNC(void, ECUM_CODE) EcuM_ReleaseResourceScheduler(void)
{
#ifdef OS_AUTOSAROS_VER
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();
#endif

#ifndef OS_AUTOSAROS_VER
  (void)ReleaseResource(RES_SCHEDULER);
#else
  switch(coreID)
  {
    case 0:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)ReleaseResource(RES_SCHEDULER);
#else
      (void)ReleaseResource(RES_SCHEDULER_0);
#endif
       break;
    }
    case 1:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)ReleaseResource(RES_SCHEDULER);
#else
      (void)ReleaseResource(RES_SCHEDULER_1);
#endif
       break;
    }
    case 2:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)ReleaseResource(RES_SCHEDULER);
#else
      (void)ReleaseResource(RES_SCHEDULER_2);
#endif
       break;
    }
    case 3:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)ReleaseResource(RES_SCHEDULER);
#else
      (void)ReleaseResource(RES_SCHEDULER_3);
#endif
       break;
    }
    default:
    {
      /* ERROR */
      break;
    }
  }
#endif /* #ifndef OS_AUTOSAROS_VER */
}

FUNC(Std_ReturnType, ECUM_CODE) EcuM_Send_SlaveCoreReadyPort(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  Std_ReturnType ret = E_NOT_OK;
  Std_ReturnType schMSendResult;

  if (ECUM_CORE_ID_MASTER != coreID)
  {
      switch(coreID)
      {
        case 1:
        {
          schMSendResult = SchM_Send_EcuM_1_Core_1_EcuM_SlaveCoreReadyPort(GetCoreID());
          ret = (schMSendResult == SCHM_E_OK) ? E_OK : E_NOT_OK;
          break;
        }
        case 2:
        {
          schMSendResult = SchM_Send_EcuM_1_Core_2_EcuM_SlaveCoreReadyPort(GetCoreID());
          ret = (schMSendResult == SCHM_E_OK) ? E_OK : E_NOT_OK;
          break;
        }
        case 3:
        {
          schMSendResult = SchM_Send_EcuM_1_Core_3_EcuM_SlaveCoreReadyPort(GetCoreID());
          ret = (schMSendResult == SCHM_E_OK) ? E_OK : E_NOT_OK;
          break;
        }
        default:
        {
          break;
        }
      }
  }

  return ret;
}

/* !LINKSTO EcuM.Impl.EcuM_MasterCoreSync,1 */
/* !LINKSTO EcuM.Impl.Source.SlaveMasterCoreSync,1 */
FUNC(Std_ReturnType, ECUM_CODE) EcuM_MasterCoreSync(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();
  EcuM_SyncActionType syncResult = ECUM_CONTINUE_SYNC;
  Std_ReturnType schMReceiveResult = E_NOT_OK;

  if (ECUM_CORE_ID_MASTER != coreID)
  {
    boolean EcuM_IsMasterReady = FALSE;
    do
    {
      switch(coreID)
      {
        case 1:
        {
          schMReceiveResult = SchM_Receive_EcuM_1_Core_1_EcuM_MasterCoreSyncPort(&EcuM_IsMasterReady);
          break;
        }
        case 2:
        {
          schMReceiveResult = SchM_Receive_EcuM_1_Core_2_EcuM_MasterCoreSyncPort(&EcuM_IsMasterReady);
          break;
        }
        case 3:
        {
          schMReceiveResult = SchM_Receive_EcuM_1_Core_3_EcuM_MasterCoreSyncPort(&EcuM_IsMasterReady);
          break;
        }
        default:
        {
          break;
        }
      }
      if (TRUE == EcuM_IsMasterReady)
      {
        break;
      }
      /* !LINKSTO EcuM.Impl.EcuM_OnCoreSync,1 */
      syncResult = EcuM_OnCoreSync();
    } while (syncResult != ECUM_ABORT_SYNC);
  }

  return ((ECUM_CONTINUE_SYNC == syncResult) && (schMReceiveResult == SCHM_E_OK)) ? E_OK : E_NOT_OK;
}
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

#define ECUM_1_Core_1_START_SEC_CODE
#include <EcuM_1_Core_1_MemMap.h>
FUNC(void, ECUM_1_Core_1_CODE) EcuM_1_Core_1_MainFunction(void)
{
   EcuM_MainFunction();
}
#define ECUM_1_Core_1_STOP_SEC_CODE
#include <EcuM_1_Core_1_MemMap.h>

#define ECUM_1_Core_2_START_SEC_CODE
#include <EcuM_1_Core_2_MemMap.h>
FUNC(void, ECUM_1_Core_2_CODE) EcuM_1_Core_2_MainFunction(void)
{
   EcuM_MainFunction();
}
#define ECUM_1_Core_2_STOP_SEC_CODE
#include <EcuM_1_Core_2_MemMap.h>

#define ECUM_1_Core_3_START_SEC_CODE
#include <EcuM_1_Core_3_MemMap.h>
FUNC(void, ECUM_1_Core_3_CODE) EcuM_1_Core_3_MainFunction(void)
{
   EcuM_MainFunction();
}
#define ECUM_1_Core_3_STOP_SEC_CODE
#include <EcuM_1_Core_3_MemMap.h>


#endif /* (ECUM_MULTICORE_ENABLED == TRUE) */

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>
/* !LINKSTO EcuM.Impl.EcuM_GetCoreInstance,1 */
FUNC_P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_CODE) EcuM_GetCoreInstance(void)
{
  P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_APPL_DATA) inst = NULL_PTR;

#if (ECUM_MULTICORE_ENABLED == TRUE)
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
    case 0:
    {
      inst = &EcuM_Core0_Context;
      break;
    }
    case 1:
    {
      inst = &EcuM_Core1_Context;
      break;
    }
    case 2:
    {
      inst = &EcuM_Core2_Context;
      break;
    }
    case 3:
    {
      inst = &EcuM_Core3_Context;
      break;
    }
    default:
    {
      /* No EcuM instance exists for core. */
      break;
    }
  }
#else
  inst = &EcuM_Core0_Context;
#endif

  return inst;
}

/* !LINKSTO EcuM.Impl.EcuM_GetMasterCoreInstance,1 */
FUNC_P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_CODE) EcuM_GetMasterCoreInstance(void)
{
  return &EcuM_Core0_Context;
}
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>


#define ECUM_1_Core_1_START_SEC_CODE
#include <EcuM_1_Core_1_MemMap.h>
FUNC(void, ECUM_1_Core_1_CODE) EcuM_1_Core_1_UpdateSleepMode(void)
{
  Std_ReturnType result;

  do
  {
    result = SchM_Receive_EcuM_1_Core_1_EcuM_GetSleepMode(&EcuM_GetCoreInstance()->SleepMode);
  } while (result != SCHM_E_NO_DATA);

}
#define ECUM_1_Core_1_STOP_SEC_CODE
#include <EcuM_1_Core_1_MemMap.h>

#define ECUM_1_Core_2_START_SEC_CODE
#include <EcuM_1_Core_2_MemMap.h>
FUNC(void, ECUM_1_Core_2_CODE) EcuM_1_Core_2_UpdateSleepMode(void)
{
  Std_ReturnType result;

  do
  {
    result = SchM_Receive_EcuM_1_Core_2_EcuM_GetSleepMode(&EcuM_GetCoreInstance()->SleepMode);
  } while (result != SCHM_E_NO_DATA);

}
#define ECUM_1_Core_2_STOP_SEC_CODE
#include <EcuM_1_Core_2_MemMap.h>

#define ECUM_1_Core_3_START_SEC_CODE
#include <EcuM_1_Core_3_MemMap.h>
FUNC(void, ECUM_1_Core_3_CODE) EcuM_1_Core_3_UpdateSleepMode(void)
{
  Std_ReturnType result;

  do
  {
    result = SchM_Receive_EcuM_1_Core_3_EcuM_GetSleepMode(&EcuM_GetCoreInstance()->SleepMode);
  } while (result != SCHM_E_NO_DATA);

}
#define ECUM_1_Core_3_STOP_SEC_CODE
#include <EcuM_1_Core_3_MemMap.h>

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>
FUNC(void, ECUM_CODE) EcuM_StartAllCores(void)
{
  if (OS_CORE_ID_0 != ECUM_CORE_ID_INITIAL)
  {
    StatusType status;
    StartCore(OS_CORE_ID_0, &status);
    if (status != E_OK)
    {
      /* !LINKSTO EcuM.Impl.StartedCoreStatus,1 */
      ECUM_DET_REPORT_ERROR(ECUM_SID_INIT, ECUM_E_UNSUCCESSFUL_CORE_START);
    }
  }
  if (OS_CORE_ID_1 != ECUM_CORE_ID_INITIAL)
  {
    StatusType status;
    StartCore(OS_CORE_ID_1, &status);
    if (status != E_OK)
    {
      /* !LINKSTO EcuM.Impl.StartedCoreStatus,1 */
      ECUM_DET_REPORT_ERROR(ECUM_SID_INIT, ECUM_E_UNSUCCESSFUL_CORE_START);
    }
  }
  if (OS_CORE_ID_2 != ECUM_CORE_ID_INITIAL)
  {
    StatusType status;
    StartCore(OS_CORE_ID_2, &status);
    if (status != E_OK)
    {
      /* !LINKSTO EcuM.Impl.StartedCoreStatus,1 */
      ECUM_DET_REPORT_ERROR(ECUM_SID_INIT, ECUM_E_UNSUCCESSFUL_CORE_START);
    }
  }
  if (OS_CORE_ID_3 != ECUM_CORE_ID_INITIAL)
  {
    StatusType status;
    StartCore(OS_CORE_ID_3, &status);
    if (status != E_OK)
    {
      /* !LINKSTO EcuM.Impl.StartedCoreStatus,1 */
      ECUM_DET_REPORT_ERROR(ECUM_SID_INIT, ECUM_E_UNSUCCESSFUL_CORE_START);
    }
  }
}
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

STATIC FUNC(void, ECUM_CODE) EcuM_DriverInitListOneCall(uint8 id)
{
    switch (id)
    {
      case 0:
      {
        /* *** Call service PreInit of module Dem *** */
        Dem_PreInit(&DemConfigSet_0);
        break;
      }
      case 1:
      {
        /* *** Call service Init of module Mcu *** */
        Mcu_Init(BASE_MCU_CONFIG_PTR);
        break;
      }
      case 2:
      {
        /* *** Call service Init of module Eb_Intgr_McuArchClockInit *** */
        Eb_Intgr_McuArchClockInit_Init();
        break;
      }
      case 3:
      {
        /* *** Call service Init of module PbcfgM *** */
        PbcfgM_Init(BASE_PBCFGM_CONFIG_PTR);
        break;
      }
      case 4:
      {
        /* *** Call service Init of module Port *** */
        Port_Init(&Port_Config);
        break;
      }
      case 5:
      {
        /* *** Call service Init of module Spi *** */
        Spi_Init(&Spi_Config);
        break;
      }
      case 6:
      {
        /* *** Call service 17_Scu_Init of module Wdg *** */
        Wdg_17_Scu_Init(&Wdg_17_Scu_Config_0);
        break;
      }
      case 7:
      {
        /* *** Call service Init of module Adc *** */
        Adc_Init(&Adc_Config);
        break;
      }
      case 8:
      {
        /* *** Call service 17_TimerIp_Init of module Icu *** */
        Icu_17_TimerIp_Init(&Icu_17_TimerIp_Config);
        break;
      }
      case 9:
      {
        /* *** Call service 17_GtmCcu6_Init of module Pwm *** */
        Pwm_17_GtmCcu6_Init(&Pwm_17_GtmCcu6_Config);
        break;
      }
      case 10:
      {
        /* *** Call service Init of module Dma *** */
        Dma_Init(&Dma_Config);
        break;
      }
      case 11:
      {
        /* *** Call service Init of module I2c *** */
        I2c_Init(&I2c_Config);
        break;
      }
      case 12:
      {
        /* *** Call service Init of module Smu *** */
        Smu_Init(&Smu_Config);
        break;
      }
      case 13:
      {
        /* *** Call service Init of module UserEcuM *** */
        UserEcuM_Init();
        break;
      }
      default:
      {
        /* No driver configured. */
        break;
      }
    }
}


#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

/*==================[end of file]===========================================*/

