/*! \file **********************************************************************

By default, this file uses the implementation from CML.
If you set the CML_CMATH_USE_STD_LIB define outside, the STD library functions will be used.

The implementation of the STD functions are called from the global namespace
as the TI compiler for DSP C66xx and C674x have a buggy std-library

COMPANY:                   Continental AG, A.D.C. GmbH

CPU:                       CPU-Independent

COMPONENT:                 CML (Common Math Library)

MODULNAME:                 cml_stl_cmath.h

DESCRIPTION:               Math operations from cmath

AUTHOR:                    Stefan Zechner

CREATION DATE:             16.01.2015

VERSION:                   $Revision: 1.17 $

**************************************************************************** */

#ifndef cml_stl_cmath_h__
#define cml_stl_cmath_h__

#include "glob_type.h"

#include <cmath>
#include <cstdlib>

// PRQA S 1014 3
// date: 2015-23-07, reviewer: Markus Friebertshaeuser, reason: This is necessary for TI-compiler's std library
#include <math.h>

#ifndef CML_CMATH_USE_STD_LIB
extern "C"
{
# include "cml_ext.h"
}
#endif

// PRQA S 2502 EOF
// date: 2015-21-07, reviewer: Markus Friebertshaeuser, reason: renaming of existing functions is intended in this file

namespace cml
{
    /// \brief  Returns the absolute value of signed character value.
    /// \details Returns the absolute value of signed character value.
    /// It's simply calling the function abs() from cstdlib with "val" as argument and cmath but 
    /// in a way to avoid useless casting generated by TI libs.
    /// Overloads for all variants of the abs function.
    /// \param[in]       val   Constant reference to input value of type signed char  
    /// \return          Absolute value of input parameter.
    /// \testmethod
    /// \traceability
    inline static sint32 abs(const sint8& val)
    {
        return std::abs(val);
    }

    /// \brief Returns the absolute value of signed short value.
    /// \details Returns the absolute value of signed character value.
    /// This function calls the function abs() from cstdlib with "val" as argument.
    /// \param[in]       val   Constant reference to input value of type signed short  
    /// \return          Absolute value of input parameter.
    /// \testmethod
    /// \traceability
    inline static sint32 abs(const sint16& val)
    {
        return std::abs(val);
    }

    /// \brief Returns the absolute value of signed integer value.
    /// \details Returns the absolute value of signed integer value.
    /// This function calls the function abs() from cstdlib with "val" as argument.
    /// \param[in]       val   Constant reference to input value of type signed int.
    /// \return          Absolute value of input parameter.
    /// \testmethod
    /// \traceability
    inline static sint32 abs(const sint32& val)
    {
        return std::abs(val);
    }

    /// \brief Returns the absolute value of float value.
    /// \details This function calls the function CML_f_Abs() with "val" as an argument.
    /// \param[in]       val   Constant reference to input value of type float.
    /// \return          Absolute value of input parameter.
    /// \testmethod
    /// \traceability
    inline static float32 abs(const float32& val)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::fabsf(val);
#else
        return CML_f_Abs(val);
#endif
    }
    
    /// \brief Calculates the sine with 5.2 decimals accuracy.
    /// \details Calculates the sine with 5.2 decimals accuracy.
    /// This function is a wrapper and calls the function GDBsin_52() with argument "f_angle".
    /// Inside the core function,the sine is just cosine shifted a half-pi, 
    /// so we'll adjust the argument and call the cosine approximation.
    /// \param[in]       f_angle    Input angle for which we would like to know the sine, radians
    ///                             Supported values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                             where MAX_ANGLE =
    ///                             ([max range of uint32] * CML_f_two_Pi)-C_HALFPI
    /// \return          Sine of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 sin(const float32& f_angle)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::sinf(f_angle);
#else
        return GDBsin_52(f_angle);
#endif
    }
#ifndef CML_CMATH_USE_STD_LIB
    /// \brief Calculates the sine with 3.2 decimals accuracy. 
    /// \details This function calculates the sine with 3.2 decimals accuracy.
    /// This function is a wrapper and calls the function GDBsin_32() with argument "f_angle".
    /// Inside the core function,the sine is just cosine shifted a half-pi, 
    /// so the argument is adjusted and the cosine approximation is called.
    /// \param[in]       f_angle    Input angle for which we would like to know the sine, radians
    ///                             Supported values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                             where MAX_ANGLE =
    ///                             ([max range of uint32] * CML_f_two_Pi)-C_HALFPI
    /// \return          Sine of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_sin32(const float32& f_angle)
    {
        return GDB_sin32(f_angle);
    }	

    /// \brief Calculates the sine with 6.6 decimals relative accuracy.
    /// \details This function is a wrapper and calls the function CML_sin66() with argument "f_angle".
    /// Inside the core function,approximates the sine function using a polynomial
    /// of the 11th degree. The polynomial are the odd terms of the
    /// Taylor expansion of the exponential function.
    /// Performs bounds wrapping, but looses accuracy for very
    /// large arguments due to the reduced resolution of the argument.
    /// \param[in]       f_angle    Input angle for which we would like to know the sine, radians
    ///                             Supported values [Full range of float32]. 
    /// \return          Sine of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_sin66(const float32& f_angle)
    {
        return CML_sin66(f_angle);
    }

    /// \brief Calculates the sine with 6.6 decimals relative accuracy.
    /// \details This function is a wrapper and calls the function CML_sin66_Core() with argument "f_angle".
    /// Inside the core function,approximates the sine function using a polynomial
    /// of the 11th degree. The polynomial are the odd terms of the
    /// Taylor expansion of the exponential function.
    /// Valid on the interval [-pi/2..pi/2]. 
    /// Larger input range requires a range-reducing wrapper.
    /// \param[in]       f_angle    Input angle for which we would like to know the sine, radians
    ///                             Optimal range [-CML_f_Half_Pi,..,CML_f_Half_Pi]
    /// \return          Sine of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_sin66_Core(const float32& f_angle)
    {
        return CML_sin66_Core(f_angle);
    }		
#endif

    /// \brief Calculates the cosine with 5.2 decimals accuracy.
    /// \details This function is a wrapper and calls the function GDBcos_52() with argument "f_angle".
    /// Inside the core function,it reduces the input argument's range to [0, pi/2],and then performs the approximation.
    /// Algorithm:
    /// cos(x)= c1 + c2*x^2 + c3*x^4 + c4*x^6
    /// which is the same as:
    /// cos(x)= c1 + x^2(c2 + c3*x^2 + c4*x^4)
    /// cos(x)= c1 + x^2(c2 + x^2(c3 + c4*x^2))
    /// \param[in]       f_angle    angle for which cosine has to be found
    ///                             Supported values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                             where MAX_ANGLE = [max range of uint32] * CML_f_two_Pi
    /// \return          Cosine of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 cos(const float32& f_angle)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::cosf(f_angle);
#else
        return GDBcos_52(f_angle);
#endif
    }

#ifndef CML_CMATH_USE_STD_LIB
    /// \brief Calculates the cosine with 3.2 decimals accuracy.
    /// \details This function is a wrapper and calls the function GDB_cos32() with argument "f_angle".
    /// Inside the core function,it reduces the input argument's range to [0, pi/2],
    /// and then performs the approximation.
    /// Algorithm:
    /// cos(x)= c1 + c2*x**2 + c3*x**4
    /// which is the same as:
    /// cos(x)= c1 + x**2(c2 + c3*x**2)
    /// \param[in]       f_angle    Input angle for which we would like to know the cosine, radians
    ///                             Supported values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                             where MAX_ANGLE = [max range of uint32] * CML_f_two_Pi
    /// \return          Cosine of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_cos32(const float32& f_angle)
    {
        return GDB_cos32(f_angle);
    }

    /// \brief Calculates the cosine with 6.6 decimals relative accuracy.
    /// \details This function is a wrapper and calls the function CML_cos66() with argument "f_angle".
    /// Inside the core function,it approximates the cosine function using a polynomial
    /// of the 11th degree. The polynomial are the odd terms of the Taylor expansion of the exponential function.
    /// Performs bounds wrapping, but looses accuracy for very large arguments due to the reduced resolution of the argument.
    /// \param[in]       f_angle    Input angle for which we would like to know the cosine, radians
    ///                             Supported values [Full range of float32]
    /// \return          Cosine of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_cos66(const float32& f_angle)
    {
        return CML_cos66(f_angle);
    }

    /// \brief Calculates the cosine with 6.6 decimals relative accuracy.
    /// \details This function is a wrapper and calls the function CML_cos66_Core() with argument "f_angle".
    /// Inside the core function,it approximates the sine function using a polynomial
    /// of the 8th degree. The polynomial are the odd terms of the
    /// Taylor expansion of the exponential function.
    /// Valid on the interval [-pi/4..pi/4]. 
    /// Larger input range requires a range-reducing wrapper.
    /// \param[in]       f_angle    Input angle for which we would like to know the cosine, radians
    ///                             Optimal range [-CML_f_Half_Pi,..,CML_f_Half_Pi]
    /// \return          Cosine of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_cos66_Core(const float32& f_angle)
    {
        return CML_cos66_Core(f_angle);
    }
#endif
    /// \brief Computes the tangent of x with accuracy of about 5.2 decimal digits.
    /// \details This function is a wrapper and calls the function GDBtan_52() with argument "f_angle".
    /// Inside the core function,this is the main tangent approximation "driver".
    /// It reduces the input argument's range to [0, pi/4],and then calls the approximator.
    /// \attention We do not test for the tangent approaching
    /// infinity,  which it will at x=pi/2 and x=3*pi/2.
    /// If this is a problem in your application, take
    /// appropriate action.
    /// \param[in]       f_angle  the angle for which we want to know the tangent, radians
    ///                           Supported values are [Full range of float32]
    ///                           except ((2*n) + 1)*C_HALFPI, n is any integer.
    /// \return          Tangent of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 tan(const float32& f_angle)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::tanf(f_angle);
#else
        return GDBtan_52(f_angle);
#endif
    }

#ifndef CML_CMATH_USE_STD_LIB
    /// \brief Computes the tangent of x with accuracy of about 3.2 decimal digits.
    /// \details This function is a wrapper and calls the function GDB_tan32() with argument "f_angle".
    /// Inside the core function,this is the main tangent approximation "driver". 
    /// It reduces the input argument's range to [0, pi/4],and then calls the approximator. 
    /// \attention We do not test for the tangent approaching 
    /// infinity,  which it will at x=pi/2 and x=3*pi/2. 
    /// If this is a problem in your application, take appropriate action.
    /// \param[in]       f_angle  The angle for which we want to know the 
    ///                           tangent, radians
    ///                           Supported values are [Full range of float32]
    ///                           except ((2*n) + 1)*C_HALFPI, n is any integer.
    /// \return          Tangent of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_tan32(const float32& f_angle)
    {
        return GDB_tan32(f_angle);
    }	
#endif
    /// \brief Returns the hyperbolic sine of val radians.
    /// \details This function calls sinhf() with argument "f_angle" and returns the hyperbolic sine of f_angle radians.
    /// \param[in]       f_angle    Constant reference to value representing an angle, expressed in radians. 
    ///				                One radian is equivalent to 180/PI degrees. 
    /// \return          Hyperbolic sine of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 sinh(const float32& f_angle)
    {
        return ::sinhf(f_angle);
    }

    /// \brief Returns the hyperbolic cosine of val radians.
    /// \details This function calls coshf() with argument "f_angle" and returns the hyperbolic cosine of f_angle radians.
    /// \param[in]       f_angle    Constant reference to value representing an angle, expressed in radians. 
    ///				                One radian is equivalent to 180/PI degrees.
    /// \return          Hyperbolic cosine of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 cosh(const float32& f_angle)
    {
        return ::coshf(f_angle);
    }

    /// \brief Returns the hyperbolic tangent of val radians.
    /// \details This function calls tanhf() with argument "f_angle" and returns the hyperbolic tangent of f_angle radians.
    /// \param[in]       f_angle    Constant reference to value representing an angle, expressed in radians. 
    ///   			                One radian is equivalent to 180/PI degrees.
    /// \return          Hyperbolic tangent of f_angle radians.
    /// \testmethod
    /// \traceability
    inline static float32 tanh(const float32& f_angle)
    {
        return ::tanhf(f_angle);
    }

#ifndef CML_CMATH_USE_STD_LIB
    /// \brief Calculates the hyperbolic tangent with 5.8 decimals relative accuracy.
    /// \details Calculates the hyperbolic tangent with 5.8 decimals relative accuracy and Maximum relative error is 1.35e-6.This function is a wrapper and calls the function CML_tanh58() with argument "f_Arg".
    /// Inside the core function,it approximates the hyperbolic tangent using a rational 
    /// function for arguments < 8, and by sign(arg) * 1 for 
    /// larger arguments. The method has no poles on the real axis.
    /// \param[in]       f_Arg   Input argument for which we would like to know the 
    ///                          hyperbolic tangent.
    ///                          Supported range [Full range of float32]
    /// \return          Hyperbolic tangent of f_Arg radians.
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_tanh58(const float32& f_Arg)
    {
        return CML_tanh58(f_Arg);
    }	
#endif
    /// \brief Implements the asin() function with 6.6 decimals of accuracy.
    /// \details This function is a wrapper and calls the function GDBasin_66() with argument "f_sin".
    /// Inside the core function,it uses the relationships between trigonomtric and inverse trigonometric functions.
    /// tan(arccos x) = sqrt(1 - x^2) / x
    /// tan(arcsin x) = x / sqrt(1 - x^2)
    /// \param[in]       f_sin   Value for which we want the inverse sinus
    ///                          Ideal values are [-1,..,0,..,1]
    /// \return          Arcsine corresponding to the value f_sin, in radians
    /// \testmethod
    /// \traceability
    inline static float32 asin(const float32& f_sin)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::asinf(f_sin);
#else
        return GDBasin_66(f_sin);
#endif
    }

    /// \brief Implements the acos() function with 6.6 decimals of accuracy.
    /// \details This function is a wrapper and calls the function GDBacos_66() with argument "f_cos".
    /// Inside the core function,it uses the relationships between trigonomtric and inverse trigonometric functions.
    /// tan(arccos x) = sqrt(1 - x^2) / x
    /// tan(arcsin x) = x / sqrt(1 - x^2)
    /// \param[in]       f_cos   Value for which we want the inverse cosinus
    ///                          Ideal values are [-1,..,0,..,1]
    /// \return          Arccosine corresponding to the value f_cos, in radians
    /// \testmethod
    /// \traceability
    inline static float32 acos(const float32& f_cos)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::acosf(f_cos);
#else
        return GDBacos_66(f_cos);
#endif
    }

#ifndef CML_CMATH_USE_STD_LIB
    /// \brief Calculates the inverse tangent with 1.8 decimals accuracy.
    /// \details Calculates the inverse tangent with 1.8 decimals accuracy and the maximum error is 0.0015 radians, 0.088°.
    ///  This function is a wrapper and calls the function CML_atan18() with arguments "f_x" and "f_y".
    ///  Inside the core function,it approximates the inverse tangent using a common method.
    /// \param[in]       f_x    x value of Vector (x,y) for which we want to know the atan.
    ///                         Supported range [Full range of float32]
    /// \param[in]       f_y    y value of Vector (x,y) for which we want to know the atan.
    ///                         Supported range [Full range of float32]
    /// \return          The inverse tangent of (x, y)
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_atan18(float32 f_x, float32 f_y)
    {
        return CML_atan18(f_x, f_y);
    }
#endif
    /// \brief Computes atan(x) with about 6.6 decimal digits accuracy.
    /// \details This function is a wrapper and calls the function GDBatan_66() with argument "f_tan".
    /// Inside the core function,the input argument's range is reduced to [0, pi/12] 
    /// before the approximation takes place
    /// Algorithm: atan(x)= x(c1 + c2*x^2)/(c3 + x^2)
    /// \param[in]       f_tan   The "secant length" for which we want to know the 
    ///                          corresponding angle, radians
    ///                          Optimal values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                          where MAX_ANGLE is square root of max value of float32
    /// \return          Arctangent of f_tan
    /// \testmethod
    /// \traceability
    inline static float32 atan(const float32& f_tan)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::atanf(f_tan);
#else
        return GDBatan_66(f_tan);
#endif
    }

    /// \brief computes the four-quadrant atan(y/x) with about 6.6 decimal digits accuracy.
    /// \details This function is a wrapper and calls the function GDBatan2_66() with arguments "f_xaxis" and "f_xaxis".
    /// Inside the core function,this function computes the four-quandrant arctangent with 
    /// about 6.6 decimal digits accuracy.
    /// The input arguments are x and y. The situation y=0 is handled correctly.
    /// \param[in]       f_xaxis   Any number 
    ///                            Optimal values are [-MAX_ANGLE,..,MAX_ANGLE] 
    /// \param[in]       f_yaxis   Any number
    ///                            Optimal values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                            where MAX_ANGLE is cube root of max value of float32
    /// \return          The four-quadrant arctangent of f_yaxis/f_xaxis in 
    ///                  radians [-Pi, Pi]
    ///                  if x=0 and y=0 the result is 0
    /// \testmethod
    /// \traceability
    inline static float32 atan2(const float32& f_xaxis, const float32& f_yaxis)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::atan2f(f_xaxis, f_yaxis);
#else
        return GDBatan2_66(f_xaxis, f_yaxis);
#endif
    }

    /// \brief Approximates the square root of a float.
    /// \details This function is a wrapper and calls the macro CML_f_Sqrt() with arguments "f_radicand".
    /// inside the core function,it approximates the square root of a float and the relative error is bound by 4.22e-7.\n
    /// special cases:
    /// 
    ///                 |input | output    |
    ///                 |  < 0 | 0         |
    ///                 |  DEN | 0         |
    ///                 |  NAN | max_float |
    ///                 |  INF | max_float |
    ///
    /// The function extracts the exponent and mantissa parts 
    /// from the given floating point number and process them.
    /// \param[in]       f_radicand   The radicand
    ///                               Supported range [Full positive range of float32]
    /// \return          Square root of f_radicand
    /// \testmethod
    /// \traceability
    inline static float32 sqrt(const float32& f_radicand)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::sqrtf(f_radicand);
#else
        return CML_f_Sqrt(f_radicand);
#endif
    }

#ifndef CML_CMATH_USE_STD_LIB
    /// \brief Approximates the square root of a float.
    /// \details This function is a wrapper and calls the function CML_f_SqrtApprox() with arguments "f_radicand".
    /// Inside the core function,it approximates the square root of a float and the relative error is bound by 4.22e-7 \n
    /// special cases:\n |input | output    | \n
    ///                |  < 0 | 0         | \n
    ///                |  DEN | 0         | \n
    ///                |  NAN | max_float | \n
    ///                |  INF | max_float | \n
    /// The function extracts the exponent and mantissa parts 
    /// from the given floating point number and process them.
    /// \param[in]       f_radicand   The radicand
    ///                               Supported range [Full positive range of float32]
    /// \return          Square root of f_radicand
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_f_SqrtApprox(const float32& f_radicand)
    {
        return CML_f_SqrtApprox(f_radicand);
    }	

    /// \brief Approximates the square root of x.
    /// \details This function is a wrapper and calls the function CML_Sqrt_VeryFast() with arguments "f_x".
    /// Inside the core function,it approximates the square root of x and maximum error is 6.07%.
    /// The function make use of a predefined constant 0x4C000 to evaluate the square root using some basic operations.
    /// \attention No input checks are made.So the caller must guarantee that the input is valid.
    /// \param[in]       f_x   A positive real number.
    /// \return          A rough approximation of x^(1/2)
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_Sqrt_VeryFast(const float32& f_x)
    {
        return CML_Sqrt_VeryFast(f_x);
    }	

    /// \brief Approximates the square root of x.
    /// \details This function is a wrapper and calls the function CML_Sqrt67() with arguments "f_x".
    /// Inside the core function,it approximates the square root of x and the maximum error is 2.07e-7.
    /// The function make use of the CML_InvSqrt67 function to
    /// compute the inverse square root of the floating point number
    /// and then multiply it with the number to get the required square root of the number.
    /// This method is described in Lomont(2003)
    /// \attention No input checks are made.The caller must guarantee that the input is valid.
    /// \param[in]       f_x   A positive real number.
    /// \return          A precise calculation of x^(1/2)
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_Sqrt67(const float32& f_x)
    {
        return CML_Sqrt67(f_x);
    }		

    /// \brief Approximates the inverse square root of x.
    /// \details This function is a wrapper and calls the function CML_InvSqrt14() with arguments "f_x".
    /// Inside the core function,it approximates the inverse square root of x and maximum error is 3.5%.
    /// The function make use of the CML_InvSqrt14 function to
    /// compute the inverse square root of the floating point number
    /// and then multiply it with the number to get the required square root of the number.
    /// The method is described in Lomont(2003).
    /// \attention No input checks are made.The caller must guarantee that the input is valid.
    /// \param[in]       f_x   A positive real number.
    /// \return          A rough approximation of x^(-1/2)
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_InvSqrt14(const float32& f_x)
    {
        return CML_InvSqrt14(f_x);
    }	

    /// \brief Approximates the inverse square root of x.
    /// \details This function is a wrapper and calls the function CML_InvSqrt27() with arguments "f_x" and maximum error is 0.2%.
    ///   The function make use of a predefined constant to manipulate the floating point value to get the square root approximation.
    ///   This in turn calls CML_InvSqrt14() for the initial approximation and does the correction computation to improve the accuracy.              
    ///   The method is described in Lomont(2003).
    /// \attention No input checks are made.The caller must guarantee that the input is valid.
    /// \param[in]       f_x   A positive real number.
    /// \return          A rough approximation of x^(-1/2)
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_InvSqrt27(const float32& f_x)
    {
        return CML_InvSqrt27(f_x);
    }	

    /// \brief Approximates the inverse square root of x.
    /// \details This function is a wrapper and calls the function CML_InvSqrt53() with arguments "f_x".
    /// In the core function,it approximates the inverse square root of x and Maximum error is 4.8e-6. 
    /// The function make use of a predefined constant to manipulate the floating point value to get the square root approximation.
    /// This in turn calls CML_InvSqrt14 for the initial approximation and does the correction computation to improve the accuracy.
    /// The method is described in Lomont(2003).
    /// \attention No input checks are made.The caller must guarantee that the input is valid.
    /// \param[in]       f_x   A positive real number.
    /// \return          A highly accurate approximation of x^(-1/2)
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_InvSqrt53(const float32& f_x)
    {
        return CML_InvSqrt53(f_x);
    }	

    /// \brief Approximates the inverse square root of x.
    /// \details This function is a wrapper and calls the function CML_InvSqrt67() with arguments "f_x".
    /// In the core function,it approximates the inverse square root of x and maximum error is 2.07e-7.
    /// The function make use of a predefined constant to manipulate the floating point value to get the square root approximation. 
    /// This in turn calls CML_InvSqrt14 for the initial approximation and does the correction computation to improve the accuracy.
    /// The method is described in Lomont(2003).
    /// \attention No input checks are made.The caller must guarantee that the input is valid.
    /// \param[in]       f_x  A positive real number.
    /// \return          A precise calculation of x^(-1/2)
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_InvSqrt67(const float32& f_x)
    {
        return CML_InvSqrt67(f_x);
    }

    /// \brief Fast approximation exponential function 
    /// \details This function is a wrapper and calls the function GDBexp() with arguments "f_power".
    /// In this core function, function does a fast approximation of the 
    /// exponential function with the help of some predetermined
    /// constant coefficients. If the input is less than -80, then
    /// zero will be returned, whereas if it is greater than 80, the 
    ///value is capped at 80. Let the input be x. 
    ///Reduce x to an r so that |r| <= 0.5*ln2 ~ 0.3465735903F. Given x,
    ///find r and integer k such that x = k*ln2 + r,  |r| <= 0.5*ln2. 
    ///Once these values are found, then the result is obtained by scaling the found values.
    /// \param[in]       f_power  Any number 
    ///                           Supported values [-80.0,+80.0]
    /// \return          Approximation of exp(f_power)
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_exp(const float32& f_power)
    {
        return GDBexp(f_power);
    }

    /// \brief Approximates exp(x) (the natural exponential).
    /// \details This function is a wrapper and calls the function CML_Exp_VeryFast() with arguments "f_power".
    /// In this core function,it approximates exp(x) (the natural exponential) for some number x.
    /// Schraudolph (1999) adapted to 32-Bit float.Accuracy < 4% throughout the range.
    /// The calculation is done using predefined constants 12102203 and 1064866805 and bit manipulation operations. 
    /// \param[in]       f_power   The number for which we want e^x
    /// \return          Base-e exponential value of f_power.
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_Exp_VeryFast(const float32& f_power)
    {
        return CML_Exp_VeryFast(f_power);
    }
#endif

    /// \brief This function calculates the exponential for any number x.
    /// \details This function is a wrapper and calls the function GDBexp_100() with arguments "f_power".
    /// This function calculates the exponential for any number x.
    /// It adjusts the input value and calls the function GDBexp_100s
    /// in turn. The function checks if the power is negative or not.
    /// If negative, the function calls the core function and returns the 
    /// reciprocal result. Otherwise it calls the core function and returns
    /// the result as such. Core function is as follows.
    /// e(x) is re-written as e(n/4 + y) 
    /// where x = n/4 + y, n is an integer
    /// and 0 < y < 1/4. 
    /// We can transform this into 
    /// e(n/4) * e(y) = e(1/4)^n * e(y).
    /// We call these two part the integer and the fraction 
    /// part, respectively.
    /// The parameters of the fraction part of the 
    /// approximation function are minimax-optimized for 
    /// the range 0..1/4
    /// Fractional part is computed using predefined constants as
    /// \f[ e^y=(((((((((y \times E) + D) \times y) + C) \times y) + B) \times y) + A) \times y) + 1 \f]
    /// and the integer part is calculated using function GDBexp_power.
    /// \param[in]       f_power   The number for which we want e^x
    ///                            Optimal value [-MAX_VAL,..,MAX_VAL]
    ///                            where MAX_VAL is fifth root of max value of float32.
    /// \return          Base-e exponential value of f_power.
    /// \testmethod
    /// \traceability
    inline static float32 exp(const float32& f_power)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::expf(f_power);
#else
        return GDBexp_100(f_power);
#endif
    }	

    /// \brief Returns the floating-point remainder of numerator/denominator.
    /// \details Returns the floating-point remainder of numerator/denominator (rounded towards zero).
    /// \InOutCorrelation fmod = numer - tquot * denom ,Where tquot is the truncated (i.e., rounded towards zero) result of numer/denom.
    /// \param[in]       numer   Constant reference to input numerator value. 
    /// \param[in]       denom   Constant reference to input denominator value. 
    /// \return          Floating-point remainder(rounded towards zero).
    /// \testmethod
    /// \traceability
    inline static float32 fmod(const float32& numer, const float32& denom)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::fmod(numer, denom);
#else
        return numer - (static_cast<sint32>(numer/denom)*denom);
#endif
    }

#ifndef CML_CMATH_USE_STD_LIB
    /// \brief Calculates modulus after division.
    /// \details This function is a wrapper and calls the function CML_f_Mod() with arguments "f_value" and "f_modulo".
    /// This core function calculates modulus after division:
    /// result = X - n*Y where n = floor(X/Y)
    /// returns same values as CML_Rem if X and Y have same signs.
    /// Divident & Divisor should be such that f_quotient should not exceed the range of sint32. 
    /// The function returns the result as zero is the given modulus is 
    /// approximately equivalent to zero inorder to avoid a division by zero operation in the function.
    /// returns same values as CML_Rem if X and Y have same signs
    /// \param[in]       f_value  value
    ///                  Supported values are [Full range of float32]
    ///                  Overflow may occur at higher values.
    /// \param[in]       f_modulo modulo
    ///                  Supported values are [Full range of float32]
    ///                  Overflow may occur at very small values.
    /// \return          f_value modulo f_modulo
    /// \testmethod
    /// \traceability
    inline static float32 CML_STL_f_Mod(float32 f_value, float32 f_modulo)
    {
        return CML_f_Mod(f_value, f_modulo);
    }
#endif
} // End of cml namespace

#endif // cml_stl_cmath_h__

