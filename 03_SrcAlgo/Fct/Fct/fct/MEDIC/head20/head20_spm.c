/*! \file **********************************************************************

COMPANY:                   COPYRIGHT (C) Continental AG

PROJECT:                   Mainstream

CPU:                       CPU-Independent

COMPONENT:                 HEAD (Hypothesis Evaluation And Decision)

PACKAGENAME:               head20_spm.c

DESCRIPTION:               Implementation of the signal performance monitor of the HEAD module

AUTHOR:                    $Author: Prakash, Siri (uia98930) (uia98930) $

CREATION DATE:             $Date: 2020/10/22 14:54:36CEST $

VERSION:                   $Revision: 1.20 $

LEGACY VERSION:            1.22.1.1 (HEAD 2.0)
  
**************************************************************************** */

/*****************************************************************************
  INCLUDES
*****************************************************************************/
#include "frame_medic/medic_int.h"
#if (MEDIC_CFG_HEAD20)
#if (MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION)
#include "head20/head20_int.h"

/*****************************************************************************
  SYMBOLIC CONSTANTS
*****************************************************************************/

/*****************************************************************************
  MACROS
*****************************************************************************/

/*****************************************************************************
  TYPEDEFS
*****************************************************************************/

/*****************************************************************************
  CONSTS
*****************************************************************************/

/*****************************************************************************
  VARIABLES
*****************************************************************************/

/*****************************************************************************
  PROTOTYPES
*****************************************************************************/
static eGDBError_t HEADSPMCheckCondition(boolean bCondition, HEADSPMCheck_t *pRule, uint8 uiModuleQoState[],
                                         uint8 uiModuleRepErrorState[], float32 fCycleTime);

static void HEADSPMEvaluate_sint32(const HEADSPMCheck_t *pThisRule, const sint32 *pVal, boolean *bResult);
static void HEADSPMEvaluate_uint32(const HEADSPMCheck_t *pThisRule, const uint32 *pVal, boolean *bResult);
static void HEADSPMEvaluate_float32(const HEADSPMCheck_t *pThisRule, const float32 *pVal, boolean *bResult);
static void HEADSPMEvaluate_boolean(const HEADSPMCheck_t *pThisRule, const boolean *pVal, boolean *bResult);
static void HEADSPMFunctionCheck_sint32(const HEADSPMCheck_t *pThisRule, sint32 *pVal);
static void HEADSPMFunctionCheck_uint32(const HEADSPMCheck_t *pThisRule, uint32 *pVal);
static void HEADSPMFunctionCheck_float32(const HEADSPMCheck_t *pThisRule, float32 *pVal);

/*****************************************************************************
 FUNCTION DEFINITIONS
*****************************************************************************/
/*************************************************************************************************************************
  Functionname:         HEADSPMAddSigCheck                                                                        */ /*!

  @brief                Adds a new rule to the spm array

  @description          This function is used to add the SPM rules generated by Autocoder to SPM rules array
  
                        @startuml
                        Start
                            If(Null check for HEAD SPM check rules and signals) then (Yes)
                            If(check for less than the number of SPM rules) then (Yes)
                            : Get the HEAD SPM check rules;
                            If(Null check for HEAD current Module SPM rules and QoS) then (Yes)
                            :Update the HEAD SPM check rules;
                            Note right
                            Update module Qos, number of modules,
                             MTS signal identifier, Check type and current timer.
                            Endnote
                            If(Is needed time less than zero?)then (Yes)
                            : Reset the needed time;
                            Elseif(check for greater than the maximum value of timer) then (Yes) 
                            : Set the maximum time;
                            Else 
                            :Set the needed time;
                            Note right
                            Get needed time from SPM rules 
                            multiply with head time scale.
                            Endnote
                            Endif
                            If(Is float value greater than the parameter raw value?) then (Yes)
                            : Set the parameter raw maximum value;
                            Note right
                            Fvalue is get from the Auto code.
                            Endnote
                            Else
                            If(Is float value less than the  parameter raw maximum negative value?) then (Yes)
                            : Set the parameter raw maximum negative value;
                            Endif
                            Endif
                            :Get the input signal and reset the bit modules;
                            While(Is number of modules greater than the index?) is (Yes)
                            : Get the module number, Qos and error;
                            If(Null check for HEAD Module QoS relation structure) then (Yes)
                            If(Is the states of the QoS for an module /ngrater than the maximum Qos?)then (Yes)
                            : Set error as array index is out of bounds;
                            Endif 
                            If(Is the states of the SPM reported error
                            for an module /ngrater than the maximum reported error?)then (Yes)
                            : Set error as array index is out of bounds;
                            Endif 
                            : Updated the bits of modules affected by this SPM rule;
                            Else
                            : Set null pointer error;
                            Endif
                            Endwhile(No)
                            Else
                            : Set null pointer error;
                            Endif
                            Else
                            : Set null pointer error;
                            Endif
                            Else
                            : Set null pointer error;
                            Endif
                        stop
                        @enduml

  @return               eGDBError_t         :GDB error type is returned

  @param[in]            pRules              : Stores all the HEAD SPM check rules
  @param[in]            uiRuleNr            : HEAD SPM rule number
  @param[in]            pSignal             : Pointer to HEAD input signals
  @param[in]            eHEADMTSInSigIdent  : HEAD MTS signal identifier
  @param[in]            eCheckSignal        : Whether the signal or state  to be checked
  @param[in]            eCheckOperator      : The HEAD signal operation 
  @param[in]            eCheckFunction      : The HEAD module signal to be used by the function
  @param[in]            eCheckStdDev        : The HEAD module signal for standard deviation
  @param[in]            fValue              : Float value to update the current value 
  @param[in]            fNeededTime         : Float value to stores needed time 
  @param[in]            pModuleQoSRel       : Ponter to module QoS relation
  @param[in]            uiNumQoSModules     : Number of Qos in modules
  
  @glob_in              None
  @glob_out             None

  @c_switch_part        None 
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION   

  @pre                  None
  @post                 None

  @InOutCorrelation     See the  description
  
  @testmethod           Test of output data (dynamic module test) 

  @traceability         
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1173-0007e0f8}\n
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1175-0007e0f8}\n
  
  @author               Armin Vogl | armin.vogl@continental-corporation.com  
*************************************************************************************************************************/
eGDBError_t HEADSPMAddSigCheck(const HEADSPMRules_t *pRules, uint32 uiRuleNr, struct HEADInputValue_t *pSignal,
                               HEADMTSInSigIdent_t eHEADMTSInSigIdent, eHEADSPMCheckBitsSignal_t eCheckSignal,
                               eHEADSPMCheckBitsOp_t eCheckOperator, eHEADSPMCheckBitsFunction_t eCheckFunction,
                               eHEADSPMCheckBitsStdDeviation_t eCheckStdDev, float32 fValue, float32 fNeededTime,
                               const HEADModuleQoSRel_t * pModuleQoSRel, uint8 uiNumQoSModules)
{
  eGDBError_t eError = GDB_ERROR_NONE;
  uint8 uiIndex = 0;
  if ((pRules != NULL) && (pSignal != NULL))
  {
    if(uiRuleNr < pRules->uiNrOfSPMRules)
    {
      HEADSPMCheck_t *pCurrRule = HEADSPMGetRule(pRules->rgSPMRules, uiRuleNr);
      
      if((pCurrRule != NULL) && (pModuleQoSRel != NULL))
      {
        pCurrRule->pModuleQoSRel   = pModuleQoSRel;
        pCurrRule->uiNumQoSModules = uiNumQoSModules;
        pCurrRule->bitCheckType = (uint8) ( HEADSPMSetBitsStdDeviation(eCheckStdDev) 
                                          | HEADSPMSetBitsFunction(eCheckFunction) 
                                          | HEADSPMSetBitsOperator(eCheckOperator) 
                                          | HEADSPMSetBitsSignal(eCheckSignal)
                                          );
        pCurrRule->eHEADMTSInSigIdent = eHEADMTSInSigIdent;
        pCurrRule->uiCurrentTimer = 0u;
      
        if(fNeededTime < 0.0f)
        {
          eError = GDB_ERROR_CAST_VALUE_TO_LOW;
          pCurrRule->uiNeededTime = 0u;
        }
        else if ((fNeededTime * (float32)HEADTimeScale) > (float32)HEADTimeMax)
        {
          eError = GDB_ERROR_CAST_VALUE_TO_HIGH;
          pCurrRule->uiNeededTime = (uint16)HEADTimeMax;
        }
        else
        {
          float32 fTime;
          fTime = fNeededTime * (float32)HEADTimeScale;
          pCurrRule->uiNeededTime = (uint16)fTime;
        }
 
        if(fValue > (float32)HEADParameterRawValue_Max)
        {
          fValue = (float32)HEADParameterRawValue_Max;
          eError = GDB_ERROR_CAST_VALUE_TO_HIGH;
        }
        else 
        {
          if(fValue < -((float32)HEADParameterRawValue_Max))
          {
            fValue = (float32)(-HEADParameterRawValue_Max);
            eError = GDB_ERROR_CAST_VALUE_TO_LOW;
          }
        }

        pCurrRule->f16Value = HEADConvf32Tof16(fValue);
        pCurrRule->pInputSignal = pSignal;

        /* reset the bit modules for the current SPM rule */
        pCurrRule->bitModules = 0;

        /* check QoS and RepError overflow conditions*/
        for(uiIndex = 0; (uiIndex < uiNumQoSModules)&&(eError == GDB_ERROR_NONE); uiIndex++)
        {
          const HEADModuleQoSRel_t * const pSPMQoSRel = HEADGetQoSModule(pCurrRule, uiIndex);

          if(pSPMQoSRel != NULL)
          {
            if(pSPMQoSRel->eModuleQoS >= (HEADModuleQoS_t)HEADModuleQoS_Max) 
            {
              eError = GDB_ERROR_ARRAY_OVERFLOW;
            }

            if(pSPMQoSRel->eReportedError >= (HEADModuleRepError_t)HEADModuleRepError_Max) 
            {
              eError = GDB_ERROR_ARRAY_OVERFLOW;
            }

            /* updated the bits of modules affected by this SPM rule */
            pCurrRule->bitModules |= (uint32)(1uL << pSPMQoSRel->uiModuleNr); 
          }
          else
          {
            eError = GDB_ERROR_POINTER_NULL;
          }
        }
      }
      else
      {
        eError = GDB_ERROR_POINTER_NULL;
      }
    }
    else
    {
      eError = GDB_ERROR_ARRAY_OVERFLOW;
    }
  }
  else
  {
    eError = GDB_ERROR_POINTER_NULL;
  }
  return eError;
}/*PRQA S 7007 */ /* date: 2020-10-21, reviewer: Siri Prakash, reason: Implementation Intended */


/* ***********************************************************************************************************************
  Functionname:         HEADSPMCheckCondition                                                                       */ /*! 

  @brief                The function checks a condition and updates the spm QoS array

  @description          The function checks a condition and updates the spm QoS array
  
                        @startuml
                        Start
                            If(is condition true? \nNote :Depends on input signal quality condition is enabled) then (Yes)
                            :assign zero to local condition;
                            If(check current timer is greater than the needed time) then (Yes)
                            Note right
                            Current timer value will be increased every Vehicle 
                            cycle count in every spm codition.
                            endnote
                            :assign true to local condition;
                            Else
                            :assign zero to local condition;
                            Endif
                            If(Is local condition enabled?) then (Yes)
                            While(Check for less than the number of modules affected by spm rules) is (True)
                            : Get the module number, Qos and reported error;
                            If(Null check for module Qos relation) then (True)
                            If(Is current module QoS higher?) then (Yes)
                            : Update module QoS;
                            endif
                            If(Is current module reported error higher?) then (Yes)
                            : Update module reported error;
                            endif
                            else
                            :Set null pointer error;
                            Endif
                            Endwhile(No)
                            Else 
                            While(Check for less than the number of modules affected by spm rules) is (True)
                            : Get the module number, Qos and reported error;
                            If(Null check for module Qos relation) then (True)
                            If(Is module Qos normal mode?) then (Yes)
                            If(Is current module Qos normal mode?) then (Yes)
                            : Set maximum value of Qos;
                            Endif
                            Endif
                            If(Is module reported error normal mode?) then (Yes)
                            If(Is current module reported error normal mode?) then (Yes)
                            : Set maximum value of reported error;
                            Endif
                            Endif
                            else
                            :Set null pointer error;
                            endif
                            Endwhile(No)
                            Endif
                            :Update the timer value;
                            If(Is timer value more than maximum timer value?) then (No)
                            :update increased timer value;
                            Else
                            :update maximum timer value;
                            Endif
                            Else
                            :Reset the current timer;
                            Endif
                            :return error type;
                        stop
                        @enduml


  @return               eGDBError_t    :GDB error type is returned
  
  @param[in]            bCondition            : flag of the the condition
  @param[in,out]        pRule                 : Pointer to HEAD SPM check rules
  @param[out]           uiModuleQoState       : Modules QoS state value are stored
  @param[out]           uiModuleRepErrorState : Affected modules error types will be reported
  @param[in]            fCycleTime            : The function cycle time
  
  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  NONE
  @post                 NONE
  
  @InOutCorrelation     See the description 
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1179-0007e0f8}\n
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1180-0007e0f8}\n

  @author               Robert Thiel | robert.thiel@contiautomotive.com
**************************************************************************** */
static eGDBError_t HEADSPMCheckCondition(boolean bCondition, HEADSPMCheck_t *pRule, uint8 uiModuleQoState[],
                                         uint8 uiModuleRepErrorState[], float32 fCycleTime)
{
  eGDBError_t eError = GDB_ERROR_NONE;
  uint32 uiTemp;
  float32 fTemp;
  uint8 uiIndex;

  if (bCondition != b_FALSE)
  {
    boolean bLocalCondition = b_FALSE;
    if(pRule->uiCurrentTimer >= pRule->uiNeededTime)
    {
      /* condition TRUE */
      bLocalCondition = b_TRUE;
    }
    else
    {
      bLocalCondition = b_FALSE;
    }

    if(bLocalCondition == b_TRUE)
    {
      /* condition fulfilled, check QoS other then HEADModuleQoS_NormalRunning */
      for(uiIndex = 0; (uiIndex < pRule->uiNumQoSModules)&&(eError == GDB_ERROR_NONE) ; uiIndex++)
      {
        const HEADModuleQoSRel_t * const pModuleQoSRel = HEADGetQoSModule(pRule, uiIndex);

        if(pModuleQoSRel != NULL)
        {
          /* if current module QoS is higher(less severe), update module QoS */
          if(uiModuleQoState[pModuleQoSRel->uiModuleNr] > pModuleQoSRel->eModuleQoS) 
          {
            uiModuleQoState[pModuleQoSRel->uiModuleNr] = pModuleQoSRel->eModuleQoS; 
          }

          /* if current module RepError is higher(less severe), update module RepError */
          if(uiModuleRepErrorState[pModuleQoSRel->uiModuleNr] > pModuleQoSRel->eReportedError) 
          {
            uiModuleRepErrorState[pModuleQoSRel->uiModuleNr] = pModuleQoSRel->eReportedError;
          }
        }
        else
        {
          eError = GDB_ERROR_POINTER_NULL;
        }
      }
    }
    else
    {
      /* condition not fulfilled, check QoS HEADModuleQoS_NormalRunning for all modules of current rule */   
      for(uiIndex = 0; (uiIndex < pRule->uiNumQoSModules)&&(eError == GDB_ERROR_NONE) ; uiIndex++)
      {
        const HEADModuleQoSRel_t * const pModuleQoSRel = HEADGetQoSModule(pRule, uiIndex);

        if(pModuleQoSRel != NULL)
        {
          if(pModuleQoSRel->eModuleQoS == (HEADModuleQoS_t)HEADModuleQoS_NormalRunning)
          {
            /* if current module QoS is HEADModuleQoS_NormalRunning, set it to HEADModuleQoS_Max */
            if(uiModuleQoState[pModuleQoSRel->uiModuleNr] == (HEADModuleQoS_t)HEADModuleQoS_NormalRunning) 
            {
              uiModuleQoState[pModuleQoSRel->uiModuleNr] = (HEADModuleQoS_t)HEADModuleQoS_Max; 
            }
          }

          if(pModuleQoSRel->eReportedError == (HEADModuleRepError_t)HEADModuleRepError_NoError)
          {
            /* if current module RepError is HEADModuleRepError_NoError, set it to HEADModuleRepError_Max */
            if(uiModuleRepErrorState[pModuleQoSRel->uiModuleNr] == (HEADModuleRepError_t)HEADModuleRepError_NoError) 
            {
              uiModuleRepErrorState[pModuleQoSRel->uiModuleNr] = (HEADModuleRepError_t)HEADModuleRepError_Max;
            }
          }
        }
        else
        {
          eError = GDB_ERROR_POINTER_NULL;
        }
      }
    }

    /* Convert from float ms to integer seconds */
    fTemp = fCycleTime * (float32)HEADTimeScale;
    uiTemp = ROUND_TO_UINT((float32)pRule->uiCurrentTimer + fTemp);
    
    if(uiTemp < HEADTimeMax)
    {
      /* increase timer by current cycle time */
      pRule->uiCurrentTimer = (uint16)uiTemp;
    }
    else
    {
      /* keep maximum allowed value */
      pRule->uiCurrentTimer = (uint16) HEADTimeMax;
    }
  }
  else
  {
    /* set timer to 0*/
    pRule->uiCurrentTimer = 0u;
  }
  return eError;
}


/*************************************************************************************************************************
  Functionname:         HEADSPMRunCheck                                                                             */ /*!

  @brief                Run check over all SPM rules and update state of modules

  @description          This function Evaluates all configured SPM rules and apply state to modules

                        @startuml
                        Start
                            If(check for spm rules and module list availability) then (Yes)
                            : Temporarily update the module Qos and error mode;
                            While(check for less than the total modules) is (Yes)
                            : Set the module Qos as normal running and error mode as no error;
                            Endwhile(No)
                            While(check for less than Number of SPM Rules) is (Yes)
                            :Get the spm rule;
                            If(Null check for spm rules and input signal) then (Yes)
                            :Get the bit check type;
                            Note right
                             It define which one is need to be checked 
                            whether signal state or signal.
                            Endnote
                            If(Is it signal state?) then (Yes)
                            : Signal state has to be tested;
                            Else
                            If(Is it HEAD input signal type?) then (Yes)
                            : Signal value has to be tested;
                            Note right 
                            Set the standard deviation, function and 
                            HEAD signal operator for following value
                            type float, signed int, unsigned int and bool.
                            endnote
                            Endif
                            Endif
                            #orange:Each module QoS , RepError or time are updated
                            <b> HEADSPMCheckCondition <b> >
                            endif
                            Endwhile(No)
                            While(check for less than the maximum modules) is (Yes)
                            :Get the module;
                            If(Is module QoS state less than HEAD module QoS maximum?) then (Yes)
                            :Update module QoS;
                            Endif
                            If(Is module report error state less than HEAD module report error state maximum?) then (Yes)
                            :Updated module reported error;
                            Endif
                            Endwhile(No)
                            Else
                            : Set Null point error;
                            Endif
                            : Return the updated error type;
                        stop
                        @enduml

  @return               eGDBError_t  :GDB error type is returned

  @param[in]            pRules       : Stores all the HEAD SPM check rules
  @param[in]            pModuleList  : pointer to module list
  @param[in]            fCycleTime   : The function cycle time
  
  @glob_in              None
  @glob_out             None

  @c_switch_part        None 
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION   

  @pre                  None
  @post                 None

  @InOutCorrelation     see the description
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1172-0007e0f8}\n
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1173-0007e0f8}\n
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1175-0007e0f8}\n
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1179-0007e0f8}\n
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1180-0007e0f8}\n
  
  @author               Armin Vogl | armin.vogl@continental-corporation.com 
*************************************************************************************************************************/
eGDBError_t HEADSPMRunCheck(const HEADSPMRules_t *pRules, const HEADModuleList_t *pModuleList, float32 fCycleTime)
{
  eGDBError_t eError = GDB_ERROR_NONE;
  #if ((MEDIC_CFG_RTA_PROFILING) && (MEDIC_CFG_USE_SERVICE_POINTER_FUNCTS))
  #if (MEDIC_ARCHITECTURE_VERSION < 0x10)
  MEDIC_v_AlgoServiceAddEvent(MEDIC_p_GetServiceFuncts(), e_RTA_EVT_AlgoStart, (uint8)MEDIC_GLOBAL_RTA_ID, (uint8)MEDIC_RTA_HEAD_SPM_CHECK, 0);
  #endif 
  MEDIC_v_AlgoServiceAddEvent(MEDIC_p_GetServiceFuncts(), e_RTA_EVT_AlgoStart, (uint8)MEDIC_GLOBAL_RTA_ID, (uint8)MEDIC_RTA_HEAD_SPM_CHECK, 0);
  #endif
  if ((pRules != NULL) && (pModuleList != NULL))
  {
    uint32 uiIndex;

    uint8 uiModuleQoState[(HEADDGSM_Module_t)HEAD_AUTOCODE_MOD_Max]; /*!< saves QoS for each module temporary */
    uint8 uiModuleRepErrorState[(HEADDGSM_Module_t)HEAD_AUTOCODE_MOD_Max]; /*!< saves reported error for each module temporary */

    /* temporary set QoS for all modules to be normal and RepError to be no error */
    for(uiIndex = 0u; uiIndex < (HEADDGSM_Module_t)HEAD_AUTOCODE_MOD_Max; uiIndex++)
    {
      uiModuleQoState[uiIndex]        = (HEADModuleQoS_t)HEADModuleQoS_NormalRunning;
      uiModuleRepErrorState[uiIndex]  = (HEADModuleRepError_t)HEADModuleRepError_NoError;
    }

    /* run through all rules and update the timers and QoS of the modules */
    for(uiIndex = 0u; uiIndex < pRules->uiNrOfSPMRules; uiIndex++)
    {
      HEADSPMCheck_t *pThisRule = HEADSPMGetRule(pRules->rgSPMRules, uiIndex);

      if((pThisRule != NULL)&&(pThisRule->pInputSignal != NULL))
      {
        /* PRQA S 1482 1 */ /* This cast to enum type is valid */
        eHEADSPMCheckBitsSignal_t eCheckSignal = (eHEADSPMCheckBitsSignal_t)HEADSPMGetBitsSignal(pThisRule->bitCheckType);

        boolean bResult = b_FALSE;

        if(eCheckSignal == HEADSPMCheckBitsSignal_SigState)
        {
          /* Signal state has to be tested */
          sint32 iVal = (sint32) pThisRule->pInputSignal->eSignalQuality;
          HEADSPMFunctionCheck_sint32(pThisRule, &iVal);
          HEADSPMEvaluate_sint32(pThisRule, &iVal, &bResult);
        }
        else
        {
          /* Signal value has to be tested */
          switch (pThisRule->pInputSignal->eSignalType)
          {
          case HEADInputSignalType_SignedInt:
            {
              sint32 iVal;
              (void)HEADGetInputValue_sint32((*(pThisRule->pInputSignal)), 0, &iVal);
              HEADSPMFunctionCheck_sint32(pThisRule, &iVal);
              HEADSPMEvaluate_sint32(pThisRule, &iVal, &bResult);
            }
            break;
          case HEADInputSignalType_UnsignedInt:
            {
              uint32 uiVal;
              (void)HEADGetInputValue_uint32((*(pThisRule->pInputSignal)), 0u, &uiVal);
              HEADSPMFunctionCheck_uint32(pThisRule, &uiVal);
              HEADSPMEvaluate_uint32(pThisRule, &uiVal, &bResult);
            }
            break;          
          case HEADInputSignalType_Float:
            {
              float32 fVal;
              (void)HEADGetInputValue_float32((*(pThisRule->pInputSignal)), 0.0f, &fVal);
              HEADSPMFunctionCheck_float32(pThisRule, &fVal);
              HEADSPMEvaluate_float32(pThisRule, &fVal, &bResult);
            }
            break;
          case HEADInputSignalType_Bool:
            {
              boolean bVal;
              (void)HEADGetInputValue_boolean((*(pThisRule->pInputSignal)), b_FALSE, &bVal);
              HEADSPMEvaluate_boolean(pThisRule, &bVal, &bResult);
            }
            break;
          default:
            /*PRQA S 2982 1*/ /* date: 2019-05-23, reviewer: Schnurr, Clemens, reason: Intended behaviour*/
            eError = GDB_ERROR_UNKNOWN_TYPE;
            break;
          }
        }
        /* call the handler */
        eError = HEADSPMCheckCondition(bResult, pThisRule, &uiModuleQoState[0], &uiModuleRepErrorState[0], fCycleTime);
      }
    } /*for*/

    /* update the global module QoS and RepError */
    for(uiIndex = 0u; uiIndex < (HEADDGSM_Module_t)HEAD_AUTOCODE_MOD_Max; uiIndex++)
    {
      HEADModule_t *pCurrModule;

      pCurrModule = HEADGetModule(pModuleList, uiIndex);

      /* update module QoS if uiModuleQoState is less than HEADModuleQoS_Max */
      if(uiModuleQoState[uiIndex] < (HEADModuleQoS_t)HEADModuleQoS_Max)
      {
        /* PRQA S 1482 1 */ /* HEADModuleQoS_Max ensures valid cast to enum type */
        pCurrModule->eQoS            =  (eHEADModuleQoS_t)uiModuleQoState[uiIndex];
      }

      /* updated module reported error if uiModuleRepErrorState is less than HEADModuleRepError_Max */
      if(uiModuleRepErrorState[uiIndex] < (HEADModuleRepError_t)HEADModuleRepError_Max)
      {
         /* PRQA S 1482 1 */ /* HEADModuleRepError_Max ensures valid cast to enum type */       
         pCurrModule->eReportedError  =  (eHEADModuleRepError_t)uiModuleRepErrorState[uiIndex];
      }
    }

  }
  else
  {
    eError = GDB_ERROR_POINTER_NULL;
  }
  #if ((MEDIC_CFG_RTA_PROFILING) && (MEDIC_CFG_USE_SERVICE_POINTER_FUNCTS))
  #if (MEDIC_ARCHITECTURE_VERSION < 0x10)
  MEDIC_v_AlgoServiceAddEvent(MEDIC_p_GetServiceFuncts(), e_RTA_EVT_AlgoEnd, (uint8)MEDIC_GLOBAL_RTA_ID, (uint8)MEDIC_RTA_HEAD_SPM_CHECK, 0);
  #endif 
  MEDIC_v_AlgoServiceAddEvent(MEDIC_p_GetServiceFuncts(), e_RTA_EVT_AlgoEnd, (uint8)MEDIC_GLOBAL_RTA_ID, (uint8)MEDIC_RTA_HEAD_SPM_CHECK, 0);
  #endif 
  return eError;
} /*PRQA S 7002 */ /*date: 2020-10-21, Reviewer: Siri Prakash, Reason:suppressing cyclomatic complexity for better code maintainability*/  

/* ***********************************************************************************************************************
  Functionname:         HEADSPMEvaluate_sint32                                                                      */ /*! 

  @brief                Evaluate SPM signal of type signed integer

  @description          Evaluate SPM signal of type signed integer
  
                        @startuml
                        Start
                            :get operator type;
                            If(Check Operator type) then (True)
                            If( check for operator is equal to smaller  or Equal type) then (yes)
                            note left
                            Remaining operator  (Smaller, Greater Or Equal, Greater and not equal) type will be checked for same
                            End note
                            If(check  for parameter value is equal to SPM check rules parameter value) then (Yes)
                            : updated result is true;
                            Else 
                            : updated result is false;
                            Endif
                            endif
                            :update operator type in particular bit;
                            note left
                            Any one of the operator  (Smaller, Smaller Or Equal,
                            Greater Or Equal, Greater and not equal) type will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void

  @param[in]            pThisRule : pointer to head spm check rules
  @param[in]            pVal      : pointer to local value
  @param[out]           bResult   : pointer to store result

  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     
                        |     eCheckOperator                    |     bResult                |
                        |:--------------                        |:---------------------------|
                        |     HEADSPMCheckBitsOp_Equals         |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_EqualsNot      |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Greater        |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_GreaterOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Smaller        |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_SmallerOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_SmallerOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Max            |     b_FALSE                |

  @testmethod           Test of output data (dynamic module test)

  @traceability         
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1175-0007e0f8}

  @author               Robert Thiel | robert.thiel@contiautomotive.com
***************************************************************************************************************************/
static void HEADSPMEvaluate_sint32(const HEADSPMCheck_t *pThisRule, const sint32 *pVal, boolean *bResult)
{
  /* PRQA S 1482 1 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsOp_t eCheckOperator = (eHEADSPMCheckBitsOp_t)HEADSPMGetBitsOperator(pThisRule->bitCheckType);
  float32 f32Value = HEADConvf16Tof32(pThisRule->f16Value);
  {
    const sint32 i32Value = ROUND_TO_INT(f32Value);
    switch(eCheckOperator)
    {
      case HEADSPMCheckBitsOp_Equals:
        *bResult = (*pVal == i32Value)? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_EqualsNot:
        *bResult = (*pVal != i32Value)? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_Greater:
        *bResult = (*pVal > i32Value)? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_GreaterOrEqual:
        *bResult = (*pVal >= i32Value)? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_Smaller:
        *bResult = (*pVal < i32Value) ? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_SmallerOrEqual:
        *bResult = (*pVal <= i32Value) ? b_TRUE : b_FALSE;
        break;
      case HEADSPMCheckBitsOp_Max:
      default:
        *bResult = b_FALSE;
        MEDIC_ASSERT(FALSE);/*PRQA S 3119 */ /* date: 2019-09-19, reviewer: Srinivasa, Sadhanashree, Reason: This code is placed for assertive failure and hence cannot be removed */
        break;
    }
  }
}

/* ***********************************************************************************************************************
  Functionname:         HEADSPMEvaluate_uint32                                                                      */ /*! 

  @brief                Evaluate SPM signal of type unsigned integer

  @description          Evaluate SPM signal of type unsigned integer
  
                        @startuml
                        Start
                            :get operator type;
                            If(Check Operator type) then (True)
                            If( check for operator is equal to smaller  or Equal type) then (yes)
                            note left
                            Remaining operator  (Smaller, Greater Or Equal, Greater and not equal) type will be checked for same
                            End note
                            If(check  for parameter value is equal to SPM check rules parameter value) then (Yes)
                            : updated result is true;
                            Else 
                            : updated result is false;
                            Endif
                            endif
                            :update operator type in particular bit;
                            note left
                            Any one of the operator  (Smaller, Smaller Or Equal,
                            Greater Or Equal, Greater and not equal) type will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void
  
  @param[in]            pThisRule : Pointer to head spm check rules
  @param[in]            pVal      : Pointer to local value
  @param[out]           bResult   : Pointer to store result

  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     
                        |     eCheckOperator                    |     bResult                | 
                        |:--------------                        |:---------------------------|
                        |     HEADSPMCheckBitsOp_Equals         |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_EqualsNot      |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Greater        |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_GreaterOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Smaller        |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_SmallerOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_SmallerOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Max            |     b_FALSE                |

  @testmethod           Test of output data (dynamic module test)

  @traceability         
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1175-0007e0f8}

  @author               Robert Thiel robert.thiel@contiautomotive.com
**************************************************************************************************************************/
static void HEADSPMEvaluate_uint32(const HEADSPMCheck_t *pThisRule,const uint32 *pVal, boolean *bResult)
{
  /* PRQA S 1482 1 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsOp_t eCheckOperator = (eHEADSPMCheckBitsOp_t)HEADSPMGetBitsOperator(pThisRule->bitCheckType);
  float32 f32Value = HEADConvf16Tof32(pThisRule->f16Value);
  const uint32 ui32Value = ROUND_TO_UINT(f32Value);
  switch(eCheckOperator)
  {
    case HEADSPMCheckBitsOp_Equals:
      *bResult = (*pVal == ui32Value)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_EqualsNot:
      *bResult = (*pVal != ui32Value)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Greater:
      *bResult = (*pVal > ui32Value)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_GreaterOrEqual:
      *bResult = (*pVal >= ui32Value)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Smaller:
      *bResult = (*pVal < ui32Value) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_SmallerOrEqual:
      *bResult = (*pVal <= ui32Value) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Max:
    default:
      *bResult = b_FALSE;
      MEDIC_ASSERT(FALSE);/*PRQA S 3119 */ /* date: 2019-09-19, reviewer: Srinivasa, Sadhanashree, Reason: This code is placed for assertive failure and hence cannot be removed */
      break;
  }
}

/* ***********************************************************************************************************************
  Functionname:         HEADSPMEvaluate_float32                                                                     */ /*! 

  @brief                Evaluate SPM signal of type float

  @description          Evaluate SPM signal of type float
  
                        @startuml
                        Start
                            :get operator type;
                            If(Check Operator type) then (True)
                            If( check for operator is equal to smaller  or Equal type) then (yes)
                            note left
                            Remaining operator  (Smaller, Greater Or Equal, Greater and not equal) type will be checked for same
                            End note
                            If(check  for parameter value is equal to SPM check rules parameter value) then (Yes)
                            : updated result is true;
                            Else 
                            : updated result is false;
                            Endif
                            endif
                            :update operator type in particular bit;
                            note left
                            Any one of the operator  (Smaller, Smaller Or Equal,
                            Greater Or Equal, Greater and not equal) type will be updated
                            End note
                            endif
                        stop
                        @enduml
                        
  @return               void                        

  @param[in]            pThisRule : Pointer to head spm check rules
  @param[in]            pVal      : Pointer to local value
  @param[out]           bResult   : Pointer to store result

  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     
                        |     eCheckOperator                    |     bResult                |
                        |:--------------                        |:---------------------------|
                        |     HEADSPMCheckBitsOp_Equals         |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_EqualsNot      |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Greater        |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_GreaterOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Smaller        |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_SmallerOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_SmallerOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Max            |     b_FALSE                |
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1175-0007e0f8}

  @author               robert.thiel@contiautomotive.com
**************************************************************************** */
static void HEADSPMEvaluate_float32(const HEADSPMCheck_t *pThisRule, const float32 *pVal, boolean *bResult)
{
  /* PRQA S 1482 1 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsOp_t  eCheckOperator = (eHEADSPMCheckBitsOp_t)HEADSPMGetBitsOperator(pThisRule->bitCheckType);
  const float32 tmpCompareValue = HEADConvf16Tof32(pThisRule->f16Value);
  switch(eCheckOperator)
  {
    case HEADSPMCheckBitsOp_Equals:
      *bResult = (F32_IS_ZERO(*pVal - tmpCompareValue)) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_EqualsNot:
      *bResult = (F32_IS_NZERO(*pVal - tmpCompareValue)) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Greater:
      *bResult = (*pVal > tmpCompareValue) ? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_GreaterOrEqual:
      *bResult = (*pVal >= tmpCompareValue)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Smaller:
      *bResult = (*pVal < tmpCompareValue)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_SmallerOrEqual:
      *bResult = (*pVal <= tmpCompareValue)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Max:
    default:
      *bResult = b_FALSE;
      MEDIC_ASSERT(FALSE);/*PRQA S 3119 */ /* date: 2019-09-19, reviewer: Srinivasa, Sadhanashree, Reason: This code is placed for assertive failure and hence cannot be removed */
      break;
  }
}

/* ***********************************************************************************************************************
  Functionname:         HEADSPMEvaluate_boolean                                                                     */ /*! 

  @brief                Evaluate SPM signal of type boolean

  @description          Evaluate SPM signal of type boolean
  
                        @startuml
                        Start
                            :get operator type;
                            If(Check Operator type) then (True)
                            If( check for operator is equal to smaller  or Equal type) then (yes)
                            note left
                            Remaining operator  (Smaller, Greater Or Equal, Greater and not equal) type will be checked for same
                            End note
                            If(check  for parameter value is equal to SPM check rules parameter value) then (Yes)
                            : updated result is true;
                            Else 
                            : updated result is false;
                            Endif
                            endif
                            :update operator type in particular bit;
                            note left
                            Any one of the operator  (Smaller, Smaller Or Equal,
                            Greater Or Equal, Greater and not equal) type will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void
  
  @param[in]            pThisRule : Pointer to head spm check rules
  @param[in]            pVal      : Pointer to local value
  @param[out]           bResult   : Pointer to store result

  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     
                        |     eCheckOperator                    |     bResult                |
                        |:--------------                        |:---------------------------|
                        |     HEADSPMCheckBitsOp_Equals         |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_EqualsNot      |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Greater        |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_GreaterOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Smaller        |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_SmallerOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_SmallerOrEqual |     b_TRUE or b_FALSE      |
                        |     HEADSPMCheckBitsOp_Max            |     b_FALSE                |
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1175-0007e0f8}

  @author               Robert Thiel robert.thiel@contiautomotive.com
***************************************************************************************************************************/
static void HEADSPMEvaluate_boolean(const HEADSPMCheck_t *pThisRule, const boolean *pVal, boolean *bResult)
{
  /* PRQA S 1482 1 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsOp_t eCheckOperator = (eHEADSPMCheckBitsOp_t)HEADSPMGetBitsOperator(pThisRule->bitCheckType);
  float32 f32Value = HEADConvf16Tof32(pThisRule->f16Value);
  const uint32 ui32Value = ROUND_TO_UINT(f32Value);
  boolean bTemp = (ui32Value > 0u)? b_TRUE : b_FALSE;
  /*consistent to Autocoder - some operators are nonsens for bool*/
  switch(eCheckOperator)
  {
    case HEADSPMCheckBitsOp_Equals:
      *bResult = (*pVal == bTemp)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_EqualsNot:
      *bResult = (*pVal != bTemp)? b_TRUE : b_FALSE;
      break;
    case HEADSPMCheckBitsOp_Greater:
      *bResult = (*pVal > bTemp)? b_TRUE : b_FALSE;/* PRQA S 4505 */ /* Mesg :An expression of 'essentially unsigned'type(_Bool)is being used as a left/right-hand operand of relational -operator */
      break;
    case HEADSPMCheckBitsOp_GreaterOrEqual:
      *bResult = (*pVal >= bTemp)? b_TRUE : b_FALSE;/* PRQA S 4505 */ /* Mesg :An expression of 'essentially unsigned'type(_Bool)is being used as a left/right-hand operand of relational -operator */
      break;
    case HEADSPMCheckBitsOp_Smaller:
      *bResult = (*pVal < bTemp) ? b_TRUE : b_FALSE;/* PRQA S 4505 */ /* Mesg :An expression of 'essentially unsigned'type(_Bool)is being used as a left/right-hand operand of relational -operator */
      break;
    case HEADSPMCheckBitsOp_SmallerOrEqual:
      *bResult = (*pVal <= bTemp) ? b_TRUE : b_FALSE;/* PRQA S 4505 */ /* Mesg :An expression of 'essentially unsigned'type(_Bool)is being used as a left/right-hand operand of relational -operator */
      break;
    case HEADSPMCheckBitsOp_Max:
    default:
      *bResult = b_FALSE;
      MEDIC_ASSERT(FALSE);/*PRQA S 3119 */ /* date: 2019-09-19, reviewer: Srinivasa, Sadhanashree, Reason: This code is placed for assertive failure and hence cannot be removed */
      break;
  }
}


/*************************************************************************************************************************
  Functionname:         HEADSPMFunctionCheck_sint32                                                                 */ /*!

  @brief                Do functional check of SPM signal of type signed integer

  @description          Do functional check of SPM signal of type signed integer
  
                        @startuml
                        Start
                            :get type of function and standard deviation;
                            If(Is funtion ABS type) then (Yes)
                            :update parameter value;
                            Endif
                            If(check standard deviation type ) then (True)
                            :update standard deviation in parameter variable;
                            note left
                            Incremented, decremented or not modified Standard 
                            deviation value will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void

  @param[in]            pThisRule : Pointer to head spm check rules
  @param[in,out]        pVal      : Pointer to local value
  
  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     see the description
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1175-0007e0f8}

  @author               Armin Vogl | armin.vogl@continental-corporation.com                  
*************************************************************************************************************************/
static void HEADSPMFunctionCheck_sint32(const HEADSPMCheck_t *pThisRule, sint32 *pVal)
{
  /* PRQA S 1482 2 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsStdDeviation_t eCheckStdDev   = (eHEADSPMCheckBitsStdDeviation_t) HEADSPMGetBitsStdDeviation(pThisRule->bitCheckType);
  eHEADSPMCheckBitsFunction_t     eCheckFunction = (eHEADSPMCheckBitsFunction_t)HEADSPMGetBitsFunction(pThisRule->bitCheckType);
        
  if (eCheckFunction == HEADSPMCheckBitsFunction_ABS)
  {
    *pVal = ABS(*pVal);
  }
    /* apply standard deviation if necessary */
  switch(eCheckStdDev)
  {
    case HEADSPMCheckBitsStdDeviation_Minus:
      *pVal-= (sint32)HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_Plus:
      *pVal+= (sint32)HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_No:
      /*Do nothing*/
      break;
    case HEADSPMCheckBitsStdDeviation_Max:
    default:
      MEDIC_ASSERT(FALSE);/*PRQA S 3119 */ /* date: 2019-09-19, reviewer: Srinivasa, Sadhanashree, Reason: This code is placed for assertive failure and hence cannot be removed */
      break;
  }
}

/*************************************************************************************************************************
  Functionname:         HEADSPMFunctionCheck_uint32                                                                  */ /*!

  @brief                Do functional check of SPM signal of type unsigned integer

  @description          Do functional check of SPM signal of type unsigned integer

                        @startuml
                         Start
                            :get type of standard deviation;                         
                            If(check standard deviation type ) then (True)
                            : update standard deviation in parameter variable;
                            note left
                            Incremented, decremented or not modified Standard 
                            deviation value will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void

  @param[in]            pThisRule : Pointer to head spm check rules
  @param[in,out]        pVal      : Pointer to local value
  
  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     see the description
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1175-0007e0f8}

  @author               Armin Vogl | armin.vogl@continental-corporation.com        
*************************************************************************************************************************/
static void HEADSPMFunctionCheck_uint32(const HEADSPMCheck_t *pThisRule, uint32 *pVal)
{
  /* PRQA S 1482 1 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsStdDeviation_t eCheckStdDev   = (eHEADSPMCheckBitsStdDeviation_t) HEADSPMGetBitsStdDeviation(pThisRule->bitCheckType);
 
  /* apply standard deviation if necessary */
  switch(eCheckStdDev)
  {
    case HEADSPMCheckBitsStdDeviation_Minus:
      *pVal-= (uint32)HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_Plus:
      *pVal+= (uint32)HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_No:
      /*Do nothing*/
      break;
    case HEADSPMCheckBitsStdDeviation_Max:
    default:
      MEDIC_ASSERT(FALSE);/*PRQA S 3119 */ /* date: 2019-09-19, reviewer: Srinivasa, Sadhanashree, Reason: This code is placed for assertive failure and hence cannot be removed */
      break;
  }
}

/*************************************************************************************************************************
  Functionname:         HEADSPMFunctionCheck_float32                                                                */ /*!

  @brief                Do functional check of the SPM signal of type float

  @description          Do functional check of the SPM signal of type float

                        @startuml
                        Start
                            :get type of function and standard deviation;
                            If(Is funtion ABS type) then (Yes)
                            :update parameter value;
                            Endif
                            If(check standard deviation type ) then (True)
                            :update standard deviation in parameter variable;
                            note left
                            Incremented, decremented or not modified Standard 
                            deviation value will be updated
                            End note
                            endif
                        stop
                        @enduml

  @return               void

  @param[in]            pThisRule : pointer to head spm check rules
  @param[in,out]        pVal      : pointer to local value
  
  @glob_in              None
  @glob_out             None 

  @c_switch_part        None
  @c_switch_full        @ref MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION 

  @pre                  None
  @post                 None
  
  @InOutCorrelation     see the description
  
  @testmethod           Test of output data (dynamic module test)

  @traceability         
                        @satisfy{doors://rbgs854a:40000/?version=2&prodID=0&urn=urn:telelogic::1-503e822e5ec3651e-O-1175-0007e0f8}

  @author               Armin Vogl | armin.vogl@continental-corporation.com      
  *************************************************************************************************************************/
static void HEADSPMFunctionCheck_float32(const HEADSPMCheck_t *pThisRule, float32 *pVal)
{
  /* PRQA S 1482 2 */ /* This cast to enum type is valid */
  eHEADSPMCheckBitsStdDeviation_t eCheckStdDev   = (eHEADSPMCheckBitsStdDeviation_t) HEADSPMGetBitsStdDeviation(pThisRule->bitCheckType);
  eHEADSPMCheckBitsFunction_t     eCheckFunction = (eHEADSPMCheckBitsFunction_t)HEADSPMGetBitsFunction(pThisRule->bitCheckType);
  
  if (eCheckFunction == HEADSPMCheckBitsFunction_ABS)
  {
    *pVal = fABS(*pVal);
  }
  /* apply standard deviation if necessary */
  switch(eCheckStdDev)
  {
    case HEADSPMCheckBitsStdDeviation_Minus:
      *pVal-= HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_Plus:
      *pVal+= HEADGetInputStdDev(*pThisRule->pInputSignal);
      break;
    case HEADSPMCheckBitsStdDeviation_No:
      /*Do nothing*/
      break;
    case HEADSPMCheckBitsStdDeviation_Max:
    default:
      MEDIC_ASSERT(FALSE);/*PRQA S 3119 */ /* date: 2019-09-19, reviewer: Srinivasa, Sadhanashree, Reason: This code is placed for assertive failure and hence cannot be removed */
      break;
  }
}

#endif /* MEDIC_CFG_HYPOTHESIS_EVAL_AND_DECISION */
#endif /* MEDIC_CFG_HEAD20 */

