* qac.usr.m2cm
*
* copyright:  (c) 2009 - Programming Research
*
* Purpose:  M2CM-3.2-QAC-8.1.1 configuration user message file
*
* History:  Auto-created from Database
*
* CMS version: 0.1a
*
#levelname                         0     Information
#levelname                         1     Conti Naming Convention Check
#levelname                         2     Minor
#levelname                         3     Mandatory
#levelname                         4     Critical
#levelname                         5     Errors
#define    ODF_Control             1     Dataflow - Control flow
#define    ODF_Redundancy          1     Dataflow - Redundancy
#define    OTC_Enums               1     Arithmetic type - Enum types 
#define    OTC_Implicit            1     Arithmetic type - Implicit conversions
#define    DF_Recovery             0     Data flow analysis failure
#define    DF_Critical             4     Critical data flow warning 
#define    DF_Mandatory            3     Mandatory data flow warning
#define    NCC_MACRO         	   1     Naming Conventions for macros
#define    NCC_VAR_LOC         	   1     Naming Conventions for local variables
#define    NCC_VAR_GLOB        	   1     Naming Conventions for global variables
#define    NCC_FCT        	       1     Naming Conventions for functions 
#define    NCC_TYPE        	       1     Naming Conventions for types
#define    HIS_METRICS_STCDN  	   0     HIS metrics check: comment density
#define    HIS_METRICS_STPTH  	   3     HIS metrics check: amount of non-cyclic paths
#define    HIS_METRICS_STGTO  	   3     HIS metrics check: number of goto-statements
#define    HIS_METRICS_STCYC  	   3     HIS metrics check: cyclomatic complexitiy
#define    HIS_METRICS_STM29  	   0     HIS metrics check: number of calling functions
#define    HIS_METRICS_STCAL  	   0     HIS metrics check: number of called functions
#define    HIS_METRICS_STPAR  	   3     HIS metrics check: number of function parameters
#define    HIS_METRICS_STMIF  	   0     HIS metrics check: function nesting level
#define    HIS_METRICS_STM19  	   3     HIS metrics check: number of exit points
#define    HIS_METRICS_STNRA  	   3     HIS metrics check: Call graph recursions
#define    ANT_information         0     Annotations
#define    METRICS_STXLN  	       3     metrics check: executable lines of code per function
#define    METRICS_STTPP  	       2     metrics check: executable lines of code per file
#define    CMA_information         0     CMA information
#define    Parser_Rec              0     Recovery
#define    submsg                  0     Sub-Messages
#define    DF_Signed               2     Conversion to signed      
#define    DF_Unsigned             2     Conversion to unsigned
#define    DF_Shift                2     Shift operations
#define    DF_Overflow             2     Overflow and wraparound
#define    DF_Arrays               2     Arrays       
#define    DF_Pointers             2     Pointers
#define    DF_NULL                 2     NULL pointers
#define    DF_Unset                2     Unset data
#define    DF_Redundancy           2     Redundancy
#define    DF_Invariant            2     Invariant operations
#define    DF_Control              2     Control flow
#define    Min_Assignment          2     Arithmetic type - Assignment
#define    Min_Array               2     Arrays, structures, unions & bit-fields
#define    Min_Brace               2     Bracing and Indentation
#define    Min_Complex             2     Arithmetic type - Composite expressions
#define    Min_Cpp                 2     C++ compatibility
#define    Min_Casts               2     Arithmetic type - Casts
#define    CMA_declaration         2     CMA declaration checks
#define    CMA_maintenance         2     CMA maintenance checks
#define    Min_Balancing           2     Arithmetic type - Balancing
#define    Min_Const               2     Constants
#define    Min_Ctrl                2     Control flow
#define    Min_Decl                2     Declarations and Definitions
#define    Min_Enum                2     Enumerations
#define    Min_Func                2     Functions
#define    Min_Ident               2     Identifiers
#define    Min_Prom                2     Integral promotion
#define    Min_KandR               2     K&R compatibility
#define    Metrics                 2     Metric thresholds
#define    Obsolete                2     Obsolete
#define    Min_MacroDefs           2     Macro Definition
#define    Min_Operands            2     Arithmetic type - Operands
#define    Min_Operations          2     Arithmetic type - Operations
#define    Min_Ops                 2     Operations
#define    Min_Prepro              2     Preprocessor
#define    Min_Side                2     Side Effects
#define    Min_Stmt                2     Statements
#define    Min_Switch              2     Switch statements
#define    Min_Pointers            2     Pointers
#define    Min_Redun               2     Redundancy
#define    Min_Read                2     Readability
#define    Maj_Array               3     Arrays, structures, unions & bit-fields
#define    Maj_Balancing           3     Arithmetic type - Balancing
#define    Maj_Brace               3     Bracing and Indentation
#define    Maj_Casts               3     Arithmetic type - Casts
#define    Maj_Ctrl                3     Control flow
#define    Maj_Cpp                 3     C++ compatibility
#define    Maj_Decl                3     Declarations and definitions
#define    Maj_DF_Invariant        3     Invariant operations
#define    Maj_Enum                3     Enumerations
#define    Maj_Func                3     Functions
#define    Maj_FLtoI               3     Implicit conversions - float to integer
#define    Maj_ItoFL               3     Implicit conversions - integer to float
#define    Maj_MacroDefs           3     Macro Definition
#define    Maj_Small               3     Implicit conversions - narrowing
#define    Maj_Pchar               3     Implicit conversions - plain char
#define    Maj_StoUS               3     Implicit conversions - signed to unsigned
#define    Maj_UStoLS              3     Implicit conversions - unsigned to larger signed
#define    Maj_UStoS               3     Implicit conversions - unsigned to signed
#define    Maj_Ops                 3     Operations
#define    Maj_Operands            3     Arithmetic type - Operands
#define    Maj_Operations          3     Arithmetic type - Operations
#define    Maj_Pointers            3     Pointers
#define    Maj_Prepro              3     Preprocessor
#define    Maj_Prom                3     Integral promotion
#define    Maj_Redun               3     Redundancy
#define    Maj_Stmt                3     Statements
#define    Maj_Switch              3     Switch statements
#define    Maj_Side                3     Side Effects
#define    Maj_Ident               3     Identifiers
#define    Maj_Const               3     Constants
#define    Maj_KandR               3     K&R compatibility
#define    Cri_Func                4     Functions
#define    Cri_Decl                4     Declarations and definitions
#define    Cri_MacroDefs           4     Macro Definition
#define    local                   3     Local Standards
#define    ISO_C90_Limits          2     ISO C90 Conformance limits
#define    ISO_C99_Limits          3     ISO C99 Conformance limits
#define    ISO_ImplDef             2     Implementation defined
#define    Lang_ext                2     Language extensions
#define    C99_ext                 2     ISO C99 Language features
#define    CMA_warning             3     CMA undefined
#define    ISO_ExpU                3     Explicitly undefined
#define    ISO_ImpU                3     Implicitly undefined
#define    Constraint              3     Constraint violations
#define    Config                  5     QAC configuration
#define    Syntax                  5     Syntax errors
#define    RULE001_1               3     M2CM Rule 1.1
#define    RULE001_2               3     M2CM Rule 1.2
#define    RULE001_3               3     M2CM Rule 1.3
#define    RULE001_4               3     M2CM Rule 1.4
#define    RULE001_5               2     M2CM Rule 1.5
#define    RULE002_1               3     M2CM Rule 2.1
#define    RULE002_2               3     M2CM Rule 2.2
#define    RULE002_3               3     M2CM Rule 2.3
#define    RULE002_4               2     M2CM Rule 2.4
#define    RULE003_1               3     M2CM Rule 3.1
#define    RULE003_2               3     M2CM Rule 3.2
#define    RULE003_3               2     M2CM Rule 3.3
#define    RULE003_4               3     M2CM Rule 3.4
#define    RULE003_5               3     M2CM Rule 3.5
#define    RULE003_6               3     M2CM Rule 3.6
#define    RULE004_1               3     M2CM Rule 4.1
#define    RULE004_2               3     M2CM Rule 4.2
#define    RULE005_1               3     M2CM Rule 5.1
#define    RULE005_2               3     M2CM Rule 5.2
#define    RULE005_3               3     M2CM Rule 5.3
#define    RULE005_4               3     M2CM Rule 5.4
#define    RULE005_5               2     M2CM Rule 5.5
#define    RULE005_6               2     M2CM Rule 5.6
#define    RULE005_7               2     M2CM Rule 5.7
#define    RULE006_1               3     M2CM Rule 6.1
#define    RULE006_2               3     M2CM Rule 6.2
#define    RULE006_3               2     M2CM Rule 6.3
#define    RULE006_4               3     M2CM Rule 6.4
#define    RULE006_5               3     M2CM Rule 6.5
#define    RULE007_1               3     M2CM Rule 7.1
#define    RULE008_1               3     M2CM Rule 8.1
#define    RULE008_2               3     M2CM Rule 8.2
#define    RULE008_3               3     M2CM Rule 8.3
#define    RULE008_4               3     M2CM Rule 8.4
#define    RULE008_5               3     M2CM Rule 8.5
#define    RULE008_6               3     M2CM Rule 8.6
#define    RULE008_7               3     M2CM Rule 8.7
#define    RULE008_8               3     M2CM Rule 8.8
#define    RULE008_9               3     M2CM Rule 8.9
#define    RULE08_10               3     M2CM Rule 8.10
#define    RULE08_11               3     M2CM Rule 8.11
#define    RULE08_12               3     M2CM Rule 8.12
#define    RULE009_1               3     M2CM Rule 9.1
#define    RULE009_2               3     M2CM Rule 9.2
#define    RULE009_3               3     M2CM Rule 9.3
#define    RULE010_1               4     M2CM Rule 10.1
#define    RULE010_2               4     M2CM Rule 10.2
#define    RULE010_3               3     M2CM Rule 10.3
#define    RULE010_4               3     M2CM Rule 10.4
#define    RULE010_5               3     M2CM Rule 10.5
#define    RULE010_6               3     M2CM Rule 10.6
#define    RULE011_1               3     M2CM Rule 11.1
#define    RULE011_2               3     M2CM Rule 11.2
#define    RULE011_3               2     M2CM Rule 11.3
#define    RULE011_4               2     M2CM Rule 11.4
#define    RULE011_5               3     M2CM Rule 11.5
#define    RULE012_1               2     M2CM Rule 12.1
#define    RULE012_2               4     M2CM Rule 12.2
#define    RULE012_3               3     M2CM Rule 12.3
#define    RULE012_4               4     M2CM Rule 12.4
#define    RULE012_5               3     M2CM Rule 12.5
#define    RULE012_6               2     M2CM Rule 12.6
#define    RULE012_7               3     M2CM Rule 12.7
#define    RULE012_8               3     M2CM Rule 12.8
#define    RULE012_9               3     M2CM Rule 12.9
#define    RULE12_10               3     M2CM Rule 12.10
#define    RULE12_11               2     M2CM Rule 12.11
#define    RULE12_12               3     M2CM Rule 12.12
#define    RULE12_13               2     M2CM Rule 12.13
#define    RULE013_1               4     M2CM Rule 13.1
#define    RULE013_2               2     M2CM Rule 13.2
#define    RULE013_3               4     M2CM Rule 13.3
#define    RULE013_4               3     M2CM Rule 13.4
#define    RULE013_5               3     M2CM Rule 13.5
#define    RULE013_6               4     M2CM Rule 13.6
#define    RULE013_7               3     M2CM Rule 13.7
#define    RULE014_1               3     M2CM Rule 14.1
#define    RULE014_2               3     M2CM Rule 14.2
#define    RULE014_3               3     M2CM Rule 14.3
#define    RULE014_4               4     M2CM Rule 14.4
#define    RULE014_5               3     M2CM Rule 14.5
#define    RULE014_6               3     M2CM Rule 14.6
#define    RULE014_7               3     M2CM Rule 14.7
#define    RULE014_8               3     M2CM Rule 14.8
#define    RULE014_9               3     M2CM Rule 14.9
#define    RULE14_10               3     M2CM Rule 14.10
#define    RULE015_0               3     M2CM Rule 15.0
#define    RULE015_1               3     M2CM Rule 15.1
#define    RULE015_2               3     M2CM Rule 15.2
#define    RULE015_3               3     M2CM Rule 15.3
#define    RULE015_4               3     M2CM Rule 15.4
#define    RULE015_5               3     M2CM Rule 15.5
#define    RULE016_1               4     M2CM Rule 16.1
#define    RULE016_2               4     M2CM Rule 16.2
#define    RULE016_3               3     M2CM Rule 16.3
#define    RULE016_4               3     M2CM Rule 16.4
#define    RULE016_5               3     M2CM Rule 16.5
#define    RULE016_6               3     M2CM Rule 16.6
#define    RULE016_7               2     M2CM Rule 16.7
#define    RULE016_8               3     M2CM Rule 16.8
#define    RULE016_9               3     M2CM Rule 16.9
#define    RULE16_10               3     M2CM Rule 16.10
#define    RULE017_1               3     M2CM Rule 17.1
#define    RULE017_2               3     M2CM Rule 17.2
#define    RULE017_3               3     M2CM Rule 17.3
#define    RULE017_4               3     M2CM Rule 17.4
#define    RULE017_5               2     M2CM Rule 17.5
#define    RULE017_6               3     M2CM Rule 17.6
#define    RULE018_1               3     M2CM Rule 18.1
#define    RULE018_2               3     M2CM Rule 18.2
#define    RULE018_3               3     M2CM Rule 18.3
#define    RULE018_4               3     M2CM Rule 18.4
#define    RULE019_1               2     M2CM Rule 19.1
#define    RULE019_2               3     M2CM Rule 19.2
#define    RULE019_3               3     M2CM Rule 19.3
#define    RULE019_4               3     M2CM Rule 19.4
#define    RULE019_5               4     M2CM Rule 19.5
#define    RULE019_6               3     M2CM Rule 19.6
#define    RULE019_7               2     M2CM Rule 19.7
#define    RULE019_8               3     M2CM Rule 19.8
#define    RULE019_9               3     M2CM Rule 19.9
#define    RULE19_10               3     M2CM Rule 19.10
#define    RULE19_11               3     M2CM Rule 19.11
#define    RULE19_12               4     M2CM Rule 19.12
#define    RULE19_12M              3     M2CM Rule 19.12
#define    RULE19_13               2     M2CM Rule 19.13
#define    RULE19_14               3     M2CM Rule 19.14
#define    RULE19_15               3     M2CM Rule 19.15
#define    RULE19_16               3     M2CM Rule 19.16
#define    RULE19_17               3     M2CM Rule 19.17
#define    RULE020_1               3     M2CM Rule 20.1
#define    RULE020_2               3     M2CM Rule 20.2
#define    RULE020_3               3     M2CM Rule 20.3
#define    RULE020_4               3     M2CM Rule 20.4
#define    RULE020_5               3     M2CM Rule 20.5
#define    RULE020_6               3     M2CM Rule 20.6
#define    RULE020_7               3     M2CM Rule 20.7
#define    RULE020_8               3     M2CM Rule 20.8
#define    RULE020_9               3     M2CM Rule 20.9
#define    RULE20_10               3     M2CM Rule 20.10
#define    RULE20_11               3     M2CM Rule 20.11
#define    RULE20_12               3     M2CM Rule 20.12
#define    RULE021_1               3     M2CM Rule 21.1

9	Config	[Q] The length of this preprocessed source code line has exceeded the size of an internal buffer.\\
REFERENCE - ISO:C90-5.2.4.1 Translation Limits

40	Config	[Q] Definition of size_t differs from configured type.

41	Config	[Q] Definition of ptrdiff_t differs from configured type.

42	Config	[Q] Definition of wchar_t differs from configured type.

97	DF_Recovery	Recoverable dataflow problem. Analysis continues. Please inform Programming Research.

159	Config	[Q] The maximum number of errors set by -maxerr has been exceeded - the analysis has been aborted.

160    RULE001_2             [U] Using unsupported conversion specifier number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6 Formatted input/output functions

161    RULE001_2             [U] Unknown length modifier used with 'i' or 'd' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

162    RULE001_2             [U] Unknown length modifier used with 'o' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

163    RULE001_2             [U] Unknown length modifier used with 'u' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

164    RULE001_2             [U] Unknown length modifier used with 'x' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

165    RULE001_2             [U] Unknown length modifier used with 'X' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

166    RULE001_2             [U] Unknown length modifier used with 'f' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

167    RULE001_2             [U] Unknown length modifier used with 'e' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

168    RULE001_2             [U] Unknown length modifier used with 'E' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

169    RULE001_2             [U] Unknown length modifier used with 'g' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

170    RULE001_2             [U] Unknown length modifier used with 'G' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

171    RULE001_2             [U] Unknown length modifier used with 'c' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

172    RULE001_2             [U] Unknown length modifier used with '%%' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

173    RULE001_2             [U] Unknown length modifier used with 's' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

174    RULE001_2             [U] Unknown length modifier used with 'n' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

175    RULE001_2             [U] Unknown length modifier used with 'p' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

176    RULE001_2             [U] Incomplete conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

177    RULE001_2             [U] Field width of format conversion specifier exceeds 509 characters.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Environmental limit

178    RULE001_2             [U] Precision of format conversion specifier exceeds 509 characters.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Environmental limit

179    RULE001_2             [U] Argument type does not match conversion specifier number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

180    RULE001_1             [C99] Use of ll for conversion specifier.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C99-7.19.6 Formatted input/output functions

184    RULE001_2             [U] Insufficient arguments to satisfy conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6 Formatted input/output functions

185    RULE001_2             [U] Call contains more arguments than conversion specifiers.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6 Formatted input/output functions

186    RULE001_2             [U] A call to this function must include at least one argument.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6 Formatted input/output functions

190    RULE001_2             [U] Using unsupported conversion specifier number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

191    RULE001_2             [U] Unknown length modifier used with 'd/i/n' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

192    RULE001_2             [U] Unknown length modifier used with 'o' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

193    RULE001_2             [U] Unknown length modifier used with 'u' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

194    RULE001_2             [U] Unknown length modifier used with 'x/X' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

195    RULE001_2             [U] Unknown length modifier used with 'e/E/f/F/g/G' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

196    RULE001_2             [U] Unknown length modifier used with 's' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

197    RULE001_2             [U] Unknown length modifier used with 'p' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

198    RULE001_2             [U] Unknown length modifier used with '%%' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

199    RULE001_2             [U] Unknown length modifier used with '[' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

200    RULE001_2             [U] Unknown length modifier used with 'c' conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

201    RULE001_2             [U] Incomplete conversion specifier, number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

202    RULE003_1             [I] '-' character in '[]' conversion specification is implementation defined.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

203    RULE001_2             [U] Value of character prior to '-' in '[]' is greater than following character.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 The fscanf Function

204    RULE001_2             [U] Field width of format conversion specifier exceeds 509 characters.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

206    RULE001_2             [U] Argument type does not match conversion specifier number %s.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

207    RULE001_2             [U] 'scanf' expects address of objects being stored into.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9, ISO:C90-7.9.6.4 - The scanf Function

208    RULE001_2             [U] Same character occurs in scanset more than once.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

231	Syntax	[S] Character constant contains an invalid hex escape sequence.\\
REFERENCE - ISO:C90-6.1.3.4 Character Constants - Syntax

232	RULE001_1	[C] Value of hex escape sequence is not representable in type 'unsigned char'.\\
REFERENCE - ISO:C90-6.1.3.4 Character Constants - Constraints

233	RULE001_1	[C] Value of octal escape sequence is not representable in type 'unsigned char'.\\
REFERENCE - ISO:C90-6.1.3.4 Character Constants - Constraints

234	Syntax	[S] String literal contains an invalid hex escape sequence.\\
REFERENCE - ISO:C90-6.1.4, ISO:C90-6.1.3.4 Character Constants - Syntax

235    RULE004_1             [U] Unknown escape sequence.\\
MISRA-C:2004 Rule 4.1; REFERENCE - ISO:C90-6.1.3.4 Description, ISO:C90-6.9.2 Future Language Directions

240    RULE001_1             [E] This file contains the control-M character at the end of a line.\\
MISRA-C:2004 Rule 1.1

241    RULE001_1             [E] This file contains the control-Z character - was this transferred from a PC?\\
MISRA-C:2004 Rule 1.1

244	RULE001_1	[C] Value of character constant is not representable in type 'int'.\\
REFERENCE - ISO:C90-6.1.3 Constants - Constraints

245	Syntax	[S] Empty character constant.\\
REFERENCE - ISO:C90-6.1.3.4 Character Constants - Syntax

246    RULE001_1             [E] Binary integer constants are a language extension.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.1.3.2 Integer Constants

249	Syntax	[S] Character constant contains a new-line character.\\
REFERENCE - ISO:C90-6.1.3.4 Character Constants - Syntax

250	Syntax	[S] Character constant contains a single backslash character.\\
REFERENCE - ISO:C90-6.1.3.4  Character Constants - Syntax

251	Syntax	[S] Character constant contains a trigraph representation of a single backslash character.\\
REFERENCE - ISO:C90-5.2.1.1 Trigraph Sequences, ISO:C90-6.1.3.4 Character Constants

257	Syntax	[S] String literal is not terminated. A trigraph has been used in the construction of an escape sequence.\\
REFERENCE - ISO:C90-6.1.3.4  Character Constants, ISO:C90-5.2.1.1 Trigraph Sequences

258	Syntax	[S] String literal is not terminated. A backslash character has been used to define an escape sequence.\\
REFERENCE - ISO:C90-6.1.4 String Literals - Syntax

259	Syntax	[S] String literal is not terminated.\\
REFERENCE - ISO:C90-6.1.4 String Literals - Syntax

261	RULE001_1	[C] Comment still open at end of included file.\\
REFERENCE - ISO:C90-5.1.1.2 Translation phases

268	Syntax	[S] Comment open at end of translation unit.\\
REFERENCE - ISO:C90-5.1.1.2 Translation phases

269	Syntax	[S] Unexpected end of file.

* message 271 is replaced by 2860 Data flow: 271    RULE003_1             [U] Left shift operation on constant signed expression generating an undefined value.\\
* MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-6.3.7 Bitwise Shift Operators, ISO:C90-6.4, ISO:C99-6.5.7 Bitwise shift operators

* message 272 is replaced by 2852+2857 Data flow: 272    RULE021_1             [I] Apparent conversion of integer expression to a signed integer type which cannot represent the value.\\
* MISRA-C:2004 Rule 21.1; REFERENCE - ISO:C90-6.2.1.2 Conversions (to Signed Integers)

* message 273 is replaced by 2851+2856 Data flow: 273    RULE021_1             [I] Definite conversion of integer expression to a signed integer type which cannot represent the value.\\
* MISRA-C:2004 Rule 21.1; REFERENCE - ISO:C90-6.2.1.2 Conversions (to Signed Integers)

* message 274 is replaced by 2850 Data flow: 274    RULE003_1             [I] Conversion of integer constant expression to a signed integer type which cannot represent the value.\\
* MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-6.2.1.2 Conversions (to Signed Integers)

275    RULE001_2             [U] Floating value is out of range for conversion to destination type.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.2.1.3 Conversions (Floating and Integral)

* message 277 is replaced by 2890 data flow: 277    RULE003_1             Conversion of a constant negative value to an unsigned type.\\
* MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-6.2.1.2 Conversions - Signed and Unsigned Integers

* message 278 is replaced by 2800 data flow
* message 280 is replaced by 2940 data flow
* message 281 is replaced by 2941+2946 data flow
* message 282 is replaced by 2942+2947 data flow

284    RULE003_1             [I] Multiple character constants have implementation defined values.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-6.1.3.4 Character Constants - Semantics

285    RULE003_1             [I] Character constant contains character which is not a member of the basic source character set.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-5.2.1 Character Sets

286    RULE003_1             [I] String literal contains character which is not a member of the basic source character set.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-5.2.1 Character Sets

287    RULE003_1             [I] Header name contains character which is not a member of the basic source character set.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-5.2.1 Character Sets

288    RULE003_1             [I] Source file '%s' has comments containing characters which are not members of the basic source character set.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-5.2.1 Character Sets

289    RULE003_1             [I] Source file '%s' has preprocessing tokens containing characters which are not members of the basic source character set.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-5.2.1 Character Sets

* message 290 is replaced by 2891 data flow: 290    RULE021_1             Definite conversion of a negative value to an unsigned type.\\
*MISRA-C:2004 Rule 21.1; REFERENCE - ISO:C90-6.2.1.2 Conversions - Signed and Unsigned Integers

* message 291 is replaced by 2892 data flow: 291    RULE021_1             Apparent conversion of a negative value to an unsigned type.\\
* MISRA-C:2004 Rule 21.1; REFERENCE - ISO:C90-62.1.2 Conversions - Signed and Unsigned Integers

292    RULE003_1             [I] Source file '%s' has comments containing one of the characters '$', '@' or '`'.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-5.2.1 Character Sets

* message 294 is replaced by 2861 data flow: 294    RULE003_1             [U] Definite signed left shift operation generating an undefined value.\\
* MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-6.3.7 Bitwise Shift Operators, ISO:C90-6.4, ISO:C99-6.5.7 Bitwise shift operators

* message 295 is replaced by 2862 data flow: 295    RULE003_1             [U] Apparent signed left shift operation generating an undefined value.\\
* MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-6.3.7 Bitwise Shift Operators, ISO:C90-6.4, ISO:C99-6.5.7 Bitwise shift operators

* message 296 is replaced by 2801 data flow: 296    RULE021_1             [U] Definite overflow in signed arithmetic operation.\\
* MISRA-C:2004 Rule 21.1; REFERENCE - ISO:C90-6.3 Expressions

* message 297 is replaced by 2802 data flow: 297    RULE021_1             [U] Apparent overflow in signed arithmetic operation.\\
* MISRA-C:2004 Rule 21.1; REFERENCE - ISO:C90-6.3 Expressions

299    RULE003_1             [I] Source file '%s' includes #pragma directives containing characters which are not members of the basic source character set.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-5.2.1 Character Sets

301    RULE011_2             [u] Cast between a pointer to object and a floating type.\\
MISRA-C:2004 Rule 11.2; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

302    RULE011_1             [u] Cast between a pointer to function and a floating type.\\
MISRA-C:2004 Rule 11.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

303    RULE003_1             [I] Cast between a pointer to volatile object and an integral type.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

304    RULE001_2             [U] The address of an array declared 'register' may not be computed.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.5.1 Storage-Class Specifiers - Semantics

305    RULE003_1             [I] Cast between a pointer to function and an integral type.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

306    RULE003_1             [I] Cast between a pointer to object and an integral type.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

307    RULE011_1             [u] Cast between a pointer to object and a pointer to function.\\
MISRA-C:2004 Rule 11.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

308    RULE003_1             Non-portable cast involving pointer to an incomplete type.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

309    RULE001_2             [U] Integral type is not large enough to hold a pointer value.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

310    RULE011_4             Casting to different object pointer type.\\
MISRA-C:2004 Rule 11.4; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

311    RULE011_5             Dangerous pointer cast results in loss of const qualification.\\
MISRA-C:2004 Rule 11.5

312    RULE011_5             Dangerous pointer cast results in loss of volatile qualification.\\
MISRA-C:2004 Rule 11.5

313    RULE011_1             Casting to different function pointer type.\\
MISRA-C:2004 Rule 11.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

314	Min_Pointers	[I] Cast from a pointer to object type to a pointer to void.\\
REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

315	Min_Pointers	[I] Implicit conversion from a pointer to object type to a pointer to void.\\
REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

316	RULE011_4	[I] Cast from a pointer to void to a pointer to object type.\\
REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

317	RULE011_4	[I] Implicit conversion from a pointer to void to a pointer to object type.\\
REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

318	Min_Redun	Redundant type qualifier used in cast\\
REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

320    RULE001_1             [C99] Declaration within 'for' statement.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C99-6.8.5 Iteration statements

321	RULE001_1	[C] Declaration within 'for' statement defines an identifier '%s' which is not an object.\\
REFERENCE - ISO:C99-6.8.5 Iteration statements - Constraints

322	RULE001_1	[C] Illegal storage class specifier used in 'for' statement declaration.\\
REFERENCE - ISO:C99-6.8.5 Iteration statements - Constraints

336    RULE007_1             Macro defined as an octal constant.\\
MISRA-C:2004 Rule 7.1

337    RULE001_2             [U] String literal has undefined value. This may be a result of using '#' on \\.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.8.3.2 The # Operator - Semantics

338	RULE001_1	[C] Octal or hex escape sequence value is too large for 'unsigned char' or 'wchar_t' type.\\
REFERENCE - ISO:C90-6.1.3.4 Character Constants - Constraints

339    RULE007_1             Octal constant used.\\
MISRA-C:2004 Rule 7.1

340	Min_KandR	Using the '#error' preprocessing directive.\\
REFERENCE - ISO:C90-6.8.5 Error Directive

341    RULE19_13             Using the stringify operator '#'.\\
MISRA-C:2004 Rule 19.13; REFERENCE - ISO:C90-6.8.3.2 The # Operator

342    RULE19_13             Using the glue operator '##'.\\
MISRA-C:2004 Rule 19.13; REFERENCE - ISO:C90-6.8.3.3 The ## Operator

343	Min_KandR	Using string literal concatenation.\\
REFERENCE - ISO:C90-5.1.1.2 Translation Phases

344	Min_KandR	Using function prototype syntax.\\
REFERENCE - ISO:C90-6.5.4.3 Function Declarators (Including Prototypes)

345	Min_KandR	Using the keyword 'void'.\\
REFERENCE - ISO:C90-6.1.2.5 Types

346	Min_KandR	Using one of the keywords 'signed', 'const' or 'volatile'.

347	Min_KandR	Using 'extern' in the definition of a global variable.

348	Min_KandR	Using a bit-field.

349	Min_KandR	Using the unary '+' operator.\\
REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators

350	Min_KandR	Using the keyword 'enum'.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

351	Min_KandR	Using an initializer when defining an automatic object of struct, union or array type.\\
REFERENCE - ISO:C90-6.5.7 Initialization

352	Min_KandR	Using the '#elif' preprocessing directive.\\
REFERENCE - ISO:C90-6.8.1 Preprocessing Directives - Conditional Inclusion

360	RULE011_3	An expression of pointer type is being converted to type _Bool on assignment.\\
REFERENCE - ISO:C99-6.5.16.1 Simple assignment

361	RULE011_3	An expression of pointer type is being cast to type _Bool.\\
REFERENCE - ISO:C99-6.3.1.2 Boolean type

362	RULE011_3	An expression of essentially Boolean type is being cast to a pointer.\\
REFERENCE - ISO:C99-6.3.1.2 Boolean type

371	ISO_C99_Limits	[L] Nesting levels of blocks exceeds 127 - program does not conform strictly to ISO:C99.\\
REFERENCE - ISO:C99-5.2.4.1 Translation Limits

372	ISO_C99_Limits	[L] More than 63 levels of nested conditional inclusion - program does not conform strictly to ISO:C99.\\
REFERENCE - ISO:C99-5.2.4.1 Translation Limits

375	ISO_C99_Limits	[L] Nesting of parenthesized expressions exceeds 63 - program does not conform strictly to ISO:C99.\\
REFERENCE - ISO:C99-5.2.4.1 Translation Limits

380	ISO_C99_Limits	[L] Number of macro definitions exceeds 4095 - program does not conform strictly to ISO:C99.\\
REFERENCE - ISO:C99-5.2.4.1 Translation Limits

388	ISO_C99_Limits	[L] '#include "%s"' causes nesting to exceed 15 levels - program does not conform strictly to ISO:C99.\\
REFERENCE - ISO:C99-5.2.4.1 Translation Limits

390	ISO_C99_Limits	[L] Number of members in 'struct' or 'union' exceeds 1023 - program does not conform strictly to ISO:C99.\\
REFERENCE - ISO:C99-5.2.4.1 Translation Limits

391	ISO_C99_Limits	[L] Number of enumeration constants exceeds 1023 - program does not conform strictly to ISO:C99.\\
REFERENCE - ISO:C99-5.2.4.1 Translation Limits

392	ISO_C99_Limits	[L] Nesting of 'struct' or 'union' types exceeds 63 - program does not conform strictly to ISO:C99.\\
REFERENCE - ISO:C99-5.2.4.1 Translation Limits

400    RULE012_2             [U] '%s' is modified more than once between sequence points - evaluation order undefined.\\
MISRA-C:2004 Rule 12.2; REFERENCE - ISO:C90-6.3 Expressions

401    RULE012_2             [U] '%s' may be modified more than once between sequence points - evaluation order undefined.\\
MISRA-C:2004 Rule 12.2; REFERENCE - ISO:C90-6.3 Expressions

402    RULE012_2             [U] '%s' is modified and accessed between sequence points - evaluation order undefined.\\
MISRA-C:2004 Rule 12.2; REFERENCE - ISO:C90-6.3 Expressions

403    RULE012_2             [U] '%s' may be modified and accessed between sequence points - evaluation order undefined.\\
MISRA-C:2004 Rule 12.2; REFERENCE - ISO:C90-6.3 Expressions

410    RULE001_1             [L] Nesting of parentheses exceeds 32 - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

422    RULE016_6             [C] Function call contains fewer arguments than prototype specifies.\\
MISRA-C:2004 Rule 16.6; REFERENCE - ISO:C90-6.3.2.2 Function calls

423    RULE016_6             [C] Function call contains more arguments than prototype specifies.\\
MISRA-C:2004 Rule 16.6; REFERENCE - ISO:C90-6.3.2.2 Function calls

426	RULE001_1	[C] Called function has incomplete return type.\\
REFERENCE - ISO:C90-6.3.2.2 Function calls

427	RULE001_1	[C] Object identifier used as if it were a function or a function pointer identifier.\\
REFERENCE - ISO:C90-6.3.2.2 Function calls

428	Maj_Func	Function identifier is not followed by () but a function call may be intended.\\
REFERENCE - ISO:C90-6.2.2.1 Lvalues and Function Designators

429	RULE001_1	[C] Function argument is not of arithmetic type.\\
REFERENCE - ISO:C90-6.3.2.2 Function calls

430	RULE001_1	[C] Function argument is not of compatible 'struct'/'union' type.\\
REFERENCE - ISO:C90-6.3.2.2 Function calls

431	RULE001_1	[C] Function argument points to a more heavily qualified type.\\
REFERENCE - ISO:C90-6.3.2.2 Function calls

432	RULE001_1 [C] Function argument is not of compatible pointer type.\\
REFERENCE - ISO:C90-6.3.2.2 Function calls, ISO:C90-6.3.4

434	Syntax	[S] The identifier '%s' has not been declared.\\
REFERENCE - ISO:C90-6.3.1 Primary Expressions - Syntax

435	RULE001_1	[C] The 'struct'/'union' member '%s' does not exist.\\
REFERENCE - ISO:C90-6.3.2.3 Structure and union members

436	RULE001_1	[C] Left operand of '.' must be a 'struct' or 'union' object.\\
REFERENCE - ISO:C90-6.3.2.3 Structure and union members

437	RULE001_1	[C] Left operand of '->' must be a pointer to a 'struct' or 'union' object.\\
REFERENCE - ISO:C90-6.3.2.3 Structure and union members

446	RULE001_1	[C] Operand of ++/-- must have scalar (arithmetic or pointer) type.\\
REFERENCE - ISO:C90-6.3.2.4 (Postfix), ISO:C90-6.3.3.1 (Prefix) Increment and Decrement Operators

447	RULE001_1	[C] Operand of ++/-- must be a modifiable object.\\
REFERENCE - ISO:C90-6.3.2.4 (Postfix), ISO:C90-6.3.3.1 (Prefix) Increment and Decrement Operators

448	RULE001_1	[C] Operand of ++/-- must not be a pointer to an object of unknown size.\\
REFERENCE - ISO:C90-6.3.2.4 (Postfix), ISO:C90-6.3.3.1 (Prefix) Increment and Decrement Operators

449	RULE001_1	[C] Operand of ++/-- must not be a pointer to a function.\\
REFERENCE - ISO:C90-6.3.2.4 (Postfix), ISO:C90-6.3.3.1 (Prefix) Increment and Decrement Operators

450	RULE001_1	[C] An expression of array type cannot be cast.\\
REFERENCE - ISO:C90-6.3.4 Cast Operators - Constraints, ISO:C90-6.2.2.1 Lvalues and Function Designators

451	RULE001_1	[C] Subscripting requires a pointer (or array lvalue).\\
REFERENCE - ISO:C90-6.3.2.1 Array subscripting

452	RULE001_1	[C] Cannot subscript a pointer to an object of unknown size.\\
REFERENCE - ISO:C90-6.3.2.1 Array subscripting

453	RULE001_1	[C] An array subscript must have integral type.\\
REFERENCE - ISO:C90-6.3.2.1 Array subscripting

454	RULE001_1	[C] The address-of operator '&' cannot be applied to an object declared with 'register'.\\
REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Constraints

456	RULE001_1	[C] This expression does not have an address - '&' may only be applied to an lvalue or a function designator.\\
REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Constraints

457	RULE001_1	[C] The address-of operator '&' cannot be applied to a bit-field.\\
REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Constraints

458	RULE001_1	[C] Indirection operator '*' requires operand of pointer type.\\
REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Constraints

466	RULE001_1	[C] Unary '+' requires arithmetic operand.\\
REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Constraints

467	RULE001_1	[C] Operand of '!' must have scalar (arithmetic or pointer) type.\\
REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Constraints

468	RULE001_1	[C] Unary '-' requires arithmetic operand.\\
REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Constraints

469	RULE001_1	[C] Bitwise not '~' requires integral operand.\\
REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Constraints

473	Config	[Q] Result of 'sizeof' operation will not fit in configured type for 'size_t'.\\
REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator, ISO:C90-7.1.5 Common Definitions <stddef.h>

475    RULE001_2             [u] Operand of 'sizeof' is an expression designating a bit-field.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator

476	RULE001_1	[C] 'sizeof' cannot be applied to a bit-field.\\
REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator - Constraints

477	RULE001_1	[C] 'sizeof' cannot be applied to a function.\\
REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator - Constraints

478	RULE001_1	[C] 'sizeof' cannot be applied to an object of unknown size.\\
REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator - Constraints

481	RULE001_1	[C] Only scalar expressions may be cast to other types.\\
REFERENCE - ISO:C90-6.3.4 Cast Operators - Constraints

482	RULE001_1	[C] Expressions may only be cast to 'void' or scalar types.\\
REFERENCE - ISO:C90-6.3.4 Cast Operators - Constraints

483	RULE001_1	[C] A pointer to an object of unknown size cannot be the operand of an addition operator.\\
REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

484	RULE001_1	[C] A pointer to an object of unknown size cannot be the operand of a subtraction operator.\\
REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

485	RULE001_1	[C] Only integral expressions may be added to pointers.\\
REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

486	RULE001_1	[C] Only integral expressions and compatible pointers may be subtracted from pointers.\\
REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

487	RULE001_1	[C] If two pointers are subtracted, they must be pointers that address compatible types.\\
REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

488    RULE017_4             Performing pointer arithmetic.\\
MISRA-C:2004 Rule 17.4; REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

489    RULE017_4             The integer value 1 is being added or subtracted from a pointer.\\
MISRA-C:2004 Rule 17.4; REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

490	Min_Pointers	Relational operator used to compare two pointers.\\
REFERENCE - ISO:C90-6.3.8 Relational Operators

491    RULE017_4             Array subscripting applied to an object of pointer type.\\
MISRA-C:2004 Rule 17.4; REFERENCE - ISO:C90-6.3.2.1 Array Subscripting, ISO:C90 6.2.2.1 Lvalues and Function Designators, ISO:C90 6.7.1 Function Definitions - Semantics

492    RULE017_4             Array subscripting applied to a function parameter declared as a pointer.\\
MISRA-C:2004 Rule 17.4; REFERENCE - ISO:C90-6.3.2.1 Array Subscripting, ISO:C90 6.2.2.1 Lvalues and Function Designators, ISO:C90 6.7.1 Function Definitions - Semantics

493	RULE001_1	[C] Type of left operand is not compatible with this operator.\\
REFERENCE - ISO:C90-6.3.5 Multiplicative Operators - Constraints

494	RULE001_1	[C] Type of right operand is not compatible with this operator.\\
REFERENCE - ISO:C90-6.3.5 Multiplicative Operators - Constraints

495	RULE001_1	[C] Left operand of '%', '<<', '>>', '&', '^' or '|' must have integral type.\\
REFERENCE - ISO:C90-6.3.5, ISO:C90-6.3.7, ISO:C90-6.3.10, ISO:C90-6.3.11, ISO:C90-6.3.12

496	RULE001_1	[C] Right operand of '%', '<<', '>>', '&', '^' or '|' must have integral type.\\
REFERENCE - ISO:C90-6.3.5, ISO:C90-6.3.7, ISO:C90-6.3.10, ISO:C90-6.3.11, ISO:C90-6.3.12

499    RULE012_8             Right operand of shift operator is greater than or equal to the width of the underlying type.\\
MISRA-C:2004 Rule 12.8; REFERENCE - ISO:C90-6.3.7 Bitwise Shift Operators - Semantics

* message 500 is replaced by 2790 data flow: 500    RULE012_8             [U] Right operand of shift operator is negative - this is undefined.\\
* MISRA-C:2004 Rule 12.8; REFERENCE - ISO:C90-6.3.7 Bitwise Shift Operators - Semantics

* message 501 is replaced by 2790 data flow: 501    RULE012_8             [U] Right operand of shift operator is too large - this is undefined.\\
* MISRA-C:2004 Rule 12.8; REFERENCE - ISO:C90-6.3.7 Bitwise Shift Operators - Semantics

* message is obsolete: 502    RULE012_7             A right shift on signed data may be an arithmetic or a logical shift.\\
* MISRA-C:2004 Rule 12.7

* message is obsolete: 503    RULE001_2             [U] Dereference of constant NULL pointer.\\
* MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Semantics

* message is obsolete: 504    RULE001_2             [U] Definite dereference of NULL pointer.\\
* MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Semantics

* message is obsolete: 505    RULE001_2             [U] Apparent dereference of NULL pointer.\\
* MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Semantics

* message is obsolete: 507    RULE001_2             [u] Arithmetic operation on constant NULL pointer.\\
* MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.2.2.3 Pointers

* message is obsolete: 508    RULE001_2             [u] Definite arithmetic operation on NULL pointer.\\
* MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.2.2.3 Pointers

* message is obsolete: 509    RULE001_2             [u] Apparent arithmetic operation on NULL pointer.\\
* MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.2.2.3 Pointers

* message is obsolete: 510	ODF_NULL	Possible arithmetic operation on NULL pointer.

513	RULE001_1	[C] Relational operator used to compare pointers to incompatible types.\\
REFERENCE - ISO:C90-6.3.8 Relational Operators - Constraints

514	RULE001_1	[C] Relational operator used to compare a pointer with an incompatible operand.\\
REFERENCE - ISO:C90-6.3.8 Relational Operators - Constraints

515	RULE001_1	[C] Equality operator used to compare a pointer with an incompatible operand.\\
REFERENCE - ISO:C90-6.3.9 Equality Operators - Constraints

536	RULE001_1	[C] First operand of '&&', '||' or '?' must have scalar (arithmetic or pointer) type.\\
REFERENCE - ISO:C90-6.3.13-15 Logical AND Operator - Constraints

537	RULE001_1	[C] Second operand of '&&' or '||' must have scalar (arithmetic or pointer) type.\\
REFERENCE - ISO:C90-6.3.13-14 Logical AND Operator - Constraints

540	RULE001_1	[C] 2nd and 3rd operands of conditional operator '?' must have compatible types.\\
REFERENCE - ISO:C90-6.3.15 Conditional Operator - Constraints

541	RULE001_1	[C] Argument no. %s does not have object type.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls - Constraints

542	RULE001_1	[C] Controlling expression must have scalar (arithmetic or pointer) type.\\
REFERENCE - ISO:C90-6.6.4.1 The if Statement - Constraints, ISO:C90-6.6.5 Iteration Statements - Constraints

543    RULE001_2             [U] 'void' expressions have no value and may not be used in expressions.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.2.2.2 void

544    RULE018_1             [U] The value of an incomplete 'union' may not be used.\\
MISRA-C:2004 Rule 18.1; REFERENCE - ISO:C90-6.2.2.1 lvalues

545    RULE018_1             [U] The value of an incomplete 'struct' may not be used.\\
MISRA-C:2004 Rule 18.1; REFERENCE - ISO:C90-6.2.2.1 lvalues

546	RULE001_1	[C] 'enum %s' has unknown content. Use of an enum tag with undefined content is not permitted.\\
REFERENCE - ISO:C90-6.5.2.3 Tags

547    RULE005_4             [C] This declaration of tag '%s' conflicts with a previous declaration.\\
MISRA-C:2004 Rule 5.4; REFERENCE - ISO:C90-6.5 Declarations - Constraints, ISO:C90-6.5.2.3 Tags

550	RULE001_1	[C] Left operand of '+=' or '-=' is a pointer to an object of unknown size.\\
REFERENCE - ISO:C90-6.3.16.2 Compound Assignment - Constraints

551    RULE001_1             [E] Cast may not operate on the left operand of the assignment operator.\\
MISRA-C:2004 Rule 1.1

553	Min_Decl	Translation unit contains no object or function definitions with external linkage.

554	RULE001_1	[C] 'static %s()' has been declared and called but no definition has been given.\\
REFERENCE - ISO:C90-6.7 External Definitions - Constraints

555	RULE001_1	[C] Invalid assignment to object of void type or array type.\\
REFERENCE - ISO:C90-6.3.16 Assignment Operators - Constraints

556	RULE001_1	[C] Left operand of assignment must be a modifiable object.\\
REFERENCE - ISO:C90-6.3.16 Assignment Operators - Constraints

557	RULE001_1	[C] Right operand of assignment is not of arithmetic type.\\
REFERENCE - ISO:C90-6.3.16 Assignment Operators - Constraints

558	RULE001_1	[C] Right operand of '+=' or '-=' must have integral type when left operand is a pointer.\\
REFERENCE - ISO:C90-6.3.16.2 Compound Assignment - Constraints

559	RULE001_1	[C] Right operand of '<<=', '>>=', '&=', '|=', '^=' or '%=' must have integral type.\\
REFERENCE - ISO:C90-6.3.16.2 Compound Assignment - Constraints

560	RULE001_1	[C] Left operand of '<<=', '>>=', '&=', '|=', '^=' or '%=' must have integral type.\\
REFERENCE - ISO:C90-6.3.16.2 Compound Assignment - Constraints

561	RULE001_1	[C] Right operand of assignment is not of compatible 'struct'/'union' type.\\
REFERENCE - ISO:C90-6.3.16.1 Simple Assignment - Constraints

562	RULE001_1	[C] Right operand of assignment points to a more heavily qualified type.\\
REFERENCE - ISO:C90-6.3.16.1 Simple Assignment - Constraints

563	RULE001_1	[C] Right operand of assignment is not of compatible pointer type.\\
REFERENCE - ISO:C90-6.3.16.1 Simple Assignment - Constraints

564	RULE001_1	[C] Left operand of assignment must be an lvalue (it must designate an object).\\
REFERENCE - ISO:C90-6.3.16 Assignment Operators - Constraints

565	RULE001_1	[C] Left operand of '+=' or '-=' must be of arithmetic or pointer to object type.\\
REFERENCE - ISO:C90-6.3.16.2 Compound Assignment - Constraints

570	RULE010_1	This switch case label of 'essential type' '%1s', is not consistent with a controlling expression of essential type '%2s'.

571	Maj_Switch	This switch case label of 'essential type' '%1s' is not consistent with a controlling expression which has an essential type of higher rank (%2s).

572	RULE010_1	This switch case label of 'essential type' '%1s' is not consistent with a controlling expression which has an essential type of lower rank (%2s).

580	RULE001_1	[C] Constant is too large to be representable.\\
REFERENCE - ISO:C90-6.4 Constant Expressions - Constraints

581    RULE003_1             [I] Floating-point constant may be too small to be representable.\\
MISRA-C:2004 Rule 3.1; REFERENCE - ISO:C90-5.2.4.2.2 Characteristics of Floating Types

* rule is obsolete: 585    RULE021_1             [U] Apparent division by zero.\\
* MISRA-C:2004 Rule 21.1; REFERENCE - ISO:C90-6.3.5 Multiplicative Operators - Semantics

* rule is obsolete: 586    RULE001_2             [U] Division by constant zero.\\
* MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.3.5 Multiplicative Operators - Semantics

* rule is obsolete: 587    RULE021_1             [U] Definite division by zero.\\
* MISRA-C:2004 Rule 21.1; REFERENCE - ISO:C90-6.3.5 Multiplicative Operators - Semantics

0588	RULE001_1	[C] Width of bit-field must be an integral constant expression.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

0589	RULE001_1	[C] Enumeration constant must be an integral constant expression.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers - Constraints

0590	RULE001_1	[C] Array bound must be an integral constant expression.\\
REFERENCE - ISO:C90-6.5.4.2 Array Declarators - Constraints

0591	RULE001_1	[C] A 'case' label must be an integral constant expression.\\
REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Constraints

594    RULE014_1             Negative 'case' label expression is incompatible with unsigned controlling expression in 'switch' statement.\\
MISRA-C:2004 Rule 14.1

596	Maj_Switch	Value of 'case' label expression is too large for type of controlling expression in 'switch' statement.

597	Min_Switch	Type of 'case' label expression is not consistent with type of controlling expression in 'switch' statement.

601    RULE001_1             [E] Function 'main()' is not of type 'int (void)' or 'int (int, char *[])'.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.1.2.2 Hosted environment

602    RULE020_2             [U] The identifier '%s' is reserved for use by the library.\\
MISRA-C:2004 Rule 20.2; REFERENCE - ISO:C90-7.1.3 Reserved Identifiers

604    RULE001_1             [C99] Declaration appears after statements in a compound statement.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.6.2 Compound Statement, or Block - Syntax

605	RULE001_1	[C] A declaration must declare a tag or an identifier.\\
REFERENCE - ISO:C90-6.5 Declarations - Constraints

606    Min_Decl             Object '%s' is declared using typedefs which are different to those in a previous declaration.\\
MISRA-C:2004 Rule 8.3; REFERENCE - ISO:C90-6.1.2.6 Compatible Type and Composite Type

609    RULE001_1             [L] More than 12 pointer, array or function declarators modifying a declaration - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

611    RULE001_1             [L] Nesting of 'struct' or 'union' types exceeds 15 - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

612    RULE001_1             [L] Size of object '%s' exceeds 32767 bytes - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

614    RULE001_1             [L] More than 127 block scope identifiers defined within a block - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

616	RULE001_1	[C] Illegal combination of type specifiers or storage class specifiers.\\
REFERENCE - ISO:C90-6.5.1 Storage-Class Specifiers - Constraints, ISO:C90-6.5.2 Type Specifiers - Constraints

617    RULE001_1             [C99] 'const' qualifier has been duplicated.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.5.3 Type Qualifiers, ISO:C99-6.7.3 Type Qualifiers

618    RULE001_1             [C99] 'volatile' qualifier has been duplicated.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.5.3 Type Qualifiers, ISO:C99-6.7.3 Type Qualifiers

619	RULE001_1	[C] The identifier '%s' has already been defined in the current scope within the ordinary identifier namespace.\\
REFERENCE - ISO:C90-6.5 Declarations - Constraints, ISO:C90-6.7 External Definitions - Semantics

620	RULE001_1	[C] Cannot initialize '%s' because it has unknown size.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Constraints

621	RULE001_1	[C] The struct/union '%s' cannot be initialized because it has unknown size.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Constraints

622	RULE001_1	[C] The identifier '%s' has been declared both with and without linkage in the same scope.\\
REFERENCE - ISO:C90-6.5 Declarations - Constraints

623    RULE018_1             [U] '%s' has incomplete type and no linkage - this is undefined.\\
MISRA-C:2004 Rule 18.1; REFERENCE - ISO:C90-6.5 Declarations - Semantics

624    RULE008_3             Function '%s' is declared using typedefs which are different to those in a previous declaration.\\
MISRA-C:2004 Rule 8.3; REFERENCE - ISO:C90-6.1.2.6 Compatible Type and Composite Type

625    RULE001_2             [U] '%s' has been declared with both internal and external linkage - the behaviour is undefined.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.1.2.2 Linkages of Identifiers

626    RULE008_4             [U] '%s' has different type to previous declaration (which is no longer in scope).\\
MISRA-C:2004 Rule 8.4; REFERENCE - ISO:C90-6.1.2.6 Compatible Type and Composite Type

627    RULE008_4             [C] '%s' has different type to previous declaration in the same scope.\\
MISRA-C:2004 Rule 8.4; REFERENCE - ISO:C90-6.5 Declarations - Constraints

628    RULE008_4             [C] '%s' has different type to previous declaration at wider scope.\\
MISRA-C:2004 Rule 8.4; REFERENCE - ISO:C90-6.5 Declarations - Constraints

629	RULE001_1	[C] More than one definition of '%s' (with internal linkage).\\
REFERENCE - ISO:C90-6.7 External Definitions - Constraints

630    RULE008_9             [U] More than one definition of '%s' (with external linkage).\\
MISRA-C:2004 Rule 8.9; REFERENCE - ISO:C90-6.7 External Definitions - Semantics

631	RULE001_1	[C] More than one declaration of '%s' (with no linkage).\\
REFERENCE - ISO:C90-6.5 Declarations - Constraints

632    RULE001_2             [U] Tentative definition of '%s' with internal linkage cannot have unknown size.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.7.2 External Object Definitions

633    RULE001_1             [E] Empty structures and unions are a language extension.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Syntax

634    RULE006_4             [I] Bit-field is not declared explicitly as unsigned or signed.\\
MISRA-C:2004 Rule 6.4; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

635    RULE006_4             [E] Only bit-fields of type int, signed int or unsigned int are supported in ISO-C.\\
MISRA-C:2004 Rule 6.4; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

636    RULE018_1             [U] There are no named members in this 'struct' or 'union'.\\
MISRA-C:2004 Rule 18.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

637	Syntax	[S] Storage class specifier is illegal on 'struct' or 'union' member.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Syntax

638	RULE001_1	[C] Duplicate member name '%s' in 'struct' or 'union'.\\
REFERENCE - ISO:C90-6.5 Declarations - Constraints

639    RULE001_1             [L] Number of members in 'struct' or 'union' exceeds 127 - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

640	RULE001_1	[C] '%s' in 'struct' or 'union' type may not have 'void' type.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

641	RULE001_1	[C] '%s' in 'struct' or 'union' type may not have function type.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

642	RULE001_1	[C] '%s' in 'struct' or 'union' type may not be an array of unknown size.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

643	RULE001_1	[C] '%s' in 'struct' or 'union' type may not be a 'struct' or 'union' with unknown content.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

644	RULE001_1	[C] Width of bit-field must be no bigger than the width of an 'int'.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

645	RULE001_1	[C] A zero width bit-field cannot be given a name.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

646	RULE001_1	[C] Enumeration constants must have values representable as 'int's.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers - Constraints

647    RULE001_1             [L] Number of enumeration constants exceeds 127 - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

648	Syntax	[S] Unexpected '{' encountered at file scope.

649	RULE001_1	[C] K&R style declaration of parameters is not legal after a function header that includes a parameter list.\\
REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Constraints, ISO:C90-6.7.1 Function Definitions - Constraints

650	RULE001_1	[C] Illegal storage class specifier on named function parameter.\\
REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Constraints, ISO:C90-6.7.1 Function Definitions - Constraints

651	RULE001_1	[C] Missing type specifiers in function declaration.\\
REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Constraints

652	Min_Func	Identifiers have been provided for some but not all of the parameters in a function prototype.\\
REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Semantics

653	RULE001_1	[C] Duplicate definition of 'struct', 'union' or 'enum' tag '%s'.\\
REFERENCE - ISO:C90-6.5 Declarations - Constraints, ISO:C90-6.5.2.3 Tags

654    RULE001_2             [U] Using 'const' or 'volatile' in a function return type is undefined.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.5.3 Type Qualifiers - Semantics

655	RULE001_1	[C] Illegal storage class specifier on unnamed function parameter.\\
REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Constraints, ISO:C90-6.7.1 Function Definitions - Constraints

656	RULE001_1	[C] Function return type cannot be function or array type, or an incomplete struct/union (for function definition).\\
REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Constraints, ISO:C90-6.7.1 Function Definitions - Constraints

657	RULE001_1	[C] Unnamed parameter specified in function definition.\\
REFERENCE - ISO:C90-6.7.1 Function Definitions - Constraints

658    RULE001_2             [U] Parameter cannot have 'void' type.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Semantics

659	RULE001_1	[C] The identifier '%s' was not given in the parameter list.\\
REFERENCE - ISO:C90-6.7.1 Function Definitions - Constraints

660    RULE001_1             [E] Defining an unnamed member in a struct or union. This is a language extension.\\
MISRA-C:2004 Rule 1.1

661    RULE001_2             [U] '%s()' may not have a storage class specifier of 'static' when declared at block scope.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.5.1 Storage-Class Specifiers - Semantics

662    RULE001_1             [E] Accessing a member of an unnamed struct or union member in this way is a language extension.\\
MISRA-C:2004 Rule 1.1

664	RULE001_1	[C] Parameter specified with type 'void'.\\
REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Semantics, ISO:C90-6.5 Declarations - Constraints

665	RULE001_1	[C] Two parameters have been declared with the same name '%s'.\\
REFERENCE - ISO:C90-6.5 Declarations - Constraints

666	Syntax	[S] Only type qualifiers 'const' or 'volatile' are legal here in a pointer declaration.\\
REFERENCE - ISO:C90-6.5.4 Declarators - Syntax

667    RULE001_2             [U] '%s' is declared as a typedef and may not be redeclared as an object at an inner scope without an explicit type specifier.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.5.6 Type Definitions - Semantics

668    RULE001_2             [U] '%s' is declared as a typedef and may not be redeclared as a member of a 'struct' or 'union' without an explicit type specifier.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.5.6 Type Definitions - Semantics

670	Syntax	[S] Function defined with invalid function header syntax.\\
REFERENCE - ISO:C90-6.5.4 Declarators - Syntax

671	RULE001_1	[C] Initializer for object of arithmetic type is not of arithmetic type.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

672    RULE001_2             [U] The initializer for a 'struct', 'union' or array is not enclosed in braces.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

673	RULE001_1	[C] Initializer points to a more heavily qualified type.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

674	RULE001_1	[C] Initializer for pointer is of incompatible type.\\
REFERENCE - ISO:C90-6.5.7 Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

675	RULE001_1	[C] Initializer is not of compatible 'struct'/'union' type.\\
REFERENCE - ISO:C90-6.5.7 Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

676    RULE001_2             [u] Array element is of function type. Arrays cannot be constructed from function types.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.1.2.5 Types

677	RULE001_1	[C] Array size is negative, or unrepresentable.\\
REFERENCE - ISO:C90-6.5.4.2 Array Declarators - Constraints

678    RULE001_2             [u] Array element is array of unknown size. Arrays cannot be constructed from incomplete types.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.1.2.5 Types

* message removed in 8.1.1:679    RULE009_2             Redundant braces found in initializer.\\
* MISRA-C:2004 Rule 9.2; REFERENCE - ISO:C90-6.5.7 Initialization - Syntax, Semantics

680    RULE001_2             [u] Array element is 'void' or an incomplete 'struct' or 'union'. Arrays cannot be constructed from incomplete types.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.1.2.5 Types

682	RULE001_1	[C] Initializer for object of a character type is a string literal.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

683	RULE001_1	[C] Initializer for object of a character type is a wide string literal.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

684	RULE001_1	[C] Too many initializers.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Constraints

685	RULE001_1	[C] Initializer for any object with static storage duration must be a constant expression.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Constraints, ISO:C90-6.4 Constant Expressions - Constraints.

686    RULE009_2             Array has fewer initializers than its declared size. Default initialization is applied to the remainder of the array elements.\\
MISRA-C:2004 Rule 9.2; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

687	Maj_Decl	Array has been initialized using concatenated strings and has fewer initializers than its declared size.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

688	Maj_Decl	Array size determined by number of initializers which include concatenated string literals.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90 5.1.1.2 Translation Phase 6

* rule is obsolete:689    RULE014_1             [u] 'Switch' statement will bypass the initialization of this local variable.\\
* MISRA-C:2004 Rule 14.1; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

690	RULE001_1	[C] String literal contains too many characters to initialize object.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Constraints, Semantics

693    RULE009_2             Struct initializer is missing the optional {.\\
MISRA-C:2004 Rule 9.2; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

694    RULE009_2             Array initializer is missing the optional {.\\
MISRA-C:2004 Rule 9.2; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

695	Maj_Pointers	Type given in sizeof is not compatible with the pointed to type used to cast malloc.

696	Maj_Pointers	The size of the allocated memory block is smaller than the size of the object type addressed by the pointer cast.

697	Maj_Pointers	The size of the allocated memory block is not an integral multiple of the size of the object type addressed by the pointer cast.

698	RULE001_1	[C] String literal used to initialize an object of incompatible type.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

699	RULE001_1	[C] String literal used to initialize a pointer of incompatible type.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

702	Min_Operations	Result of sizeof operator is not explicitly cast.

703	Maj_Decl	Structure has fewer initializers than its declared size. Default initialization is applied to the remainder of the members.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

706    RULE001_2             [U] Label '%s' is not unique within this function.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.1.2.1 Scopes of Identifiers

708	RULE001_1	[C] No definition found for the label '%s' in this function.\\
REFERENCE - ISO:C90-6.6.6.1 The goto Statement - Constraints

709	RULE001_1	[C] Initialization of locally declared 'extern %s' is illegal.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Constraints

715    RULE001_1             [L] Nesting of control structures (statements) exceeds 15 - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

722	Min_Enum	Enum constant not explicitly initialized, but a previous constant has been.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers - Semantics

723    RULE009_3             Initialize none, first only, or all entries in this enumerator list.\\
MISRA-C:2004 Rule 9.3; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers - Semantics

735    RULE015_4             Using relational or logical operators in a 'switch' expression is usually a programming error.\\
MISRA-C:2004 Rule 15.4

736	RULE001_1	[C] 'case' label does not have unique value within this 'switch' statement.\\
REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Constraints

737	RULE001_1 [C] More than one 'default' label found in 'switch' statement.\\
REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Constraints

738	RULE001_1	[C] Controlling expression in a 'switch' statement must have integral type.\\
REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Constraints

739    RULE001_1             [L] Number of 'case' labels exceeds 257 - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

* obsolete message: 744    RULE016_8             [U] '%s()' has been declared with a non void return type but ends with an implicit 'return ;' statement.\\
* MISRA-C:2004 Rule 16.8; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics

745    RULE016_8             [U] 'return;' found in '%s()', which has been defined with a non-'void' return type.\\
MISRA-C:2004 Rule 16.8; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics

746	RULE001_1	[C] 'return exp;' found in '%s()' whose return type is 'void'.\\
REFERENCE - ISO:C90-6.6.6.4 The return Statement - Constraints

747	RULE001_1	[C] 'return exp;' found in '%s()' whose return type is qualified 'void'.\\
REFERENCE - ISO:C90-6.6.6.4 The return Statement - Constraints

750    RULE018_4             A union type specifier has been defined.\\
MISRA-C:2004 Rule 18.4

752	Min_Pointers	String literal passed as argument to function whose parameter is not a 'pointer to const'.\\
REFERENCE - ISO:C90-6.1.4 String Literals - Semantics

753	Min_Pointers	String literal assigned to pointer which is not a 'pointer to const'.\\
REFERENCE - ISO:C90-6.1.4 String Literals - Semantics

755	RULE001_1	[C] 'return' expression is not of arithmetic type.\\
REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

756	RULE001_1	[C] 'return' expression is not of compatible 'struct'/'union' type.\\
REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

757	RULE001_1	[C] 'return' expression points to a more heavily qualified type.\\
REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

758	RULE001_1	[C] 'return' expression is not of compatible pointer type.\\
REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

759    RULE018_4             An object of union type has been defined.\\
MISRA-C:2004 Rule 18.4

766	RULE001_1	[C] 'continue' statement found outside an iteration statement.\\
REFERENCE - ISO:C90-6.6.6.2 The continue Statement - Constraints

767	RULE001_1	[C] 'break' statement found outside a 'switch' or iteration statement.\\
REFERENCE - ISO:C90-6.6.6.3 The break Statement - Constraints

768	RULE001_1	[C] 'case' or 'default' found outside a 'switch' statement.\\
REFERENCE - ISO:C90-6.6.1 Labeled Statements - Constraints

769	Min_Ctrl	A 'break' statement has been used to terminate an iteration statement.

770    RULE014_5             A 'continue' statement has been used.\\
MISRA-C:2004 Rule 14.5

771    RULE014_6             More than one 'break' statement has been used to terminate this iteration statement.\\
MISRA-C:2004 Rule 14.6

774	RULE001_1	[C] 'auto' may not be specified on global declaration of '%s'.\\
REFERENCE - ISO:C90-6.7 External Definitions - Constraints

775	RULE001_1	[C] 'register' may not be specified on global declaration of '%s'.\\
REFERENCE - ISO:C90-6.7 External Definitions - Constraints

776	ISO_C90_Limits	[L] External identifier matches other external identifier(s) (e.g. '%s') in first 6 characters - program does not conform strictly to ISO:C90.\\
REFERENCE - ISO:C90-6.1.2 Identifiers - Implementation Limits

777    RULE005_1             [U] External identifier does not differ from other identifier(s) (e.g. '%s') within the specified number of significant characters.\\
MISRA-C:2004 Rule 5.1; REFERENCE - ISO:C90-6.1.2 Identifiers - Implementation Limits

778	ISO_C90_Limits	[L] Identifier matches other identifier(s) (e.g. '%s') in first 31 characters - program does not conform strictly to ISO:C90.\\
REFERENCE - ISO:C90-6.1.2 Identifiers - Implementation Limits

779    RULE005_1             [U] Identifier does not differ from other identifier(s) (e.g. '%s') within the specified number of significant characters.\\
MISRA-C:2004 Rule 5.1; REFERENCE - ISO:C90-6.1.2 Identifiers - Implementation Limits

780    RULE005_6             Another identifier '%s' is already in scope in a different namespace.\\
MISRA-C:2004 Rule 5.6; REFERENCE - ISO:C90-6.1.2.3 Name Spaces of Identifiers

781    RULE005_6             '%s' is being used as a structure/union member as well as being a label, tag or ordinary identifier.\\
MISRA-C:2004 Rule 5.6; REFERENCE - ISO:C90-6.1.2.3 Name Spaces of Identifiers

782	Min_Ident	This identifier, '%s', will still be in scope when the same identifier is declared later in a different namespace.\\
REFERENCE - ISO:C90-6.1.2.3 Name Spaces of Identifiers

783	Min_Ident	A subsequent declaration of '%s' means that it is being used both as a structure/union member and also as a label, tag or ordinary identifier.\\
REFERENCE - ISO:C90-6.1.2.3 Name Spaces of Identifiers

790	Min_Decl	This translation unit makes use of floating types.

801	RULE001_1	[C] The '##' operator may not be the first token in a macro replacement list.\\
REFERENCE - ISO:C90-6.8.3.3 The ## Operator - Constraints

802	RULE001_1	[C] The '##' operator may not be the last token in a macro replacement list.\\
REFERENCE - ISO:C90-6.8.3.3 The ## Operator - Constraints

803	RULE001_1	[C] The '#' operator may only appear before a macro parameter.\\
REFERENCE - ISO:C90-6.8.3.2 The # Operator - Constraints

804	RULE001_1	[C] Macro parameter '%s' is not unique.\\
REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

805	Syntax	[S] Invalid identifier encountered in macro parameter list.\\
REFERENCE - ISO:C90-6.8.3 Macro Replacement - Semantics

806	Syntax	[S] Comma missing in macro parameter list.\\
REFERENCE - ISO:C90-6.8.3 Macro Replacement - Semantics

807	Syntax	[S] Identifier missing in macro parameter list.\\
REFERENCE - ISO:C90-6.8.3 Macro Replacement - Semantics

808	Config	[Q] '#include "%s"' causes itself to be included recursively. QA C terminates execution after 8 occurrences.

809    RULE019_3             [U] The '#include' preprocessing directive has not been followed by <h-char-sequence> or "s-char-sequence".\\
MISRA-C:2004 Rule 19.3; REFERENCE - ISO:C90-6.8.2 Source File Inclusion - Semantics

810    RULE001_1             [L] '#include "%s"' causes nesting to exceed 8 levels - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

811	RULE001_1	[C] The glue operator '##' may only appear in a '#define' preprocessing directive.\\
REFERENCE - ISO:C90-6.1.5 Operators - Constraints

812	RULE001_1	[C] Header name token '<text>' found outside '#include' preprocessing directive.\\
REFERENCE - ISO:C90-6.1.7 Header Names - Constraints

813    RULE019_2             [U] Using any of the characters ' " or /* in '#include <%s>' gives undefined behaviour.\\
MISRA-C:2004 Rule 19.2; REFERENCE - ISO:C90-6.1.7 Header Names

814    RULE019_2             [U] Using the characters ' or /* in '#include "%s"' gives undefined behaviour.\\
MISRA-C:2004 Rule 19.2; REFERENCE - ISO:C90-6.1.7 Header Names

815	ISO_C90_Limits	[L] #include <...>  file name does not conform strictly to ISO:C90.\\
REFERENCE - ISO:C90-6.8.2 Source File Inclusion - Semantics

816	ISO_C90_Limits	[L] #include "..."  file name does not conform strictly to ISO:C90.\\
REFERENCE - ISO:C90-6.8.2 Source File Inclusion - Semantics

817	Syntax	[S] Closing quote or bracket '>' missing from include filename.\\
REFERENCE - ISO:C90-6.1.7 Header Names - Syntax

818	Config	[Q] Cannot find '%s' - Perhaps the appropriate search path was not given ?\\
REFERENCE - ISO:C90-6.8.2 Source File Inclusion - Constraints

819	Config	[Q] Cannot open '%s' - Perhaps the appropriate search path was not given ?\\
REFERENCE - ISO:C90-6.8.2 Source File Inclusion - Constraints

820	Syntax	[S] '#include' requires a header name.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

821	RULE001_1	[C] '#include %s' does not identify a header or source file that can be processed.\\
REFERENCE - ISO:C90-6.8.2 Source File Inclusion - Constraints

822	Config	[Q] Cannot find forceinclude file '%s'.

823	Syntax	[S] Unexpected '#else' or '#elif' directive follows '#else'.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives

824	Syntax	[S] Unexpected '#else' or '#elif' directive found outside a '#if' block.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives

825	Syntax	[S] Unexpected '#endif' found outside a '#if' block.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives

826	Syntax	[S] Unexpected ':' found without a preceding '?' in a '#if' or '#elif' expression.

827	Syntax	[S] Missing ':' after '?' in a '#if' or '#elif' expression.

828    RULE001_1             [L] More than 8 levels of nested conditional inclusion - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

829	Syntax	[S] Could not find '#endif' preprocessing directive to close '#if...'.\\

830    RULE001_1             [E] Unrecognized text encountered after a preprocessing directive.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

831    RULE019_2             [E] Use of '\\' in this '#include' line is a PC extension - this usage is non-portable.\\
MISRA-C:2004 Rule 19.2; REFERENCE - ISO:C90-6.1.7 Header Names - Semantics

832	Min_Prepro	Macro substitution in #include preprocessing directive.

833	Syntax	[S] '#ifdef' or '#ifndef' must be followed by an identifier.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

834	RULE001_1	[C] Function-like macro '%s()' is being redefined as an object-like macro.\\
REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

835	RULE001_1	[C] Macro '%s' is being redefined with different parameter names.\\
REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

836    RULE020_1             [U] Definition of macro named 'defined'.\\
MISRA-C:2004 Rule 20.1; REFERENCE - ISO:C90-6.8.8 Predefined Macro Names

837    RULE001_2             [U] Use of '#undef' to remove the operator 'defined'.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.8.8 Predefined Macro Names

838	Min_Prepro	File '%1s' has already been included directly from within file '%2s'.

839	Min_Prepro	File '%1s' has already been included indirectly from within file '%2s'.

841    RULE019_6             Using '#undef'.\\
MISRA-C:2004 Rule 19.6; REFERENCE - ISO:C90-6.8.3.5 Scope of Macro Definitions

842    RULE019_5             Using #define or #undef inside a function.\\
MISRA-C:2004 Rule 19.5; REFERENCE - ISO:C90-6.8.3.5 Scope of Macro Definitions

843	Min_Prepro	/ character used in an include file name.

844	RULE001_1	[C] Macro '%s' is being redefined with a different replacement list.\\
REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

845	RULE001_1	[C] Object-like macro '%s' is being redefined as a function-like macro.\\
REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

846	Syntax	[S] '#define' must be followed by an identifier.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

847	Syntax	[S] '#undef' must be followed by an identifier.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

848    RULE020_1             [U] Attempting to #undef '%s', which is a predefined macro name.\\
MISRA-C:2004 Rule 20.1; REFERENCE - ISO:C90-6.8.8 Predefined Macro Names

849	Syntax	[S] Preprocessing directive appears in the middle of a line.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives - Description

850    RULE019_8             [C99] Macro argument is empty.\\
MISRA-C:2004 Rule 19.8; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Semantics; ISO:C99 6.10.3

851	RULE001_1	[C] More arguments in macro call than specified in definition.\\
REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

852	RULE001_1	[C] Unable to find the ')' that marks the end of the macro call.\\
REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

853    RULE019_9             [U] Macro arguments contain a sequence of tokens that has the form of a preprocessing directive.\\
MISRA-C:2004 Rule 19.9; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Semantics

854    RULE020_1             [U] Attempting to #define '%s', which is a predefined macro name.\\
MISRA-C:2004 Rule 20.1; REFERENCE - ISO:C90-6.8.8 Predefined Macro Names

855	Maj_Prepro	Preprocessing results in a sequence of tokens that has the form of a preprocessing directive.\\
REFERENCE - ISO:C90-6.8.3.4 Rescanning and Further Replacement

856    RULE019_8             [C] Fewer arguments in macro call than specified in definition.\\
MISRA-C:2004 Rule 19.8; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

857    RULE001_1             [L] Number of macro definitions exceeds 1024 - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

858    RULE001_1             [L] Number of macro parameters exceeds 31 - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

859    RULE001_1             [L] Number of arguments in macro call exceeds 31 - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

861	Min_Redun	This #include <%s> directive is redundant.

862	Min_Redun	This #include "%s" directive is redundant.

863	Syntax	[S] '#line' encountered without a following line number.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

864    RULE001_2             [U] '#line' directive specifies line number which is not in the range 1 to 32767.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.8.4 Line Control - Semantics

865    RULE001_2             [U] '#line' directive is badly formed.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.8.4 Line Control - Semantics

866	RULE001_2	[C] The string literal in a '#line' directive cannot be a 'wide string literal'.\\
REFERENCE - ISO:C90-6.8.4 Line Control - Constraints

867    RULE001_2             [U] '#line' has not been followed by a line number.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.8.4 Line Control - Semantics

868	Maj_Prepro	An absolute path has been specified in a #include statement.

869	Config	[Q] '#error' directive: %s Analysis terminated due to '#error' directive.

872    RULE001_2             [U] Result of '##' operator is not a legal preprocessing token.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.8.3.3 The ## Operator - Semantics

873	RULE001_1	[C] Preprocessing token cannot be converted to an actual token.\\
REFERENCE - ISO:C90-6.1 Lexical Elements - Constraints

874    RULE001_2             [U] Character string literal and wide character string literal are adjacent.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.1.4 String Literals - Semantics

875    RULE001_1             [L] String literal exceeds 509 characters - program does not conform strictly to ISO:C90.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1 Translation limits

877	RULE001_1	[C] '#if' and '#elif' expressions may contain only integral constants.\\
REFERENCE - ISO:C90-6.8.1 Conditional Inclusion - Constraints

878    RULE003_1             Using wide character or string literals.\\
MISRA-C:2004 Rule 3.1

879	Syntax	[S] Illegal operator in '#if' or '#elif' expression.

880    RULE19_12             Using # and ## operators in the same macro definition.\\
MISRA-C:2004 Rule 19.12; REFERENCE - ISO:C90-6.8.3.2 The # Operator - Semantics

881    RULE19_12M             Using multiple ## operators in the same macro definition.\\
MISRA-C:2004 Rule 19.12; REFERENCE - ISO:C90-6.8.3.3 The ## Operator - Semantics

882	Min_Prepro	The forceinclude file '%s' is redundant in this translation unit.

883    RULE19_15             Include file code is not protected against repeated inclusion\\
MISRA-C:2004 Rule 19.15

884    RULE19_12             Using multiple # operators in the same macro definition.\\
MISRA-C:2004 Rule 19.12; REFERENCE - ISO:C90-6.8.3.2 The # Operator - Semantics

885    RULE19_14             [U] The token 'defined' is generated in the expansion of this macro.\\
MISRA-C:2004 Rule 19.14; REFERENCE - ISO:C90-6.8.1 Conditional Inclusion - Semantics

886	Syntax	[S] Missing or invalid expression in '#if' or '#elif' directive.

887    RULE19_14             [U] Use of 'defined' must match either 'defined(identifier)' or 'defined identifier'.\\
MISRA-C:2004 Rule 19.14; REFERENCE - ISO:C90-6.8.1 Conditional Inclusion - Semantics

888    RULE19_14             [U] 'defined' requires an identifier as an argument.\\
MISRA-C:2004 Rule 19.14; REFERENCE - ISO:C90-6.8.1 Conditional Inclusion - Semantics

889	Min_Prepro	#undef refers to a macro that has previously been #undef'd.

890	Min_Prepro	#ifdef refers to a macro that has been #undef'd in a previous #if block.

891	Min_Prepro	#ifdef refers to a macro that has been #undef'd previously.

896	Syntax	[S] Missing operand in '#if' or '#elif' expression.

897	Syntax	[S] Missing operator in '#if' or '#elif' expression.

898	Syntax	[S] Unexpected ')' or ':' in '#if' or '#elif' expression.

899    RULE001_1             [E] Unrecognized preprocessing directive has been ignored - assumed to be a language extension.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.8 Preprocessing Directives, ISO:C90-6.8.3.2 The # Operator

901	Parser_Rec	Source skipped to this point after error in top level declaration.

902	Parser_Rec	Source skipped to this point after error in parameter declaration.

903	Parser_Rec	Source skipped to this point after error in member declaration.

904	Syntax	[S] Invalid designator.\\
REFERENCE - ISO:C99-6.7.8 Initialization - Syntax

907	Syntax	[S] Unexpected token.

911	Parser_Rec	Inserted '%s' token in an attempt to continue parsing.

913	Parser_Rec	Source skipped to this point after error in 'case' label.

914	RULE001_2	[U] Source file does not end with a newline character.\\
REFERENCE - ISO:C90-5.1.1.2 Translation Phases

915	RULE001_2	[U] Source file ends with a backslash character followed by a newline.\\
REFERENCE - ISO:C90-5.1.1.2 Translation Phases

917	Syntax	[S] Unable to recover from syntax errors in this source file.

918	Config	[Q] Source too complex. Please report this problem to Programming Research Technical Support.

920	Parser_Rec	Source skipped to this point after error in expression.

925	Syntax	[S] Unexpected end of file.

926	Syntax	[S] Expected:%s.

927	Syntax	[S] Unexpected ')'.

928	Syntax	[S] Missing comma ',' between enumerators.\\
REFERENCE - ISO:C90-6.5.2.2 Syntax

930    RULE001_1             [C99] Trailing comma at the end of an enumerator-list.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.5.2.2 Syntax

940	RULE001_1	[C] Illegal usage of a variably modified type.\\
REFERENCE - ISO:C99-6.7.5.2 Array declarators - Constraints

941	RULE001_1	[C] A variable length array may not be initialized.\\
REFERENCE - ISO:C99-6.7.8 Initialization - Constraints

942    RULE001_2             [U] A * can only be used to specify array size within function prototype scope.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C99-6.7.5.3 Function Declarators - Semantics

943	RULE001_1	[C] Jump to label '%s' is a jump into the scope of an identifier with variably modified type.\\
REFERENCE - ISO:C99-6.8.6.1 The goto statement - Constraints

944	RULE001_1	[C] The label '%s' is inside the scope of an identifier with variably modified type.\\
REFERENCE - ISO:C99-6.8.6.1 The goto statement - Constraints

945    RULE001_1             [C99] WARNING. Operand of sizeof is an expression of variable length array type.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C99-6.5.3.4 The sizeof operator - Semantics

970	Config	[Q] Unable to create preprocessed file.

1001   RULE001_1             [E] '#include %s' is a VMS extension.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.8.2 Form of '#include' directives

1002   RULE001_1             [E] '%s' is not a legal identifier in ISO C.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.1.2 Identifiers

1003   RULE001_1             [E] '#%s' is a language extension for in-line assembler. All statements located between #asm and #endasm will be ignored.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

1004	Syntax	[S] '#endasm' found without matching '#asm' preprocessing directive.

1005	Syntax	[S] End-of-file encountered when expecting '#%s' preprocessing directive.

1006   RULE001_1             [E] This in-line assembler construct is a language extension. The code has been ignored.\\
MISRA-C:2004 Rule 1.1

1008   RULE001_1             [E] '#%s' is not a legal ISO C preprocessing directive.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

1009	Syntax	[S] Unrecognizable expression in '#if' preprocessing directive.

1010	Syntax	[S] '#%s' is not a valid form of '#if' syntax .\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

1011   RULE002_2             [C99] Use of '//' comment.\\
MISRA-C:2004 Rule 2.2; REFERENCE - ISO:C99-6.4.9 Comments

1012   RULE001_1             [E] Use of a C++ reference type ('type &') will be treated as a language extension.\\
MISRA-C:2004 Rule 1.1

1013	Syntax	[S] Use of a C++ reference type ('type &').

1014   RULE001_1             [E] Non-standard type specifier - this will be treated as a language extension.\\
MISRA-C:2004 Rule 1.1

1015   RULE001_1             [E] '%s' is not a legal keyword in ISO C - this will be treated as a language extension.\\
MISRA-C:2004 Rule 1.1

1018   RULE001_1             [C99] Use of LL suffix.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C99-6.4.4.1 Integer Constants - Syntax

1019   RULE001_1             [E] '@ address' is not supported in ISO C - this will be treated as a language extension.\\
MISRA-C:2004 Rule 1.1

1020   RULE001_1             [E] '__typeof__' is not supported in ISO C, and is treated as a language extension.\\
MISRA-C:2004 Rule 1.1

1021   RULE001_1             [E] A statement expression is not supported in ISO C, and is treated as a language extension.\\
MISRA-C:2004 Rule 1.1

1022   RULE001_1             [E] '__alignof__' is not supported in ISO C, and is treated as a language extension.\\
MISRA-C:2004 Rule 1.1

1023	RULE001_1	[C] Using '__alignof__' on function types is illegal.

1024	RULE001_1	[C] Using '__alignof__' on incomplete types is illegal.

1025	RULE001_1	[C] Using '__alignof__' on bit-fields is illegal.

1026   RULE001_1             [E] The indicated @word construct has been ignored.\\
MISRA-C:2004 Rule 1.1

1027   RULE001_1             [C99] Use of type 'long long'.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C99-6.2.5 Types

1028   RULE001_1             [E] Use of the sizeof operator in a preprocessing directive is a language extension.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.8.1 Conditional Inclusion - Semantics, ISO:C90-6.1.1 Keywords

1029   RULE001_1             [E] Whitespace encountered between backslash and new-line has been ignored.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.1.1.2 Translation Phases

1030   RULE001_1             [C99] Macro defined with variable argument list.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C99-6.10 Preprocessing directives - Syntax

1031   RULE001_1             [C99] Initializer for 'struct', 'union' or array type is not a constant expression.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Constraints

1033	RULE001_1	[C] The identifier __VA_ARGS__ may only be used in the replacement list of a variadic macro.\\
REFERENCE - ISO:C99-6.10.3 Macro Replacement - Constraints

1034   RULE001_1             [E] Macro defined with named variable argument list. This is a language extension.\\
MISRA-C:2004 Rule 1.1

1035   RULE001_1             [E] No macro arguments supplied for variable argument list. This is a language extension.\\
MISRA-C:2004 Rule 1.1

1036   RULE001_1             [E] Comma before ## ignored in expansion of variadic macro. This is a language extension.\\
MISRA-C:2004 Rule 1.1

1037   RULE001_1             [E] Arrays of length zero are a language extension.\\
MISRA-C:2004 Rule 1.1

1038   RULE001_1             [E] The sequence ", ##__VA_ARGS__" is a language extension.\\
MISRA-C:2004 Rule 1.1

1041   RULE001_1             [E] Empty aggregate initializers are a language extension.\\
MISRA-C:2004 Rule 1.1

1042   RULE001_1             [E] Using I64 or UI64 as an integer constant suffix. This is a language extension.\\
MISRA-C:2004 Rule 1.1

1043   RULE001_1             [E] Defining an anonymous union object. This is a language extension.\\
MISRA-C:2004 Rule 1.1

1044   RULE001_1             [E] Defining an anonymous struct object. This is a language extension.\\
MISRA-C:2004 Rule 1.1

1045	RULE001_1	[E] Use of the #include_next preprocessing directive is a language extension.

1046	RULE001_1	[E] Function is being declared with default argument syntax. This is a language extension.

1047	RULE001_1	[C] Function is being declared with default argument syntax after a previous call to the function. This is not allowed.

1048	RULE001_1	[C] Default argument values are missing for some parameters in this function declaration. This is not allowed.

1051   RULE001_1             [C99] A variable length array has been declared.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C99-6.7.5.2 Array declarators

1052   RULE001_1             [C99] A variable length array of unspecified size has been declared.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C99-6.7.5.2 Array declarators

1053   RULE001_1             [C99] Designators have been used in this initialization list.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C99-6.7.8 Initialization

1054   RULE001_1             [C99] A compound literal has been used.\\
MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C99-6.5.2.5 Compound literals

1055	RULE001_1	[C99] The keyword 'inline' has been used.\\
REFERENCE - ISO:C99-6.7.4 Function specifiers

1056	RULE001_1	[C99] The keyword '_Bool' has been used.\\
REFERENCE - ISO:C99-6.2.5 Types

1100	Maj_Ident	The label '%s' is also declared as a typedef.\\
REFERENCE - ISO:C90-6.1.2.3 Name Spaces of Identifiers

1250	Min_Balancing	Unsuffixed integer constant causes implicit conversion of other operand.

1251	Min_Balancing	Suffixed integer constant causes implicit conversion of other operand.

1252	Min_Balancing	Suffixed integer constant implicitly converted to different integer type.

1253	Min_Balancing	Unsuffixed integer constant implicitly converted to different integer type.

1254	Maj_Const	Suffix is not consistent with a type of unsigned long.

1255	Maj_Const	Unsuffixed integer constant is not of type int.

1256	Min_Assignment	An integer constant suffixed with L is being converted to type signed or unsigned long long on assignment.
* mapped by default to MISRA rule 10.1, but mapping is wrong according our understanding (S. Gaile, G. Kulkarni 21.05.2015)

1257	RULE010_1	An integer constant suffixed with L or LL is being converted to a type of lower rank on assignment.

1258	Min_Casts	Suffixed integer constant cast to a different integral type.

1259	Min_Casts	Unsuffixed integer constant cast to a different integral type.

1260	Min_Balancing	Integer constant implicitly converted to a floating type.

1261	Min_Balancing	Suffixed floating constant implicitly converted to different floating type.

1262	Min_Balancing	Unsuffixed floating constant implicitly converted to different floating type.

1263	Min_Balancing	Floating constant causes implicit conversion of other (integral) operand.

1264	RULE010_2	A suffixed floating constant is being converted to a different floating type on assignment.

1265	Min_Assignment	An unsuffixed floating constant is being converted to a different floating type on assignment.
* mapped by default to MISRA rule 10.2, but mapping is wrong according our understanding (S. Gaile, G. Kulkarni 21.05.2015)

1266	RULE010_2	A floating constant is being converted to integral type on assignment.

1267	Maj_Casts	Suffixed floating constant cast to another type.

1268	Min_Casts	Unsuffixed floating constant cast to another type.

1269	Min_Casts	Floating constant cast to integral type.

1271	Maj_Enum	Using a non-int expression to define an enum constant.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1272	Min_Const	Redundant leading zeroes on a numeric constant.

1274	Min_Balancing	Unsuffixed floating constant causes implicit conversion of other (floating) operand.

1275	Min_Balancing	Suffixed floating constant causes implicit conversion of other (floating) operand.

1276	OTC_Implicit	An integer constant is being converted to floating type on assignment.

1277	Min_Const	Hex constant does not include a "U" suffix.

1278	Min_Const	Decimal constant includes a suffix.

1279	Min_Const	Hex constant includes an "L" suffix.

1280	Min_Const	A lowercase letter L (l) has been used in an integer or floating suffix.\\
REFERENCE - ISO:C90-6.1.3.1 (Floating Constants) & 6.1.3.2 (Integer Constants)

1281   RULE010_6             Integer literal constant is of an unsigned type but does not include a "U" suffix.\\
MISRA-C:2004 Rule 10.6; REFERENCE - ISO:C90-6.1.3.2 (Integer Constants)

1290	RULE010_1	An integer constant of 'essentially signed' type is being converted to unsigned type on assignment.

1291	Min_Assignment	An integer constant of 'essentially unsigned' type is being converted to signed type on assignment.
* mapped by default to MISRA rule 10.1, but mapping is wrong according our understanding (S. Gaile, G. Kulkarni 21.05.2015)

1292	RULE010_1	An integer constant of 'essentially signed' type is being converted to type char on assignment.

1293	RULE010_1	An integer constant of 'essentially unsigned' type is being converted to type char on assignment.

1294	RULE010_1	An integer constant of 'essentially signed' type is being converted to type _Bool on assignment.

1295	RULE010_1	An integer constant of 'essentially unsigned' type is being converted to type _Bool on assignment.

1296	RULE010_1	An integer constant of 'essentially signed' type is being converted to enum type on assignment.

1297	RULE010_1	An integer constant of 'essentially unsigned' type is being converted to enum type on assignment.

1298	Min_Assignment	An integer constant of 'essentially signed' type is being converted to floating type on assignment.
* mapped by default to MISRA rule 10.1, but mapping is wrong according our understanding (S. Gaile, G. Kulkarni 21.05.2015)

1299	Min_Assignment	An integer constant of 'essentially unsigned' type is being converted to floating type on assignment.
* mapped by default to MISRA rule 10.1, but mapping is wrong according our understanding (S. Gaile, G. Kulkarni 21.05.2015)

1300	Maj_Cpp	'%s' is a keyword in C++.

1301	Min_Cpp	'%s' is a keyword in some C++ implementations.

1302	Maj_Func	'%s()' must be declared before use in C++.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls - Semantics

1303	Min_Cpp	An empty parameter list in a function type has a different meaning in C++.\\
REFERENCE - ISO:C90-6.5.4.3 Function Declarators (Including Prototypes) - Semantics, ISO:C90-6.9.4 Future Language Directions
* covered by message 3001 as well

1304	Min_Func	Old style definition of function '%s()' is not portable to C++.
* covered by message 3002 as well

1305	Min_Cpp	The global object '%s' declared 'const' has external linkage in C but internal linkage in C++.

1306	Maj_Cpp	Multiple tentative definitions of '%s'. This is not allowed in C++.

1307	Min_Cpp	Unnamed 'struct' and 'union' types may cause portability problems when moving to C++.

1308	Maj_Cpp	The tag '%s' would clash with an existing typedef in C++.

1309	Maj_Cpp	The typedef '%s' would clash with an existing 'struct' / 'union' / 'enum' tag in C++.

1310	Min_Ident	'%s' is used as a tag and a typedef for the same 'struct' / 'union' / 'enum'.

1311	Obsolete	'void *' and 'const T *' pointers used as operands to an equality or conditional operator.

1312	Maj_Decl	The array being initialized is not large enough to hold a terminating null byte for the string initializer.\\
REFERENCE - ISO:C90-6.5.7 Initialization

1313	Obsolete	Executing 'goto %s' will cause local initialization to be skipped.\\
REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

1314	Min_Cpp	The tag '%s' is defined within another 'struct' / 'union'.

1315	Maj_Decl	The 'static' qualifier has been used in the declaration of a tag.

1317   RULE010_1             Value of constant expression is not in the enum type to which it is being converted.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1318	Maj_Cpp	Object of enum type is being modified with a compound assignment operator.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1319	Maj_Cpp	Object of enum type is being modified with an increment or decrement operator.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1322	Maj_Cpp	In C, sizeof('c') == sizeof(int), but in C++, sizeof('c') == sizeof(char) == 1.\\
REFERENCE - ISO:C90-6.1.3.4 Character Constants - Semantics

1323	Min_Enum	The sizeof operator has been applied to an enum constant.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1324	Maj_Cpp	Function 'main' cannot be called or have its address taken in C++.

1325	Cri_Func	'%s()'  is defined with a non-void return type but contains 'return;'. This is not allowed in C++.

1327	Maj_Cpp	The macro __STDC__ has been used. It may not be present in a C++ environment.\\
REFERENCE - ISO:C90-6.8.8 Predefined Macro Names

1328	Maj_Func	Tag type defined within a function declaration.

1329	Maj_Cpp	The global object '%s' declared 'const' has been defined without an explicit initializer. This is not allowed in C++.

1330   RULE016_4             The parameter identifiers in this function declaration differ from those in a previous declaration.\\
MISRA-C:2004 Rule 16.4

1331   RULE008_3             Type or number of arguments doesn't match previous use of the function.\\
MISRA-C:2004 Rule 8.3

1332   RULE008_3             Type or number of arguments doesn't match prototype found later.\\
MISRA-C:2004 Rule 8.3

1333   RULE008_3             Type or number of arguments doesn't match function definition found later.\\
MISRA-C:2004 Rule 8.3

1334   Min_Func             The parameter identifiers in the prototypes of these functions/function pointers are different.\\
MISRA-C:2004 Rule 16.4
* not mapped to any MISRA rule any more (by QAC default setting)

1335   RULE016_3             Parameter identifiers missing in function prototype declaration.\\
MISRA-C:2004 Rule 16.3

1336   RULE016_3             Parameter identifiers missing in declaration of a function type.\\
MISRA-C:2004 Rule 16.3

1337	RULE016_1	Function defined with a variable number of parameters.

1400	OTC_Enums	Enum object is being compared with an enum constant of a different enum type using an equality operator.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1401   RULE010_1             Function parameter of enum type is being passed the value of an enum constant of a different enum type.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1402   RULE010_1             Object of enum type is being assigned the value of an enum constant of a different enum type.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1403   RULE010_1             Function of enum type is returning the value of an enum constant of a different enum type.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1411   RULE010_1             Function parameter of enum type is being passed the value of a constant, non-enum argument.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1412   RULE010_1             Object of enum type is being assigned the value of a constant, non-enum expression.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1413   RULE010_1             Function of enum type is returning the value of a constant, non-enum expression.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1421   RULE010_1             Function parameter of enum type is being passed the value of an object of a different enum type.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1422   RULE010_1             Object of enum type is being assigned the value of an object of a different enum type.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1423   RULE010_1             Function of enum type is returning the value of an object of a different enum type.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1431   RULE010_1             Function parameter of non-enum type is being passed the value of an object of enum type.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1433   RULE010_1             Function of non-enum type is returning the value of an object of enum type.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1434	Min_Enum	This enum constant is not representable in a 16 bit integer type.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1441   RULE010_1             Function parameter of enum type is being passed the value of a non-constant, non-enum expression.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1442   RULE010_1             Object of enum type is being assigned the value of a non-constant, non-enum expression.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1443   RULE010_1             Function of enum type is returning the value of a non-constant, non-enum expression.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1460   RULE014_1             'Switch' label value, %s, not contained in enum type.\\
MISRA-C:2004 Rule 14.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1461   RULE010_1             Value of constant expression is not in the enum type to which it is being converted, but is bitwise OR of constants in the enum type.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1470	Maj_Switch	Numeric constant used as 'case' label with 'switch' expression of enum type.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1472	Maj_Switch	Enum constant used as 'case' label with 'switch' expression of different enum type.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1473	OTC_Enums	The 2nd and 3rd operands of this conditional operator (? :) are of different enum types.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1474	OTC_Enums	Object of enum type is being modified with a bitwise compound assignment operator.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1475	Min_Enum	Range of possible enum values suggests this test is always true.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1476	Min_Enum	Range of possible enum values suggests this test is always false.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1477	Maj_Enum	Object of enum type is being implicitly compared against zero in a controlling expression.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1478	Maj_Enum	Object of an enum type which does not include a zero value, is being implicitly compared against zero in a controlling expression.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1479	OTC_Enums	Object of enum type is being modified with an arithmetic compound assignment operator.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1480	OTC_Enums	Objects or constants of different enum types are operands of a bitwise operator.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1481	OTC_Enums	Object of enum type is being modified with an increment or decrement operator.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1482	OTC_Enums	Non-constant expression cast to enum type.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1483	Maj_KandR	Enum object or constant passed as argument to function declared in K&R style.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1484	OTC_Enums	Constant expression cast to enum type.\\
REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers
* obsolete -> switch off in personality

1500	CMA_declaration	The object '%1s' is declared but is not used within this project.

1501	CMA_declaration	The function '%1s' is declared but is not used within this project.

1502	CMA_declaration	The object '%1s' is defined but is not used within this project.

1503   RULE014_1             The function '%1s' is defined but is not used within this project.\\
MISRA-C:2004 Rule 14.1

1504   RULE08_10             The object '%1s' is only referenced in the translation unit where it is defined.\\
MISRA-C:2004 Rule 8.10

1505   RULE08_10             The function '%1s' is only referenced in the translation unit where it is defined.\\
MISRA-C:2004 Rule 8.10

1506   RULE005_3             The identifier '%1s' is declared as a typedef and is used elsewhere for a different kind of declaration.\\
MISRA-C:2004 Rule 5.3

1507   RULE005_3             '%1s' is used as a typedef for different types.\\
MISRA-C:2004 Rule 5.3

1508   RULE005_3             The typedef '%1s' is declared in more than one location.\\
MISRA-C:2004 Rule 5.3

1509   RULE008_9             '%1s' has external linkage and has multiple definitions.\\
MISRA-C:2004 Rule 8.9

1510   RULE008_4             '%1s' has external linkage and has incompatible declarations.\\
MISRA-C:2004 Rule 8.4

1513   RULE008_8             Identifier '%1s' with external linkage has separate non-defining declarations in more than one location.\\
MISRA-C:2004 Rule 8.8

1514   RULE008_7             The object '%1s' is only referenced by function '%2s', in the translation unit where it is defined\\
MISRA-C:2004 Rule 8.7

1520   RULE016_2             Functions are indirectly recursive.\\
MISRA-C:2004 Rule 16.2

1525   RULE005_5             Object/function with external linkage has same identifier as another object/function with internal linkage.\\
MISRA-C:2004 Rule 5.5

1526   RULE005_5             Object with no linkage has same identifier as another object/function with external linkage.\\
MISRA-C:2004 Rule 5.5

1527   RULE005_5             Object/function with internal linkage has same identifier as another object/function with internal linkage.\\
MISRA-C:2004 Rule 5.5

1528   RULE005_5             Object with no linkage has same identifier as another object/function with internal linkage.\\
MISRA-C:2004 Rule 5.5

1529   RULE005_5             Object with no linkage has same identifier as another object with static storage duration but no linkage.\\
MISRA-C:2004 Rule 5.5

1690	Min_Prepro	Null preprocessing directive used.\\
REFERENCE - ISO:C90-6.8.7 Null Directive

1691	Min_Prepro	Null preprocessing directive used in an excluded section of code.\\
REFERENCE - ISO:C90-6.8.7 Null Directive

1800	RULE010_1 	The %1s operand (essential type: '%2s') will be implicitly converted to a floating type, '%3s', in this arithmetic operation.

1802	RULE010_1 	The %1s operand (essential type: '%2s') will be implicitly converted to a floating type, '%3s', in this relational operation.

1803	RULE010_1 	The %1s operand (essential type: '%2s') will be implicitly converted to a floating type, '%3s', in this equality operation.

1804	RULE010_1 	The %1s operand (essential type: '%2s') will be implicitly converted to a floating type, '%3s', in this conditional operation.

1810	RULE006_1	An operand of 'essentially character' type is being added to another operand of 'essentially character' type.

1811	RULE006_1	An operand of 'essentially character' type is being subtracted from an operand of 'essentially signed' type.

1812	RULE006_1	An operand of 'essentially character' type is being subtracted from an operand of 'essentially unsigned' type.

1813	RULE006_1	An operand of 'essentially character' type is being balanced with an operand of 'essentially floating' type in this arithmetic operation.

1820	RULE010_1	The %1s operand is non-constant and 'essentially signed' (%2s) but will be implicitly converted to an unsigned type (%3s) in this arithmetic operation.

1821	RULE010_1	The %1s operand is non-constant and 'essentially signed' (%2s) but will be implicitly converted to an unsigned type (%3s) in this bitwise operation.

1822	RULE010_1	The %1s operand is non-constant and 'essentially signed' (%2s) but will be implicitly converted to an unsigned type (%3s) in this relational operation.

1823	RULE010_1	The %1s operand is non-constant and 'essentially signed' (%2s) but will be implicitly converted to an unsigned type (%3s) in this equality operation.

1824	RULE010_1	The %1s operand is non-constant and 'essentially signed' (%2s) but will be implicitly converted to an unsigned type (%3s) in this conditional operation.

1830	RULE010_1	The %1s operand is constant, 'essentially signed' (%2s) and negative but will be implicitly converted to an unsigned type (%3s) in this arithmetic operation.

1831	RULE010_1	The %1s operand is constant, 'essentially signed' (%2s) and negative but will be implicitly converted to an unsigned type (%3s) in this bitwise operation.

1832	RULE010_1	The %1s operand is constant, 'essentially signed' (%2s) and negative but will be implicitly converted to an unsigned type (%3s) in this relational operation.

1833	RULE010_1	The %1s operand is constant, 'essentially signed' (%2s) and negative but will be implicitly converted to an unsigned type (%3s) in this equality operation.

1834	RULE010_1	The %1s operand is constant, 'essentially signed' (%2s) and negative but will be implicitly converted to an unsigned type (%3s) in this conditional operation.

1840	Min_Balancing	The %1s operand is constant, 'essentially signed' (%2s) and non-negative but will be implicitly converted to an unsigned type (%3s) in this arithmetic operation.
* shall be deactivated in personality

1841	Min_Balancing	The %1s operand is constant, 'essentially signed' (%2s) and non-negative but will be implicitly converted to an unsigned type (%3s) in this bitwise operation.
* shall be deactivated in personality

1842	Min_Balancing	The %1s operand is constant, 'essentially signed' (%2s) and non-negative but will be implicitly converted to an unsigned type (%3s) in this relational operation.
* shall be deactivated in personality

1843	Min_Balancing	The %1s operand is constant, 'essentially signed' (%2s) and non-negative but will be implicitly converted to an unsigned type (%3s) in this equality operation.
* shall be deactivated in personality

1844	Min_Balancing	The %1s operand is constant, 'essentially signed' (%2s) and non-negative but will be implicitly converted to an unsigned type (%3s) in this conditional operation.
* shall be deactivated in personality

1850	Maj_Balancing	The %1s operand is 'essentially unsigned' (%2s) but will be implicitly converted to a signed type (%3s) in this arithmetic operation.

1851	Maj_Balancing	The %1s operand is 'essentially unsigned' (%2s) but will be implicitly converted to a signed type (%3s) in this bitwise operation.

1852	Maj_Balancing	The %1s operand is 'essentially unsigned' (%2s) but will be implicitly converted to a signed type (%3s) in this relational operation.

1853	Maj_Balancing	The %1s operand is 'essentially unsigned' (%2s) but will be implicitly converted to a signed type (%3s) in this equality operation.

1854	Maj_Balancing	The %1s operand is 'essentially unsigned' (%2s) but will be implicitly converted to a signed type (%3s) in this conditional operation.

1860	Min_Balancing	The operands of this arithmetic operator are of different 'essential signedness' but will generate a result of type 'signed int'.
* shall be deactivated in personality

1861	Maj_Balancing	The operands of this bitwise operator are of different 'essential signedness' but will generate a result of type 'signed int'.

1862	Maj_Balancing	The operands of this relational operator are of different 'essential signedness' but will both be promoted to 'signed int' for comparison.

1863	Maj_Balancing	The operands of this equality operator are of different 'essential signedness' but will both be promoted to 'signed int' for comparison.

1864	Maj_Balancing	The 2nd and 3rd operands of this conditional operator are of different 'essential signedness'. The result will be in the promoted type 'signed int'.

1880	RULE010_1	The operands of this relational operator are expressions of different 'essential type' categories (%1s and %2s).

1881	RULE010_1	The operands of this equality operator are expressions of different 'essential type' categories (%1s and %2s).

1882	RULE010_1	The 2nd and 3rd operands of this conditional operator are expressions of different 'essential type' categories (%1s and %2s).

1890	Min_Complex	A composite expression of 'essentially signed' type (%1s) is being implicitly converted to a wider signed type, '%2s'.
* shall be deactivated in personality

1891	Min_Complex	A composite expression of 'essentially unsigned' type (%1s) is being implicitly converted to a wider unsigned type, '%2s'.
* shall be deactivated in personality

1892	Min_Complex	A composite expression of 'essentially floating' type (%1s) is being implicitly converted to a wider floating type, '%2s'.
* shall be deactivated in personality

1893	Min_Complex	The 2nd and 3rd operands of this conditional operator are both 'essentially signed' ('%1s' and '%2s') but one is a composite expression of a narrower type than the other.
* shall be deactivated in personality

1894	Min_Complex	The 2nd and 3rd operands of this conditional operator are both 'essentially unsigned' ('%1s' and '%2s') but one is a composite expression of a narrower type than the other.
* shall be deactivated in personality

1895	Min_Complex	The 2nd and 3rd operands of this conditional operator are both 'essentially floating' ('%1s' and '%2s') but one is a composite expression of a narrower type than the other.
* shall be deactivated in personality

2000	Min_Ctrl	No 'else' clause exists for this 'if' statement.
* shall be deactivated in personality

2001   RULE014_4             A 'goto' statement has been used.\\
MISRA-C:2004 Rule 14.4

2002   RULE015_3             No 'default' label found in this 'switch' statement.\\
MISRA-C:2004 Rule 15.3

2003   RULE015_2             The preceding 'switch' clause is not empty and does not end with a 'jump' statement. Execution will fall through.\\
MISRA-C:2004 Rule 15.2

2004   RULE14_10             No concluding 'else' exists in this 'if'-'else'-'if' statement.\\
MISRA-C:2004 Rule 14.10

* replaced by message 2889: 2006   RULE014_7             '%s()' has more than one 'return' path.\\
* MISRA-C:2004 Rule 14.7

2007	Min_Decl	'auto' does not add information to a declaration, and is best avoided.

2008   RULE014_1             Code statements precede the first label in this 'switch' construct.\\
MISRA-C:2004 Rule 14.1; REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Semantics

2009   RULE015_3             This 'default' label is not the final 'case' label within the 'switch' block.\\
MISRA-C:2004 Rule 15.3

2010	Maj_Func	The function '%s()' must not be called.

2011	Min_Decl	The 'register' storage class specifier has been used.

2015	Min_Ctrl	A statement 'label' has been used.

2016	Maj_Switch	This 'switch' statement 'default' clause is empty.

2017	Min_Prepro	Comment spans more than one line.
* shall be deactivated in personality

* replaced by message 2881: 2018	ODF_Control	This 'switch' 'default' label is probably unreachable.

2019   RULE015_1             'Switch' label is located within a nested code block.\\
MISRA-C:2004 Rule 15.1

2020   RULE015_2             Final 'switch' clause does not end with an explicit 'jump' statement.\\
MISRA-C:2004 Rule 15.2

2021	Maj_Decl	This tentative definition is interpreted as a declaration. Is this intended ?

2022	Min_Decl	A tentative definition is being used. Is it appropriate to include an explicit initializer ?
* shall be deactivated in personality

2050   RULE008_2             The 'int' type specifier has been omitted from a function declaration.\\
MISRA-C:2004 Rule 8.2

2051   RULE008_2             The 'int' type specifier has been omitted from an object declaration.\\
MISRA-C:2004 Rule 8.2

2100	Min_Prom	Integral promotion : unsigned char promoted to signed int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers
* shall be deactivated in personality

2101	Min_Prom	Integral promotion : unsigned short promoted to signed int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers
* shall be deactivated in personality

2102	Min_Prom	Integral promotion : unsigned char promoted to unsigned int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers
* shall be deactivated in personality

2103	Min_Prom	Integral promotion : unsigned short promoted to unsigned int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers
* shall be deactivated in personality

2104	Min_Prom	Integral promotion : signed char promoted to signed int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers
* shall be deactivated in personality

2105	Min_Prom	Integral promotion : signed short promoted to signed int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers
* shall be deactivated in personality

2106	Min_Prom	Integral promotion : plain char promoted to signed int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers
* shall be deactivated in personality

2107	Min_Prom	Integral promotion : plain char promoted to unsigned int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers
* shall be deactivated in personality

2109	Min_Prom	Integral promotion : _Bool promoted to signed int.\\
REFERENCE - ISO:C99-6.3.1.1 Boolean, characters, and integers
* shall be deactivated in personality

2110	Min_Prom	Default argument promotion : unsigned char promoted to signed int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2111	Min_Prom	Default argument promotion : unsigned short promoted to signed int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2112	Min_Prom	Default argument promotion : unsigned char promoted to unsigned int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2113	Min_Prom	Default argument promotion : unsigned short promoted to unsigned int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2114	Min_Prom	Default argument promotion : signed char promoted to signed int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2115	Min_Prom	Default argument promotion : signed short promoted to signed int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2116	Min_Prom	Default argument promotion : plain char promoted to signed int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2117	Min_Prom	Default argument promotion : plain char promoted to unsigned int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2118	Min_Prom	Default argument promotion : float promoted to double.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2119	Min_Prom	Default argument promotion : _Bool promoted to signed int.\\
REFERENCE - ISO:C99-6.5.2.2 Function Calls
* shall be deactivated in personality

2120	Maj_Prom	Integral promotion : unsigned bit-field promoted to signed int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers

2122	Min_Prom	Integral promotion : unsigned bit-field promoted to unsigned int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers
* shall be deactivated in personality

2124	Min_Prom	Integral promotion : signed bit-field promoted to signed int.\\
REFERENCE - ISO:C90-6.2.1.1 Characters and Integers
* shall be deactivated in personality

2130	Maj_Prom	Default argument promotion : unsigned bit-field promoted to signed int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros

2132	Min_Prom	Default argument promotion : unsigned bit-field promoted to unsigned int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2134	Min_Prom	Default argument promotion : signed bit-field promoted to signed int.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls, 6.5.4.3 Function Declarators, 7.8.1 Variable argument list access macros
* shall be deactivated in personality

2200	Maj_Brace	Indentation of this line is to the left of the line above.

2201	Min_Brace	This indentation is not consistent with previous indentation in this file.

2203	Maj_Brace	This closing brace is not aligned appropriately with the matching opening brace.

2204	Min_Brace	'%s' is not aligned to match its controlling 'switch' statement.
* shall be deactivated in personality

2205	Maj_Brace	More than one declaration or statement on the same line.

2207	Min_Brace	This brace style is not consistent with 'K&R' style.
* shall be deactivated in personality

2208	Min_Brace	This brace style is not consistent with 'indented' style.

2209	Min_Brace	This brace style is not consistent with 'exdented' style.
* shall be deactivated in personality

2210	Maj_Brace	Tab character encountered in this line.

2211	Min_Brace	'%s' is not aligned with the previously declared identifier.
* shall be deactivated in personality

2212   RULE014_8             Body of control statement is not enclosed within braces.\\
MISRA-C:2004 Rules 14.8, 14.9

2213	Min_Brace	Matching braces appear on the same line - proper indentation would be preferred.
* shall be deactivated in personality

2214   RULE014_8             Body of control statement is on the same line and is not enclosed within braces.\\
MISRA-C:2004 Rules 14.8, 14.9

2215	Min_Brace	This indentation is not consistent with configured depth.
* shall be deactivated in personality

2216	Min_Brace	More than one structure or union member declared on the same line.

2217	Min_Brace	Line length exceeds %s characters.
* shall be deactivated in personality

2461	Maj_Ctrl	Loop control variable, %s, has file scope.

2462   RULE013_5             The variable initialized in the first expression of this 'for' statement is not the variable identified as the 'loop control variable' (%s).\\
MISRA-C:2004 Rule 13.5

2463   RULE013_5             The variable incremented in the third expression of this 'for' statement is not the variable identified as the 'loop control variable' (%s).\\
MISRA-C:2004 Rule 13.5

2464	Maj_Ctrl	Loop control variable, %s, modified twice in for-loop header.

2465	ODF_Control	This 'for' loop will only be executed once.
* obsolete, shall be deactivated in personality

2466	Obsolete	The value of this controlling expression is always 'false'. The contained code is unreachable.
* obsolete, shall be deactivated in personality

2467	Maj_Ctrl	Loop control variable, %s, is not modified inside loop.

2468	Maj_Ctrl	Loop control variable, %s, is not modified inside loop but has file scope.

2469   RULE013_6             Loop control variable in this 'for' statement, %s, is modified in the body of the loop.\\
MISRA-C:2004 Rule 13.6

2470	Maj_Ctrl	Taking address of loop control variable, %s.

2471	Maj_Ctrl	Unable to identify a loop control variable.

2472	Maj_Ctrl	More than one possible loop control variable.

2547   RULE005_2             This declaration of tag '%s' hides a more global declaration.\\
MISRA-C:2004 Rule 5.2

2740	DF_Invariant	This loop controlling expression is a constant expression and its value is 'true'.

2741	DF_Invariant	This 'if' controlling expression is a constant expression and its value is 'true'.

2742	DF_Invariant	This 'if' controlling expression is a constant expression and its value is 'false'.

2743	DF_Invariant	This 'do - while' loop controlling expression is a constant expression and its value is 'false'. The loop will only be executed once.

2744	DF_Critical	  This 'while' or 'for' loop controlling expression is a constant expression and its value is 'false'. The loop will not be entered.

2750	DF_Recovery	Internal dataflow problem. Dataflow analysis continues with the next function. Please inform Programming Research.

2751	DF_Recovery	This function is too complex. Dataflow analysis continues with the next function.

2752	DF_Recovery	This '%1s' results in the function being too complex. Dataflow analysis continues with the next function.

2753	DF_Recovery	As a result of error message '%s', dataflow analysis of the remainder of this function is not possible.

2754	DF_Recovery	As a result of error message '%s', dataflow analysis of the remainder of this translation unit is not possible.

2755	DF_Recovery	Analysis time of function '%1s' has exceeded the configured maximum: '%2sms'.  Dataflow analysis continues with the next function.

2756	DF_Recovery	Could not expand function call to '%1s' with maximum '-po df::inter' value.

2757	DF_Recovery	Could not analyse function '%1s'.\\
Try a smaller '-po df::inter' value?

2771	DF_Critical	Definite: These pointers address different objects.

2772	DF_Mandatory	Apparent: These pointers address different objects.

2773	DF_Pointers	Suspicious: These pointers address different objects.

2776	DF_Critical	Definite: Copy between overlapping objects.

2777	DF_Mandatory	Apparent: Copy between overlapping objects.

2778	DF_Pointers	Suspicious: Copy between overlapping objects.

2790	DF_Critical	Constant: Right hand operand of shift operator is negative or too large.

2791	DF_Critical	Definite: Right hand operand of shift operator is negative or too large.

2792	DF_Mandatory	Apparent: Right hand operand of shift operator is negative or too large.

2793	DF_Shift	Suspicious: Right hand operand of shift operator is negative or too large.

2800	DF_Critical	Constant: Overflow in signed arithmetic operation.

2801	DF_Critical	Definite: Overflow in signed arithmetic operation.

2802	DF_Mandatory	Apparent: Overflow in signed arithmetic operation.

2803	DF_Overflow	Suspicious: Overflow in signed arithmetic operation.

2810	DF_Critical	Constant: Dereference of NULL pointer.

2811	DF_Critical	Definite: Dereference of NULL pointer.

2812	DF_Mandatory	Apparent: Dereference of NULL pointer.

2813	DF_NULL	Suspicious: Dereference of NULL pointer.

2814	DF_NULL	Possible: Dereference of NULL pointer.

2820	DF_Critical	Constant: Arithmetic operation on NULL pointer.

2821	DF_Critical	Definite: Arithmetic operation on NULL pointer.

2822	DF_Mandatory	Apparent: Arithmetic operation on NULL pointer.

2823	DF_NULL	Suspicious: Arithmetic operation on NULL pointer.

2824	DF_NULL	Possible: Arithmetic operation on NULL pointer.

2830	DF_Critical	Constant: Division by zero.

2831	DF_Critical	Definite: Division by zero.

2832	DF_Mandatory	Apparent: Division by zero.

2833	DF_Overflow	Suspicious: Division by zero.

2834	DF_Overflow	Possible: Division by zero.

2840	DF_Critical	Constant: Dereference of an invalid pointer value.

2841	DF_Critical	Definite: Dereference of an invalid pointer value.

2842	DF_Mandatory	Apparent: Dereference of an invalid pointer value.

2843	DF_Arrays	Suspicious: Dereference of an invalid pointer value.

2845	DF_Arrays	Constant: Maximum number of characters to be written is larger than the target buffer size.

2846	DF_Arrays	Definite: Maximum number of characters to be written is larger than the target buffer size.

2847	DF_Arrays	Apparent: Maximum number of characters to be written is larger than the target buffer size.

2848	DF_Arrays	Suspicious: Maximum number of characters to be written is larger than the target buffer size.

2850	DF_Critical	Constant: Implicit conversion to a signed integer type of insufficient size.

2851	DF_Critical	Definite: Implicit conversion to a signed integer type of insufficient size.

2852	DF_Mandatory	Apparent: Implicit conversion to a signed integer type of insufficient size.

2853	DF_Signed	Suspicious: Implicit conversion to a signed integer type of insufficient size.

2855	DF_Critical	Constant: Casting to a signed integer type of insufficient size.

2856	DF_Critical	Definite: Casting to a signed integer type of insufficient size.

2857	DF_Mandatory	Apparent: Casting to a signed integer type of insufficient size.

2858	DF_Signed	Suspicious: Casting to a signed integer type of insufficient size.

2860	DF_Critical	Constant: Implementation-defined value resulting from left shift operation on expression of signed type.

2861	DF_Critical	Definite: Implementation-defined value resulting from left shift operation on expression of signed type.

2862	DF_Mandatory	Apparent: Implementation-defined value resulting from left shift operation on expression of signed type.

2863	DF_Shift	Suspicious: Implementation-defined value resulting from left shift operation on expression of signed type.

2870	DF_Control	Infinite loop construct with constant control expression.

2871	DF_Critical	Infinite loop identified.

2872	DF_Critical	This loop, if entered, will never terminate.

2877	DF_Mandatory	This loop will never be executed more than once.

2880	DF_Mandatory	This code is unreachable.

2881	DF_Control	The code in this 'default' clause is unreachable.

2882	DF_Critical	This 'switch' statement will bypass the initialization of local variables.

2883	DF_Critical	This 'goto' statement will always bypass the initialization of local variables.

2887	DF_Control	Function 'main' ends with an implicit 'return' statement.

2888	DF_Critical	This function has been declared with a non-void 'return' type but ends with an implicit 'return ;' statement.

2889	DF_Control	This function has more than one 'return' path.

2890	DF_Critical	Constant: Negative value implicitly converted to an unsigned type.

2891	DF_Critical	Definite: Negative value implicitly converted to an unsigned type.

2892	DF_Mandatory	Apparent: Negative value implicitly converted to an unsigned type.

2893	DF_Unsigned	Suspicious: Negative value implicitly converted to an unsigned type.

2895	DF_Unsigned	Constant: Negative value cast to an unsigned type.

2896	DF_Critical	Definite: Negative value cast to an unsigned type.

2897	DF_Mandatory	Apparent: Negative value cast to an unsigned type.

2898	DF_Unsigned	Suspicious: Negative value cast to an unsigned type.

2900	DF_Critical	Constant: Positive integer value truncated by implicit conversion to a smaller unsigned type.

2901	DF_Critical	Definite: Positive integer value truncated by implicit conversion to a smaller unsigned type.

2902	DF_Mandatory	Apparent: Positive integer value truncated by implicit conversion to a smaller unsigned type.

2903	DF_Unsigned	Suspicious: Positive integer value truncated by implicit conversion to a smaller unsigned type.

2905	DF_Unsigned	Constant: Positive integer value truncated by cast to a smaller unsigned type.

2906	DF_Unsigned	Definite: Positive integer value truncated by cast to a smaller unsigned type.

2907	DF_Unsigned	Apparent: Positive integer value truncated by cast to a smaller unsigned type.

2908	DF_Unsigned	Suspicious: Positive integer value truncated by cast to a smaller unsigned type.

2910	DF_Critical	Constant: Wraparound in unsigned arithmetic operation.

2911	DF_Critical	Definite: Wraparound in unsigned arithmetic operation.

2912	DF_Mandatory	Apparent: Wraparound in unsigned arithmetic operation.

2913	DF_Overflow	Suspicious: Wraparound in unsigned arithmetic operation.

2920	DF_Shift	Constant: Left shift operation on expression of unsigned type results in loss of high order bits.

2921	DF_Shift	Definite: Left shift operation on expression of unsigned type results in loss of high order bits.

2922	DF_Shift	Apparent: Left shift operation on expression of unsigned type results in loss of high order bits.

2923	DF_Shift	Suspicious: Left shift operation on expression of unsigned type results in loss of high order bits.

2930	DF_Critical	Constant: Computing an invalid pointer value.

2931	DF_Critical	Definite: Computing an invalid pointer value.

2932	DF_Mandatory	Apparent: Computing an invalid pointer value.

2933	DF_Arrays	Suspicious: Computing an invalid pointer value.

2940	DF_Signed	Constant: Result of implicit conversion is only representable in a two's complement implementation.

2941	DF_Signed	Definite: Result of implicit conversion is only representable in a two's complement implementation.

2942	DF_Signed	Apparent: Result of implicit conversion is only representable in a two's complement implementation.

2943	DF_Signed	Suspicious: Result of implicit conversion is only representable in a two's complement implementation.

2945	DF_Signed	Constant: Result of cast is only representable in a two's complement implementation.

2946	DF_Signed	Definite: Result of cast is only representable in a two's complement implementation.

2947	DF_Signed	Apparent: Result of cast is only representable in a two's complement implementation.

2948	DF_Signed	Suspicious: Result of cast is only representable in a two's complement implementation.

2950	DF_Arrays	Constant: Negative value used in array subscript or pointer arithmetic operation.

2951	DF_Arrays	Definite: Negative value used in array subscript or pointer arithmetic operation.

2952	DF_Arrays	Apparent: Negative value used in array subscript or pointer arithmetic operation.

2953	DF_Arrays	Suspicious: Negative value used in array subscript or pointer arithmetic operation.

2961	DF_Critical	Definite: Using value of uninitialized automatic object '%s'.

2962	DF_Critical	Apparent: Using value of uninitialized automatic object '%s'.

2963	DF_Unset	Suspicious: Using value of uninitialized automatic object '%s'.

2971	DF_Critical	Definite: Passing address of uninitialized object '%s' to a function parameter declared as a pointer to const.

2972	DF_Critical	Apparent: Passing address of uninitialized object '%s' to a function parameter declared as a pointer to const.

2973	DF_Unset	Suspicious: Passing address of uninitialized object '%s' to a function parameter declared as a pointer to const.

2980	DF_Mandatory	The value of this function parameter is never used before being modified.

2981	DF_Redundancy	This initialization is redundant. The value of this object is never used before being modified.

2982	DF_Redundancy	This assignment is redundant. The value of this object is never used before being modified.

2983	DF_Redundancy	This assignment is redundant. The value of this object is never subsequently used.

2984	DF_Redundancy	This operation is redundant. The value of the result is always '%1s'.

2985	DF_Redundancy	This operation is redundant. The value of the result is always that of the left-hand operand.

2986	DF_Redundancy	This operation is redundant. The value of the result is always that of the right-hand operand.

2990	DF_Critical	The value of this loop controlling expression is always 'true'.

2991	DF_Mandatory	The value of this 'if' controlling expression is always 'true'.

2992	DF_Mandatory	The value of this 'if' controlling expression is always 'false'.

2993	DF_Mandatory	The value of this 'do - while' loop controlling expression is always 'false'. The loop will only be executed once.

2994	DF_Critical	The value of this 'while' or 'for' loop controlling expression is always 'false'. The loop will not be entered.

2995	DF_Mandatory	The result of this logical operation is always 'true'.

2996	DF_Mandatory	The result of this logical operation is always 'false'.

3001   RULE016_5             Function has been declared with an empty parameter list.\\
MISRA-C:2004 Rule 16.5; REFERENCE - ISO:C90-6.5.4.3 Function Declarators (Including Prototypes) - Semantics, ISO:C90-6.9.4 Future Language Directions

3002   RULE008_1             Defining '%s()' with an identifier list and separate parameter declarations is an obsolescent feature.\\
MISRA-C:2004 Rule 8.1; REFERENCE - ISO:C90-6.9.5 Future Language Directions

3003	Maj_Pointers	This character constant is being interpreted as a NULL pointer constant.

3004	Maj_Pointers	This integral constant expression is being interpreted as a NULL pointer constant.\\
REFERENCE - ISO:C90-6.2.2.3 Pointers, ISO:C99-6.3.2.3 Pointers

3006   RULE002_1             This function contains a mixture of in-line assembler statements and C statements.\\
MISRA-C:2004 Rule 2.1

3007   RULE016_5             "void" has been omitted when defining a function with no parameters.\\
MISRA-C:2004 Rule 16.5; REFERENCE - ISO:C90-6.5.4.3 Function Declarators (Including Prototypes) - Semantics, ISO:C90-6.7.1 Function Definitions - Constraints

3101   RULE012_9             Unary '-' applied to an operand of type unsigned int or unsigned long gives an unsigned result.\\
MISRA-C:2004 Rule 12.9; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Semantics

3102   RULE012_9             Unary '-' applied to an operand whose underlying type is unsigned.\\
MISRA-C:2004 Rule 12.9; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Semantics

3103	Min_Operations	Result of signed division or remainder operation may be implementation defined.\\
REFERENCE - ISO:C90-6.3.5 Multiplicative Operators - Semantics
* shall be deactivated in personality

3104	Syntax	[S] #pragma '%s' has invalid arguments and has been ignored.

3105	Syntax	[S] A #pragma block has not been closed with a #pragma '%s'.

3106	Min_Prepro	This preprocessing directive has been ignored because it lies within a #pragma block. #pragma '%s' expected.
* shall be deactivated in personality

3107	Syntax	[S] A #pragma '%s' has been found without a matching #pragma block start directive.

3108   RULE002_3             Nested comments are not recognized in the ISO standard.\\
MISRA-C:2004 Rule 2.3; REFERENCE - ISO:C90-6.1.9 Comments (footnote 26)

3109	Min_Read	Null statement follows other code on the same line.\\
REFERENCE - ISO:C90-6.6.3 Expression and Null Statements

3110   RULE014_2             The left-hand operand of this ',' has no side effects.\\
MISRA-C:2004 Rule 14.2; REFERENCE - ISO:C90-6.6.3 Expression and Null Statements

3111	Min_Array	Redundant comma at end of braced initializer will be ignored.\\
REFERENCE - ISO:C90-3.5.7 Initialization
* covered by message 686, shall be deactivated in personality

3112   RULE014_2             This statement has no side-effect - it can be removed.\\
MISRA-C:2004 Rule 14.2

3113   RULE016_8             [U] 'return' statement includes no expression but function '%s()' is implicitly of type 'int'.\\
MISRA-C:2004 Rule 16.8; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics

3114   RULE016_8             [U] Function '%s()' is implicitly of type 'int' but ends without returning a value.\\
MISRA-C:2004 Rule 16.8; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics

3115   RULE19_16             Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.\\
MISRA-C:2004 Rule 19.16

3116   RULE003_4             Unrecognized #pragma arguments '%s' This #pragma directive has been ignored.\\
MISRA-C:2004 Rule 3.4; REFERENCE - ISO:C90-6.8.6 Pragma Directive

3117	Min_Prepro	Expected 'on' or 'off' after '#pragma' flag.\\
REFERENCE - ISO:C90-6.8.6 Pragma Directive

3118	Min_Prepro	Using the #line preprocessing directive.\\
REFERENCE - ISO:C90-6.8.4 Line Control

3120	Maj_Const	Hard-coded 'magic' integer constant, '%s'.

3121	Maj_Const	Hard-coded 'magic' floating constant, '%s'.

3122	Maj_Const	Hard-coded 'magic' string literal, %s.

3123	Min_Const	Hard coded 'magic' character constant, %s.
* shall be deactivated in personality

3131	Min_Const	Hard coded 'magic' number, '%s', used to define the size of a bit-field.
* shall be deactivated in personality

3132	Maj_Const	Hard coded 'magic' number, '%s', used to define the size of an array.

3138   RULE014_3             Null statement is located close to other code or comments.\\
MISRA-C:2004 Rule 14.3

3139	Min_Read	Null statement is obscured by code or comment on the same line.
* shall be deactivated in personality

3140	Min_Read	Null statement occurs on a line by itself.
* shall be deactivated in personality

3141	Min_Read	Null statement does not occur on a line by itself.
* shall be deactivated in personality

3195	ODF_Redundancy	The function parameter '%s' is always modified before use.
* obsolete, shall be deactivated in personality

3196	Maj_Redun	The variable '%s' is never set.

3197	ODF_Redundancy	This initialization is redundant. The value of '%s' is never used before being modified.
* obsolete, shall be deactivated in personality

3198	ODF_Redundancy	This assignment is redundant. The value of '%s' is never used before being modified.
* obsolete, shall be deactivated in personality

3199	ODF_Redundancy	This assignment is redundant. The value of '%s' is never subsequently used.
* obsolete, shall be deactivated in personality


3200   RULE16_10             '%s' returns a value which is not being used.\\
MISRA-C:2004 Rule 16.10

3201   RULE014_1             This statement is unreachable.\\
MISRA-C:2004 Rule 14.1
* obsolete, replaced by message 2880, shall be deactivated in personality

3202	Min_Redun	The label '%s:' is not used in this function and could be removed.\\
REFERENCE - ISO:C90-6.6.1 Labeled Statements

3203	Maj_Redun	The variable '%s' is set but never used.

3204	Min_Decl	The variable '%s' is only set once and so it could be declared with the 'const' qualifier.\\
REFERENCE - ISO:C90-6.5.3 Type Qualifiers

3205	Min_Redun	The identifier '%s' is not used and could be removed.

3206	Min_Redun	The parameter '%s' is not used in this function.

3207	Maj_Redun	File scope static, '%s', is not used, and could be removed.\\
REFERENCE - ISO:C90-6.1.2.2 Linkages of Identifiers

3208	Maj_Func	'%s()' returns a value which is sometimes ignored.\\
REFERENCE - ISO:C90-6.6.6.4 The return Statement

3209	Maj_Func	'%s()' returns a value which is always ignored.\\
REFERENCE - ISO:C90-6.6.6.4 The return Statement

3210	Maj_Redun	The global identifier '%s' is declared here but is not used in this translation unit.

3211	Min_Decl	The global identifier '%s' is defined here but is not used in this translation unit.

3212	Min_Operations	This cast is redundant.
* shall be deactivated in personality

3216	Min_Pointers	Address of local static object exported to a pointer with linkage or wider scope.

3217   RULE017_6             Address of automatic object exported to a pointer with linkage or wider scope.\\
MISRA-C:2004 Rule 17.6; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

3218   RULE008_7             File scope static, '%s', is only accessed in one function.\\
MISRA-C:2004 Rule 8.7

3219   RULE014_1             Static function '%s()' is not used within this translation unit.\\
MISRA-C:2004 Rule 14.1

3220	Min_Decl	Identifier declared at a nested level of block scope.
* shall be deactivated in personality

3221   RULE008_6             Function with external linkage declared at block scope.\\
MISRA-C:2004 Rule 8.6

3222   RULE008_8             Object with external linkage declared at block scope.\\
MISRA-C:2004 Rule 8.8

3223	Min_Decl	Object with static storage duration declared at block scope.
* shall be deactivated in personality

3224   RULE08_11             This identifier has previously been declared with internal linkage but is not declared here with the static storage class specifier.\\
MISRA-C:2004 Rule 8.11

3225   RULE017_6             Address of automatic object exported using a function parameter.\\
MISRA-C:2004 Rule 17.6; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

3226	Maj_Ops	The result of an assignment is being used in an arithmetic operation or another assigning operation.

3227	Min_Decl	The parameter '%s' is never modified and so it could be declared with the 'const' qualifier.\\
REFERENCE - ISO:C90-6.5.3 Type Qualifiers
* shall be deactivated in personality

3228	Min_Decl	Storage class specifier not positioned at the beginning of declaration.\\
REFERENCE - ISO:C90-6.9.3 Future Language Directions

3229	Maj_Redun	File scope static, '%s', is written but never used.

3230   RULE017_6             Address of automatic object assigned to local pointer with static storage duration.\\
MISRA-C:2004 Rule 17.6; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

3231	Min_Pointers	Address of local static object exported using a function parameter.
* shall be deactivated in personality

3232	Min_Decl	File scope static, '%s', is never modified. It could be declared const.
* shall be deactivated in personality

3233	Cri_Decl	File scope static, '%s', is not explicitly initialized but its value is used.

3234   RULE015_0             Declarations precede the first label in this 'switch' construct.\\
MISRA-C:2004 Rule 15.0

3236	RULE001_1	[C] 'inline' may not be applied to function 'main'.\\
REFERENCE - ISO:C99-6.7.4 Function specifiers - Constraints

3237	RULE001_1	[C] inline function '%1s' has external linkage and is defining an object, '%2s', with static storage duration.\\
REFERENCE - ISO:C99-6.7.4 Function specifiers - Constraints

3238	RULE001_1	[C] inline function '%1s' has external linkage and is referring to an object, '%2s', with internal linkage.\\
REFERENCE - ISO:C99-6.7.4 Function specifiers - Constraints

3239	RULE001_2	[U] inline function '%1s' has external linkage, but is not defined within this translation unit.\\
REFERENCE - ISO:C99-6.7.4 Function specifiers - Semantics

3240	Min_Func	inline function '%s' is being defined with external linkage.\\
REFERENCE - ISO:C99-6.7.4 Function specifiers - Semantics
* shall be deactivated in personality

3243	Maj_Func	inline function '%s' is also an 'external definition'.\\
REFERENCE - ISO:C99-6.7.4 Function specifiers - Semantics

3244	RULE001_1	[C] 'inline' may only be used in the declaration of a function identifier.\\
REFERENCE - ISO:C99-6.7.4 Function specifiers - Constraints

3260	RULE017_5	Typedef defined with more than 2 levels of indirection.\\
REFERENCE - ISO:C90-6.5.4.1 Pointer Declarators

3261	RULE017_5	Member of struct/union defined with more than 2 levels of indirection.\\
REFERENCE - ISO:C90-6.5.4.1 Pointer Declarators

3262	RULE017_5	Object defined or declared with more than 2 levels of indirection.\\
REFERENCE - ISO:C90-6.5.4.1 Pointer Declarators

3263	RULE017_5	Function defined or declared with a return type which has more than 2 levels of indirection.\\
REFERENCE - ISO:C90-6.5.4.1 Pointer Declarators

3302   RULE12_11             Wraparound past zero in unsigned subtraction of constant operands.\\
MISRA-C:2004 Rule 12.11; REFERENCE - ISO:C90-6.1.2.5 Types
* obsolete, replaced by 2910, shall be deactived in personality

3303   RULE12_11             Wraparound past zero in unsigned addition of constant operands.\\
MISRA-C:2004 Rule 12.11; REFERENCE - ISO:C90-6.1.2.5 Types
* obsolete, replaced by 2910, shall be deactived in personality

3304   RULE12_11             Wraparound past zero in unsigned multiplication of constant operands.\\
MISRA-C:2004 Rule 12.11; REFERENCE - ISO:C90-6.1.2.5 Types
* obsolete, replaced by 2910, shall be deactived in personality

3305	Maj_Pointers	Pointer cast to stricter alignment.

3306   RULE010_1             Truncation of positive constant integer value during implicit conversion to a smaller unsigned type.\\
MISRA-C:2004 Rule 10.1; REFERENCE - ISO:C90-6.2.1.2 Conversions, Signed and Unsigned Integers
* obsolete, replaced by 2900, shall be deactived in personality

3307   RULE012_3             The operand of 'sizeof' is an expression with implied side effects, but they will not be evaluated.\\
MISRA-C:2004 Rule 12.3; REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator - Semantics

3308	Min_Decl	'static %s()' has been declared but no definition has been provided. This is redundant.

3309	Maj_Switch	The value of the controlling expression in this 'switch' statement is constant.

3311   RULE001_2             [u] An earlier jump to this statement will bypass the initialization of local variables.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

3312   RULE001_2             [u] This goto statement will jump into a previous block and bypass the initialization of local variables.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

3313   Min_Decl             No definition has been found for structure/union tag '%s'.\\
MISRA-C:2004 Rule 18.1; REFERENCE - ISO:C90-6.5.2.3 Tags

3314	Maj_Ctrl	This controlling expression is an assignment.

3315   RULE015_5             This 'switch' statement contains only a single path - it is redundant.\\
MISRA-C:2004 Rule 15.5; REFERENCE - ISO:C90-6.6.4.2 The switch Statement

3317   RULE19_17             '#if...' not matched by '#endif' in included file. This is probably an error.\\
MISRA-C:2004 Rule 19.17

3318   RULE19_17             '#else'/'#elif'/'#endif' in included file matched '#if...' in parent file. This is probably an error.\\
MISRA-C:2004 Rule 19.17

3319   RULE016_6             [U] Function called with number of arguments which differs from number of parameters in definition.\\
MISRA-C:2004 Rule 16.6; REFERENCE - ISO:C90-6.3.2.2 Function Calls

3320   RULE008_3             Type of argument no. %s differs from its type in definition of function.\\
MISRA-C:2004 Rule 8.3; REFERENCE - ISO:C90-6.3.2.2 Function Calls

3321   RULE009_1             [U] The variable '%s' is definitely unset at this point.\\
MISRA-C:2004 Rule 9.1; REFERENCE - ISO:C90-6.5.7 Initialization
* obsolete, replaced by 2961, shall be deactived in personality

3322   RULE012_6             Operand of a logical ! operator is a constant expression which is not a 'Boolean' value.\\
MISRA-C:2004 Rule 12.6

3325   RULE014_1             This controlling expression has a constant 'false' value.\\
MISRA-C:2004 Rule 14.1
* obsolete, replaced by 2742/2744, shall be deactived in personality

3326   RULE013_1             The result of an assignment is being used in a logical operation.\\
MISRA-C:2004 Rule 13.1

3328	Maj_Operations	An unsigned value is being compared with a negative constant - this is dangerous.

3330	Min_Func	'%s()' has been called with a variable number of arguments.\\
REFERENCE - ISO:C90-6.3.2.2 Function Calls
* shall be deactivated in personality

3332   RULE19_11             The macro '%s' used in this '#if' or '#elif' expression is not defined.\\
MISRA-C:2004 Rule 19.11

3333	Maj_Ctrl	A 'break' statement has been used in the middle of a 'switch' 'case'/'default' clause.

3334   RULE005_2             This declaration of '%s' hides a more global declaration.\\
MISRA-C:2004 Rule 5.2

3335   RULE008_1             No function declaration. Implicit declaration inserted: 'extern int %s();'.\\
MISRA-C:2004 Rule 8.1; REFERENCE - ISO:C90-6.3.2.2 Function Calls - Semantics

3337	Maj_Decl	The array '%s[]' is defined with a single element because no size has been specified.\\
REFERENCE - ISO:C90-6.7.2-TC1 External Object Definitions

3340   RULE013_4             Floating point variable used as 'for' loop control variable.\\
MISRA-C:2004 Rule 13.4

3341   RULE013_3             Comparing floating point expressions for equality (with '==' or '!=').\\
MISRA-C:2004 Rule 13.3

3342   RULE013_4             Controlling expression of 'for' loop is a floating point comparison.\\
MISRA-C:2004 Rule 13.4

3343	Maj_Operations	Logical NOT being performed on one operand of a comparison.\\

3344   RULE013_2             Controlling expression is not an 'effectively Boolean' expression.\\
MISRA-C:2004 Rule 13.2

3345	Min_Side	Statement contains more than one access to objects that are volatile.\\
REFERENCE - ISO:C90-5.1.2.3 Program Execution
* shall be deactivated in personality

* obsolete, replaced by 2741: 3346	ODF_Invariant	The controlling expression in this 'if' statement has a constant 'true' value.

* obsolete, replaced by 2962: 3347   RULE009_1             [U] The variable '%s' is apparently unset at this point.\\
* MISRA-C:2004 Rule 9.1; REFERENCE - ISO:C90-6.5.7 Initialization

* obsolete, replaced by 2971: 3348   RULE009_1             Definite use of unset pointer as an argument to a function which expects a read-only pointer.\\
* MISRA-C:2004 Rule 9.1; REFERENCE - ISO:C90-6.5.7 Initialization

* obsolete, replaced by 2972: 3349   RULE009_1             Apparent use of unset pointer as an argument to a function which expects a read-only pointer.\\
* MISRA-C:2004 Rule 9.1; REFERENCE - ISO:C90-6.5.7 Initialization

3352	Min_Switch	This 'switch' statement contains only two execution paths.\\
REFERENCE - ISO:C90-6.6.4.2 The switch Statement

* obsolete, replaced by 2963: 3353   RULE009_1             The variable '%s' is possibly unset at this point.\\
* MISRA-C:2004 Rule 9.1

* obsolete, replaced by 2973: 3354   RULE009_1             Possible use of unset pointer as an argument to a function which expects a read-only pointer.\\
* MISRA-C:2004 Rule 9.1; REFERENCE - ISO:C90-6.5.7 Initialization

* obsolete, replaced by 2995: 3355   RULE013_7             The result of this logical operation is always 'true'.\\
* MISRA-C:2004 Rule 13.7

* obsolete, replaced by 2996: 3356   RULE013_7             The result of this logical operation is always 'false'.\\
* MISRA-C:2004 Rule 13.7

* obsolete, replaced by 2990: 3357   RULE013_7             The value of this loop controlling expression is always 'true'.\\
* MISRA-C:2004 Rule 13.7

* obsolete, replaced by 2991: 3358   RULE013_7             The value of this 'if' controlling expression is always 'true'.\\
* MISRA-C:2004 Rule 13.7

* obsolete, replaced by 2992: 3359   RULE013_7             The value of this controlling expression is always 'false'.\\
* MISRA-C:2004 Rule 13.7

* obsolete, replaced by 2993: 3360   RULE013_7             The value of this 'do - while' controlling expression is always 'false'. The loop will only be executed once.\\
* MISRA-C:2004 Rule 13.7

* obsolete, replaced by 2911: 3372   RULE021_1             Definite wraparound past zero in an unsigned arithmetic operation.\\
* MISRA-C:2004 Rule 21.1

3377   RULE012_6             Operand of a logical && or || operator is a constant expression which is not a 'Boolean' value.\\
MISRA-C:2004 Rule 12.6

* obsolete, replaced by 2912: 3382   RULE021_1             Apparent wraparound past zero in an unsigned arithmetic operation.\\
* MISRA-C:2004 Rule 21.1

3389   RULE012_1             Extra parentheses recommended to clarify the ordering of a % operator and another arithmetic operator (* / % + -).\\
MISRA-C:2004 Rule 12.1

3391   RULE012_1             Extra parentheses recommended. A conditional operation is the operand of another conditional operator.\\
MISRA-C:2004 Rule 12.1

3392   RULE012_1             Extra parentheses recommended. A shift, relational or equality operation is the operand of a second identical operator.\\
MISRA-C:2004 Rule 12.1

3393   RULE012_1             Extra parentheses recommended. An arithmetic operation (* / + -) is the operand of a different operator with the same precedence.\\
MISRA-C:2004 Rule 12.1

3394   RULE012_1             Extra parentheses recommended. A shift, relational or equality operation is the operand of a different operator with the same precedence.\\
MISRA-C:2004 Rule 12.1

3395   RULE012_1             Extra parentheses recommended. A * or / operation is the operand of a + or - operator.\\
MISRA-C:2004 Rule 12.1

3396   RULE012_1             Extra parentheses recommended. A binary operation is the operand of a conditional operator.\\
MISRA-C:2004 Rule 12.1

3397   RULE012_1             Extra parentheses recommended. A binary operation is the operand of a binary operator with different precedence.\\
MISRA-C:2004 Rule 12.1

3398   RULE012_5             Extra parentheses recommended. A function call, array subscript, or member operation is the operand of a logical && or ||.\\
MISRA-C:2004 Rule 12.5

3399   RULE012_5             Extra parentheses recommended. A unary operation is the operand of a logical && or ||.\\
MISRA-C:2004 Rule 12.5

3400   RULE012_5             Extra parentheses recommended. A binary operation is the operand of a logical && or ||.\\
MISRA-C:2004 Rule 12.5

3402   RULE014_9             Braces are needed to clarify the structure of this 'if'-'if'-'else' statement.\\
MISRA-C:2004 Rule 14.9; REFERENCE - ISO:C90-6.6.4.1 The if statement - Semantics

3403	Min_Read	This sequence of operators is difficult to read without intervening spaces.

3404	Maj_Redun	Statement contains a redundant * operator at top level. *p++ means *(p++) not (*p)++.

3405	Cri_Decl	Index[Array] is equivalent to Array[Index] but more confusing.

3406   RULE008_5             Object/function '%s', with external linkage, has been defined in a header file.\\
MISRA-C:2004 Rule 8.5

3407	Maj_Pointers	String literal compared using a relational or equality operator.

3408   RULE008_8             '%s' has external linkage and is being defined without any previous declaration.\\
MISRA-C:2004 Rule 8.8

3409   RULE019_4             The replacement list of function-like macro '%s' is not enclosed in ().\\
MISRA-C:2004 Rule 19.4; REFERENCE - ISO:C90-6.8 Preprocessing Directives

3410   RULE19_10             Macro parameter not enclosed in ().\\
MISRA-C:2004 Rule 19.10

3411   RULE019_4             Macro defined with unbalanced brackets, parentheses or braces.\\
MISRA-C:2004 Rule 19.4

3412   RULE019_4             Macro defines an unrecognized code-fragment.\\
MISRA-C:2004 Rule 19.4

3413   RULE019_4             Macro definition could be replaced by a typedef.\\
MISRA-C:2004 Rule 19.4; REFERENCE - ISO:C90-6.5.6 Type Definitions

3414	Maj_MacroDefs	Macro defines a storage-class or function specifier keyword.

3415   RULE012_4             Right hand operand of '&&' or '||' is an expression with possible side effects.\\
MISRA-C:2004 Rule 12.4; REFERENCE - ISO:C90-5,1,2,3 Program Execution

3416	Maj_Side	Logical operation performed on expression with possible side effects.\\

3417   RULE12_10             The comma operator has been used outside a 'for' statement.\\
MISRA-C:2004 Rule 12.10

3418   RULE12_10             The comma operator has been used in a 'for' statement.\\
MISRA-C:2004 Rule 12.10

3419	Maj_Redun	Initialization expression of 'for' statement has no side effects.\\
REFERENCE - ISO:C90-6.6.5.3 The for Statement

3420	Maj_Redun	Increment expression of 'for' statement has no side effects.\\
REFERENCE - ISO:C90-6.6.5.3 The for Statement

3422	Maj_Redun	Statement contains a redundant operator at top level.

3423	Maj_Redun	Statement contains a redundant cast at top level.

3424	Maj_Redun	Statement contains a redundant & or | at top level.

3425   RULE014_2             One branch of this conditional operation is a redundant expression.\\
MISRA-C:2004 Rule 14.2

3426   RULE014_2             Right hand side of comma expression has no side effect and its value is not used.\\
MISRA-C:2004 Rule 14.2

3427   RULE014_2             Right hand side of logical operator has no side effect and its value is not used.\\
MISRA-C:2004 Rule 14.2

3428	Maj_MacroDefs	Macro defines a type qualifier keyword.

3429	Min_MacroDefs	A function-like macro is being defined.
* shall be deactivated in personality

3430	Maj_Prepro	Macro argument expression may require parentheses.\\
REFERENCE - ISO:C90-6.3.1 Primary Expressions

3431   RULE019_4             Macro defines an operator, a punctuator or a control statement keyword,\\
MISRA-C:2004 Rule 19.4

3436	Maj_Prepro	Macro definition hides previously declared identifier.

3437   RULE001_2             [u] The assert macro has been suppressed to call a function of that name.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.2 Diagnostics <assert.h>

3438   RULE001_2             [U] #undef'ing the assert macro to call a function of that name causes undefined behaviour.\\
MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-7.2 Diagnostics <assert.h>

3439   RULE020_1             Macro redefines a keyword.\\
MISRA-C:2004 Rule 20.1

3440   RULE12_13             Using the value resulting from a ++ or -- operation.\\
MISRA-C:2004 Rule 12.13; REFERENCE - ISO:C90-6.3.2.4 Postfix Increment and Decrement Operators, ISO:C90-6.3.3.1 Prefix Increment and Decrement Operators

3441	Min_Side	Function call argument is an expression with possible side effects.\\
REFERENCE - ISO:C90-5.1.2.3 Program Execution, ISO:C90-6.3.2.2 Function Calls - Semantics
* shall be deactivated in personality

3442	Min_Side	Operator other than & (address-of) or = (assignment) applied to a volatile object.\\
REFERENCE - ISO:C90-5.1.2.3 Program Execution
* shall be deactivated in personality

3443	Min_MacroDefs	Macro '%s' has a replacement list which appears recursive.\\
REFERENCE - ISO:C90-6.8.3.4 Rescanning and Further Replacement

3446	Maj_Side	The 2nd or 3rd operand of this conditional operator is an expression with possible side effects.

3447   RULE008_8             '%s' is being declared with external linkage but this declaration is not in a header file.\\
MISRA-C:2004 Rule 8.8

3448   RULE005_3             Declaration of typedef '%s' is not in a header file although it is used in a definition or declaration with external linkage.\\
MISRA-C:2004 Rule 5.3

3450   RULE008_1             Function '%s', with internal linkage, is being defined without a previous declaration.\\
MISRA-C:2004 Rule 8.1

3451   RULE008_8             The global identifier '%s' has been declared in more than one file.\\
MISRA-C:2004 Rule 8.8

3452   RULE019_4             The replacement list of object-like macro '%s' is not enclosed in ().\\
MISRA-C:2004 Rule 19.4

3453   RULE019_7             A function could probably be used instead of this function-like macro.\\
MISRA-C:2004 Rule 19.7

3454	Maj_Prepro	Macro argument contains an increment, decrement or assignment operator.

3455	Maj_Prepro	Macro argument contains a function call.

3456	Maj_MacroDefs	Parameter '%s' will be evaluated more than once when this macro is used.

3457	Min_MacroDefs	Macro defines a braced initializer.

3458   RULE019_4             Macro defines a braced code statement block.\\
MISRA-C:2004 Rule 19.4

3459	Min_MacroDefs	Macro defines a 'do-while-zero' construct.
* shall be deactivated in personality

3460   RULE019_4             Macro defines a type specifier keyword.\\
MISRA-C:2004 Rule 19.4

3461   RULE019_4             Macro defines a storage-class specifier/type qualifier sequence.\\
MISRA-C:2004 Rule 19.4

3470	Maj_Redun	The operand of 'sizeof' is not an expression which designates either an object or a type.\\
REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator - Semantics

3480   RULE008_5             Object/function '%s', with internal linkage, has been defined in a header file.\\
MISRA-C:2004 Rule 8.5

3491	Min_Operations	Using conditional operator in a macro.
* shall be deactivated in personality

3492	Min_Operations	Using conditional operator outside a macro.
* shall be deactivated in personality

3495	Min_Operations	Using a conditional operator in place of a selection statement.
* shall be deactivated in personality

3501	Min_Read	Absence of space between assignment operator and following unary operator may cause confusion.

3600	Min_KandR	Using the unary '+' operator.\\
REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators
* shall be deactivated in personality

3601   RULE004_2             Trigraphs (??x) are an ISO feature.\\
MISRA-C:2004 Rule 4.2; REFERENCE - ISO:C90-5.2.1.1 Trigraph Sequences

3602	Min_KandR	Using one of the keywords 'signed', 'const', 'volatile' or 'enum'.
* shall be deactivated in personality

3603	Min_KandR	Using 'extern' in the definition of a global variable.
* shall be deactivated in personality

3604	Min_KandR	Using an initializer when defining an automatic object of struct, union or array type.
* shall be deactivated in personality

3605	Min_KandR	Type of 'switch' controlling expression cannot be represented in type 'int'.\\
REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Constraints
* shall be deactivated in personality

3606	Min_KandR	This unsuffixed decimal constant has type 'long', but had type 'unsigned int' in K&R C.\\
REFERENCE - ISO:C90-6.1.3.2 Integer Constants - Semantics
* shall be deactivated in personality

3607	Min_Func	Parameter '%s' declared with function type in a K&R style function definition.\\
REFERENCE - ISO:C90-6.5.4.3 Function Declarators (including Prototypes) - Semantics
* shall be deactivated in personality

3608	Min_KandR	Using the '#elif' preprocessing directive.\\
REFERENCE - ISO:C90-6.8.1 Preprocessing Directives - Conditional Inclusion
* shall be deactivated in personality

3609	Min_KandR	Using the alert escape sequence '\\a'.\\
REFERENCE - ISO:C90-5.2.2 Character Display Semantics
* shall be deactivated in personality

3610   RULE004_1             Hexadecimal escape sequence used.\\
MISRA-C:2004 Rule 4.1

3611	Maj_Operations	Non-portable comparison of plain 'char' with negative constant.\\
REFERENCE - ISO:C90-6.1.2.5 Types

3612	Maj_Operations	Nonportable comparison of plain 'char' with zero.\\
REFERENCE - ISO:C90-6.1.2.5 Types

3613	Min_Const	Some pre-ISO compilers would treat this 8 or 9 as an octal digit.
* shall be deactivated in personality

3614	Maj_Prepro	Macro '%s' is being defined more than once without using #undef to remove the previous definition.

3615	Min_KandR	Using 'entry' as an identifier.
* shall be deactivated in personality

3616	Maj_Prepro	Character constants may have different values in preprocessor arithmetic than in actual code.

3617	Min_Array	Assignment of a struct/union by value.
* shall be deactivated in personality

3618	Min_KandR	Whitespace used after '#' at the start of this preprocessing directive.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives
* shall be deactivated in personality

3619	Min_KandR	Whitespace used before '#' at the start of this preprocessing directive.\\
REFERENCE - ISO:C90-6.8 Preprocessing Directives
* shall be deactivated in personality

3620	Maj_Decl	'register' may be illegal on array and 'struct' / 'union' types in some compilers.\\
REFERENCE - ISO:C90-6.5.1 Storage-Class Specifiers
* shall be deactivated in personality

3621	Min_Array	A bit-field is being defined as a member of a struct or union.
* shall be deactivated in personality

3623	Min_Array	Passing a struct/union by value as a function argument.
* shall be deactivated in personality

3624	Min_Array	Function returns a struct/union by value.
* shall be deactivated in personality

3625	Min_Decl	Type 'char' has been used in the declaration of an object or a function.\\
REFERENCE - ISO:C90-6.1.2.5 Types
* shall be deactivated in personality

3626	Min_Const	Double-quote character in a character constant is not preceded by a backslash character.
* shall be deactivated in personality

3627	Min_Const	Single-quote character in a string literal is not preceded by a backslash character.
* shall be deactivated in personality

3628   RULE007_1             Octal escape sequences used in a character constant or string literal.\\
MISRA-C:2004 Rule 7.1

3629   RULE12_12             Union contains member of floating type.\\
MISRA-C:2004 Rule 12.12

3631	Min_Decl	Type 'char' has been used in a cast.\\
REFERENCE - ISO:C90-6.1.2.5 Types
* shall be deactivated in personality

3632	Min_Decl	Type 'char' has been used in the declaration of a typedef.\\
REFERENCE - ISO:C90-6.1.2.5 Types
* shall be deactivated in personality

3633	Min_Decl	Type 'char' has been used in the operand of the sizeof operator.\\
REFERENCE - ISO:C90-6.1.2.5 Types
* shall be deactivated in personality

3635   RULE016_9             Function identifier used as a pointer without a preceding & operator.\\
MISRA-C:2004 Rule 16.9; REFERENCE - ISO:C90-6.2,2,1 Lvalues and Function Designators

3650	Maj_Decl	Typedef defines an array type of unknown size.

3651	Maj_Decl	Using a typedef for an array of unknown size can lead to unexpected results.

3659   RULE006_5             Unnamed zero-width bit-field declared with a signed type.\\
MISRA-C:2004 Rule 6.5; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

3660   RULE006_5             Named bit-field consisting of a single bit declared with a signed type.\\
MISRA-C:2004 Rule 6.5; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

3661	Min_Array	Plain int bit-field compared with zero.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics
* shall be deactivated in personality

3662	Maj_Array	Plain int bit-field compared with negative constant.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

3663	Maj_Array	Unnamed bit-field defined with non-zero width.\\
REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

3664   RULE001_1             [E] Using a dot operator to access an individual bit is a language extension.\\
MISRA-C:2004 Rule 1.1

3665   RULE006_5             Unnamed bit-field consisting of a single bit declared with a signed type.\\
MISRA-C:2004 Rule 6.5; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

3670   RULE016_2             Recursive call to function containing this call.\\
MISRA-C:2004 Rule 16.2

3671	Min_Func	Function called via pointer to function.
* shall be deactivated in personality

3672	Min_Func	Using non-const pointer to function.
* shall be deactivated in personality

3673   RULE016_7             The object addressed by the pointer parameter '%s' is not modified and so the pointer could be of type 'pointer to const'.\\
MISRA-C:2004 Rule 16.7

3674	Min_Array	Array size defined implicitly by the number of initializers.\\
REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

3675   RULE008_3             Function parameter declared with type qualification which differs from previous declaration.\\
MISRA-C:2004 Rule 8.3

*obsolete, replaced by 2840:3680   RULE001_2             [U] Access outside bounds of array using a constant array subscript.\\
*MISRA-C:2004 Rule 1.2; REFERENCE - ISO:C90-6.3.6 Additive Operators, Semantics

3684   RULE08_12             Array declared with unknown size.\\
MISRA-C:2004 Rule 8.12

*3685   RULE021_1             [U] Definite access outside bounds of array.\\
*MISRA-C:2004 Rule 21.1; REFERENCE - ISO:C90-6.3.6 Additive Operators, Semantics

*3689   RULE021_1             [U] Apparent access outside bounds of array.\\
*MISRA-C:2004 Rule 21.1; REFERENCE - ISO:C90-6.3.6 Additive Operators, Semantics

*3700   RULE006_2             Implicit conversion: char to signed char.\\
*MISRA-C:2004 Rule 6.2

*3701   RULE006_2             Implicit conversion: char to unsigned char.\\
*MISRA-C:2004 Rule 6.2

*3702   RULE003_1             Implicit conversion: char to short.\\
*MISRA-C:2004 Rule 3.1

*3703   RULE003_1             Implicit conversion: char to unsigned short.\\
*MISRA-C:2004 Rule 3.1

*3704   RULE003_1             Implicit conversion: char to int.\\
*MISRA-C:2004 Rule 3.1

*3705   RULE003_1             Implicit conversion: char to unsigned int.\\
*MISRA-C:2004 Rule 3.1

*3706   RULE003_1             Implicit conversion: char to long.\\
*MISRA-C:2004 Rule 3.1

*3707   RULE003_1             Implicit conversion: char to unsigned long.\\
*MISRA-C:2004 Rule 3.1

*3708   RULE010_1             Implicit conversion: char to float.\\
*MISRA-C:2004 Rule 10.1

*3709   RULE010_1             Implicit conversion: char to double.\\
*MISRA-C:2004 Rule 10.1

*3710   RULE010_1             Implicit conversion: char to long double.\\
*MISRA-C:2004 Rule 10.1

*3711   RULE006_1             Implicit conversion: unsigned char to char.\\
*MISRA-C:2004 Rule 6.1

*3712   RULE010_1             Implicit conversion: unsigned char to signed char.\\
*MISRA-C:2004 Rule 10.1

*3713   RULE010_1             Implicit conversion: unsigned char to short.\\
*MISRA-C:2004 Rule 10.1

*3715   RULE010_1             Implicit conversion: unsigned char to int.\\
*MISRA-C:2004 Rule 10.1

*3717   RULE010_1             Implicit conversion: unsigned char to long.\\
*MISRA-C:2004 Rule 10.1

*3719   RULE010_1             Implicit conversion: unsigned char to float.\\
*MISRA-C:2004 Rule 10.1

*3720   RULE010_1             Implicit conversion: unsigned char to double.\\
*MISRA-C:2004 Rule 10.1

*3721   RULE010_1             Implicit conversion: unsigned char to long double.\\
*MISRA-C:2004 Rule 10.1

*3722   RULE006_1             Implicit conversion: signed char to char.\\
*MISRA-C:2004 Rule 6.1

*3723   RULE010_1             Implicit conversion: signed char to unsigned char.\\
*MISRA-C:2004 Rule 10.1

*3725   RULE010_1             Implicit conversion: signed char to unsigned short.\\
*MISRA-C:2004 Rule 10.1

*3727   RULE010_1             Implicit conversion: signed char to unsigned int.\\
*MISRA-C:2004 Rule 10.1

*3729   RULE010_1             Implicit conversion: signed char to unsigned long.\\
*MISRA-C:2004 Rule 10.1

*3730   RULE010_1             Implicit conversion: signed char to float.\\
*MISRA-C:2004 Rule 10.1

*3731   RULE010_1             Implicit conversion: signed char to double.\\
*MISRA-C:2004 Rule 10.1

*3732   RULE010_1             Implicit conversion: signed char to long double.\\
*MISRA-C:2004 Rule 10.1

*3733   RULE006_1             Implicit conversion: short to char.\\
*MISRA-C:2004 Rule 6.1

*3734   RULE010_1             Implicit conversion: short to signed char.\\
*MISRA-C:2004 Rule 10.1

*3735   RULE010_1             Implicit conversion: short to unsigned char.\\
*MISRA-C:2004 Rule 10.1

*3736   RULE010_1             Implicit conversion: short to unsigned short.\\
*MISRA-C:2004 Rule 10.1

*3738   RULE010_1             Implicit conversion: short to unsigned int.\\
*MISRA-C:2004 Rule 10.1

*3740   RULE010_1             Implicit conversion: short to unsigned long.\\
*MISRA-C:2004 Rule 10.1

*3741   RULE010_1             Implicit conversion: short to float.\\
*MISRA-C:2004 Rule 10.1

*3742   RULE010_1             Implicit conversion: short to double.\\
*MISRA-C:2004 Rule 10.1

*3743   RULE010_1             Implicit conversion: short to long double.\\
*MISRA-C:2004 Rule 10.1

*3744   RULE006_1             Implicit conversion: unsigned short to char.\\
*MISRA-C:2004 Rule 6.1

*3745   RULE010_1             Implicit conversion: unsigned short to signed char.\\
*MISRA-C:2004 Rule 10.1

*3746   RULE010_1             Implicit conversion: unsigned short to unsigned char.\\
*MISRA-C:2004 Rule 10.1

*3747   RULE010_1             Implicit conversion: unsigned short to short.\\
*MISRA-C:2004 Rule 10.1

*3748   RULE010_1             Implicit conversion: unsigned short to int.\\
*MISRA-C:2004 Rule 10.1

*3750   RULE010_1             Implicit conversion: unsigned short to long.\\
*MISRA-C:2004 Rule 10.1

*3752   RULE010_1             Implicit conversion: unsigned short to float.\\
*MISRA-C:2004 Rule 10.1

*3753   RULE010_1             Implicit conversion: unsigned short to double.\\
*MISRA-C:2004 Rule 10.1

*3754   RULE010_1             Implicit conversion: unsigned short to long double.\\
*MISRA-C:2004 Rule 10.1

*3755   RULE006_1             Implicit conversion: int to char.\\
*MISRA-C:2004 Rule 6.1

*3756   RULE010_1             Implicit conversion: int to signed char.\\
*MISRA-C:2004 Rule 10.1

*3757   RULE010_1             Implicit conversion: int to unsigned char.\\
*MISRA-C:2004 Rule 10.1

*3758   RULE010_1             Implicit conversion: int to short.\\
*MISRA-C:2004 Rule 10.1

*3759   RULE010_1             Implicit conversion: int to unsigned short.\\
*MISRA-C:2004 Rule 10.1

*3760   RULE010_1             Implicit conversion: int to unsigned int.\\
*MISRA-C:2004 Rule 10.1

*3762   RULE010_1             Implicit conversion: int to unsigned long.\\
*MISRA-C:2004 Rule 10.1

*3763   RULE010_1             Implicit conversion: int to float.\\
*MISRA-C:2004 Rule 10.1

*3764   RULE010_1             Implicit conversion: int to double.\\
*MISRA-C:2004 Rule 10.1

*3765   RULE010_1             Implicit conversion: int to long double.\\
*MISRA-C:2004 Rule 10.1

*3766   RULE006_1             Implicit conversion: unsigned int to char.\\
*MISRA-C:2004 Rule 6.1

*3767   RULE010_1             Implicit conversion: unsigned int to signed char.\\
*MISRA-C:2004 Rule 10.1

*3768   RULE010_1             Implicit conversion: unsigned int to unsigned char.\\
*MISRA-C:2004 Rule 10.1

*3769   RULE010_1             Implicit conversion: unsigned int to short.\\
*MISRA-C:2004 Rule 10.1

*3770   RULE010_1             Implicit conversion: unsigned int to unsigned short.\\
*MISRA-C:2004 Rule 10.1

*3771   RULE010_1             Implicit conversion: unsigned int to int.\\
*MISRA-C:2004 Rule 10.1

*3772   RULE010_1             Implicit conversion: unsigned int to long.\\
*MISRA-C:2004 Rule 10.1

*3774   RULE010_1             Implicit conversion: unsigned int to float.\\
*MISRA-C:2004 Rule 10.1

*3775   RULE010_1             Implicit conversion: unsigned int to double.\\
*MISRA-C:2004 Rule 10.1

*3776   RULE010_1             Implicit conversion: unsigned int to long double.\\
*MISRA-C:2004 Rule 10.1

*3777   RULE006_1             Implicit conversion: long to char.\\
*MISRA-C:2004 Rule 6.1

*3778   RULE010_1             Implicit conversion: long to signed char.\\
*MISRA-C:2004 Rule 10.1

*3779   RULE010_1             Implicit conversion: long to unsigned char.\\
*MISRA-C:2004 Rule 10.1

*3780   RULE010_1             Implicit conversion: long to short.\\
*MISRA-C:2004 Rule 10.1

*3781   RULE010_1             Implicit conversion: long to unsigned short.\\
*MISRA-C:2004 Rule 10.1

*3782   RULE010_1             Implicit conversion: long to int.\\
*MISRA-C:2004 Rule 10.1

*3783   RULE010_1             Implicit conversion: long to unsigned int.\\
*MISRA-C:2004 Rule 10.1

*3784   RULE010_1             Implicit conversion: long to unsigned long.\\
*MISRA-C:2004 Rule 10.1

*3785   RULE010_1             Implicit conversion: long to float.\\
*MISRA-C:2004 Rule 10.1

*3786   RULE010_1             Implicit conversion: long to double.\\
*MISRA-C:2004 Rule 10.1

*3787   RULE010_1             Implicit conversion: long to long double.\\
*MISRA-C:2004 Rule 10.1

*3788   RULE006_1             Implicit conversion: unsigned long to char.\\
*MISRA-C:2004 Rule 6.1

*3789   RULE010_1             Implicit conversion: unsigned long to signed char.\\
*MISRA-C:2004 Rule 10.1

*3790   RULE010_1             Implicit conversion: unsigned long to unsigned char.\\
*MISRA-C:2004 Rule 10.1

*3791   RULE010_1             Implicit conversion: unsigned long to short.\\
*MISRA-C:2004 Rule 10.1

*3792   RULE010_1             Implicit conversion: unsigned long to unsigned short.\\
*MISRA-C:2004 Rule 10.1

*3793   RULE010_1             Implicit conversion: unsigned long to int.\\
*MISRA-C:2004 Rule 10.1

*3794   RULE010_1             Implicit conversion: unsigned long to unsigned int.\\
*MISRA-C:2004 Rule 10.1

*3795   RULE010_1             Implicit conversion: unsigned long to long.\\
*MISRA-C:2004 Rule 10.1

*3796   RULE010_1             Implicit conversion: unsigned long to float.\\
*MISRA-C:2004 Rule 10.1

*3797   RULE010_1             Implicit conversion: unsigned long to double.\\
*MISRA-C:2004 Rule 10.1

*3798   RULE010_1             Implicit conversion: unsigned long to long double.\\
*MISRA-C:2004 Rule 10.1

*3799   RULE010_2             Implicit conversion: float to char.\\
*MISRA-C:2004 Rule 10.2

*3800   RULE010_2             Implicit conversion: float to signed char.\\
*MISRA-C:2004 Rule 10.2

*3801   RULE010_2             Implicit conversion: float to unsigned char.\\
*MISRA-C:2004 Rule 10.2

*3802   RULE010_2             Implicit conversion: float to short.\\
*MISRA-C:2004 Rule 10.2

*3803   RULE010_2             Implicit conversion: float to unsigned short.\\
*MISRA-C:2004 Rule 10.2

*3804   RULE010_2             Implicit conversion: float to int.\\
*MISRA-C:2004 Rule 10.2

*3805   RULE010_2             Implicit conversion: float to unsigned int.\\
*MISRA-C:2004 Rule 10.2

*3806   RULE010_2             Implicit conversion: float to long.\\
*MISRA-C:2004 Rule 10.2

*3807   RULE010_2             Implicit conversion: float to unsigned long.\\
*MISRA-C:2004 Rule 10.2

*3810   RULE010_2             Implicit conversion: double to char.\\
*MISRA-C:2004 Rule 10.2

*3811   RULE010_2             Implicit conversion: double to signed char.\\
*MISRA-C:2004 Rule 10.2

*3812   RULE010_2             Implicit conversion: double to unsigned char.\\
*MISRA-C:2004 Rule 10.2

*3813   RULE010_2             Implicit conversion: double to short.\\
*MISRA-C:2004 Rule 10.2

*3814   RULE010_2             Implicit conversion: double to unsigned short.\\
*MISRA-C:2004 Rule 10.2

*3815   RULE010_2             Implicit conversion: double to int.\\
*MISRA-C:2004 Rule 10.2

*3816   RULE010_2             Implicit conversion: double to unsigned int.\\
*MISRA-C:2004 Rule 10.2

*3817   RULE010_2             Implicit conversion: double to long.\\
*MISRA-C:2004 Rule 10.2

*3818   RULE010_2             Implicit conversion: double to unsigned long.\\
*MISRA-C:2004 Rule 10.2

*3819   RULE010_2             Implicit conversion: double to float.\\
*MISRA-C:2004 Rule 10.2

*3821   RULE010_2             Implicit conversion: long double to char.\\
*MISRA-C:2004 Rule 10.2

*3822   RULE010_2             Implicit conversion: long double to signed char.\\
*MISRA-C:2004 Rule 10.2

*3823   RULE010_2             Implicit conversion: long double to unsigned char.\\
*MISRA-C:2004 Rule 10.2

*3824   RULE010_2             Implicit conversion: long double to short.\\
*MISRA-C:2004 Rule 10.2

*3825   RULE010_2             Implicit conversion: long double to unsigned short .\\
*MISRA-C:2004 Rule 10.2

*3826   RULE010_2             Implicit conversion: long double to int.\\
*MISRA-C:2004 Rule 10.2

*3827   RULE010_2             Implicit conversion: long double to unsigned int.\\
*MISRA-C:2004 Rule 10.2

*3828   RULE010_2             Implicit conversion: long double to long.\\
*MISRA-C:2004 Rule 10.2

*3829   RULE010_2             Implicit conversion: long double to unsigned long.\\
*MISRA-C:2004 Rule 10.2

*3830   RULE010_2             Implicit conversion: long double to float.\\
*MISRA-C:2004 Rule 10.2

*3831   RULE010_2             Implicit conversion: long double to double.\\
*MISRA-C:2004 Rule 10.2

*3832   RULE003_1             Implicit conversion: char to long long.\\
*MISRA-C:2004 Rule 3.1

*3833   RULE003_1             Implicit conversion: char to unsigned long long.\\
*MISRA-C:2004 Rule 3.1

*3834   RULE010_1             Implicit conversion: unsigned char to long long.\\
*MISRA-C:2004 Rule 10.1

*3837   RULE010_1             Implicit conversion: signed char to unsigned long long.\\
*MISRA-C:2004 Rule 10.1

*3839   RULE010_1             Implicit conversion: short to unsigned long long.\\
*MISRA-C:2004 Rule 10.1

*3840   RULE010_1             Implicit conversion: unsigned short to long long.\\
*MISRA-C:2004 Rule 10.1

*3843   RULE010_1             Implicit conversion: int to unsigned long long.\\
*MISRA-C:2004 Rule 10.1

*3844   RULE010_1             Implicit conversion: unsigned int to long long.\\
*MISRA-C:2004 Rule 10.1

*3847   RULE010_1             Implicit conversion: long to unsigned long long.\\
*MISRA-C:2004 Rule 10.1

*3848   RULE010_1             Implicit conversion: unsigned long to long long.\\
*MISRA-C:2004 Rule 10.1

*3850   RULE006_1             Implicit conversion: long long to char.\\
*MISRA-C:2004 Rule 6.1

*3851   RULE010_1             Implicit conversion: long long to signed char.\\
*MISRA-C:2004 Rule 10.1

*3852   RULE010_1             Implicit conversion: long long to unsigned char.\\
*MISRA-C:2004 Rule 10.1

*3853   RULE010_1             Implicit conversion: long long to short.\\
*MISRA-C:2004 Rule 10.1

*3854   RULE010_1             Implicit conversion: long long to unsigned short.\\
*MISRA-C:2004 Rule 10.1

*3855   RULE010_1             Implicit conversion: long long to int.\\
*MISRA-C:2004 Rule 10.1

*3856   RULE010_1             Implicit conversion: long long to unsigned int.\\
*MISRA-C:2004 Rule 10.1

*3857   RULE010_1             Implicit conversion: long long to long\\
*MISRA-C:2004 Rule 10.1

*3858   RULE010_1             Implicit conversion: long long to unsigned long.\\
*MISRA-C:2004 Rule 10.1

*3859   RULE010_1             Implicit conversion: long long to unsigned long long.\\
*MISRA-C:2004 Rule 10.1

*3860   RULE010_1             Implicit conversion: long long to float.\\
*MISRA-C:2004 Rule 10.1

*3861   RULE010_1             Implicit conversion: long long to double.\\
*MISRA-C:2004 Rule 10.1

*3862   RULE010_1             Implicit conversion: long long to long double.\\
*MISRA-C:2004 Rule 10.1

*3863   RULE006_1             Implicit conversion: unsigned long long to char.\\
*MISRA-C:2004 Rule 6.1

*3864   RULE010_1             Implicit conversion: unsigned long long to signed char.\\
*MISRA-C:2004 Rule 10.1

*3865   RULE010_1             Implicit conversion: unsigned long long to unsigned char.\\
*MISRA-C:2004 Rule 10.1

*3866   RULE010_1             Implicit conversion: unsigned long long to short.\\
*MISRA-C:2004 Rule 10.1

*3867   RULE010_1             Implicit conversion: unsigned long long to unsigned short.\\
*MISRA-C:2004 Rule 10.1

*3868   RULE010_1             Implicit conversion: unsigned long long to int.\\
*MISRA-C:2004 Rule 10.1

*3869   RULE010_1             Implicit conversion: unsigned long long to unsigned int.\\
*MISRA-C:2004 Rule 10.1

*3870   RULE010_1             Implicit conversion: unsigned long long to long.\\
*MISRA-C:2004 Rule 10.1

*3871   RULE010_1             Implicit conversion: unsigned long long to unsigned long.\\
*MISRA-C:2004 Rule 10.1

*3872   RULE010_1             Implicit conversion: unsigned long long to long long.\\
*MISRA-C:2004 Rule 10.1

*3873   RULE010_1             Implicit conversion: unsigned long long to float.\\
*MISRA-C:2004 Rule 10.1

*3874   RULE010_1             Implicit conversion: unsigned long long to double.\\
*MISRA-C:2004 Rule 10.1

*3875   RULE010_1             Implicit conversion: unsigned long long to long double.\\
*MISRA-C:2004 Rule 10.1

*3876   RULE010_2             Implicit conversion: float to long long.\\
*MISRA-C:2004 Rule 10.2

*3877   RULE010_2             Implicit conversion: float to unsigned long long.\\
*MISRA-C:2004 Rule 10.2

*3878   RULE010_2             Implicit conversion: double to long long.\\
*MISRA-C:2004 Rule 10.2

*3879   RULE010_2             Implicit conversion: double to unsigned long long.\\
*MISRA-C:2004 Rule 10.2

*3880   RULE010_2             Implicit conversion: long double to long long.\\
*MISRA-C:2004 Rule 10.2

*3881   RULE010_2             Implicit conversion: long double to unsigned long long.\\
*MISRA-C:2004 Rule 10.2

*3900   RULE006_2             char value returned from signed char %s().\\
*MISRA-C:2004 Rule 6.2

*3901   RULE006_2             char value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 6.2

*3902   RULE003_1             char value returned from short %s().\\
*MISRA-C:2004 Rule 3.1

*3903   RULE003_1             char value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 3.1

*3904   RULE003_1             char value returned from int %s().\\
*MISRA-C:2004 Rule 3.1

*3905   RULE003_1             char value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 3.1

*3906   RULE003_1             char value returned from long %s().\\
*MISRA-C:2004 Rule 3.1

*3907   RULE003_1             char value returned from unsigned long %s().\\
*MISRA-C:2004 Rule 3.1

*3908   RULE010_1             char value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*3909   RULE010_1             char value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*3910   RULE010_1             char value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*3911   RULE006_1             unsigned char value returned from char %s().\\
*MISRA-C:2004 Rule 6.1

*3912   RULE010_1             unsigned char value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.1

*3913   RULE010_1             unsigned char value returned from short %s().\\
*MISRA-C:2004 Rule 10.1

*3915   RULE010_1             unsigned char value returned from int %s().\\
*MISRA-C:2004 Rule 10.1

*3917   RULE010_1             unsigned char value returned from long %s().\\
*MISRA-C:2004 Rule 10.1

*3919   RULE010_1             unsigned char value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*3920   RULE010_1             unsigned char value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*3921   RULE010_1             unsigned char value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*3922   RULE006_1             signed char value returned from char %s().\\
*MISRA-C:2004 Rule 6.1

*3923   RULE010_1             signed char value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.1

*3925   RULE010_1             signed char value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.1

*3927   RULE010_1             signed char value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 10.1

*3929   RULE010_1             signed char value returned from unsigned long %s().\\
*MISRA-C:2004 Rule 10.1

*3930   RULE010_1             signed char value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*3931   RULE010_1             signed char value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*3932   RULE010_1             signed char value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*3933   RULE006_1             short value returned from char %s().\\
*MISRA-C:2004 Rule 6.1

*3934   RULE010_1             short value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.1

*3935   RULE010_1             short value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.1

*3936   RULE010_1             short value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.1

*3938   RULE010_1             short value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 10.1

*3940   RULE010_1             short value returned from unsigned long %s().\\
*MISRA-C:2004 Rule 10.1

*3941   RULE010_1             short value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*3942   RULE010_1             short value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*3943   RULE010_1             short value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*3944   RULE006_1             unsigned short value returned from char %s().\\
*MISRA-C:2004 Rule 6.1

*3945   RULE010_1             unsigned short value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.1

*3946   RULE010_1             unsigned short value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.1

*3947   RULE010_1             unsigned short value returned from short %s().\\
*MISRA-C:2004 Rule 10.1

*3948   RULE010_1             unsigned short value returned from int %s().\\
*MISRA-C:2004 Rule 10.1

*3950   RULE010_1             unsigned short value returned from long %s().\\
*MISRA-C:2004 Rule 10.1

*3952   RULE010_1             unsigned short value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*3953   RULE010_1             unsigned short value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*3954   RULE010_1             unsigned short value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*3955   RULE006_1             int value returned from char %s().\\
*MISRA-C:2004 Rule 6.1

*3956   RULE010_1             int value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.1

*3957   RULE010_1             int value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.1

*3958   RULE010_1             int value returned from short %s().\\
*MISRA-C:2004 Rule 10.1

*3959   RULE010_1             int value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.1

*3960   RULE010_1             int value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 10.1

*3962   RULE010_1             int value returned from unsigned long %s().\\
*MISRA-C:2004 Rule 10.1

*3963   RULE010_1             int value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*3964   RULE010_1             int value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*3965   RULE010_1             int value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*3966   RULE006_1             unsigned int value returned from char %s().\\
*MISRA-C:2004 Rule 6.1

*3967   RULE010_1             unsigned int value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.1

*3968   RULE010_1             unsigned int value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.1

*3969   RULE010_1             unsigned int value returned from short %s().\\
*MISRA-C:2004 Rule 10.1

*3970   RULE010_1             unsigned int value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.1

*3971   RULE010_1             unsigned int value returned from int %s().\\
*MISRA-C:2004 Rule 10.1

*3972   RULE010_1             unsigned int value returned from long %s().\\
MISRA-C:2004 Rule 10.1

*3974   RULE010_1             unsigned int value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*3975   RULE010_1             unsigned int value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*3976   RULE010_1             unsigned int value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*3977   RULE006_1             long value returned from char %s().\\
*MISRA-C:2004 Rule 6.1

*3978   RULE010_1             long value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.1

*3979   RULE010_1             long value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.1

*3980   RULE010_1             long value returned from short %s().\\
*MISRA-C:2004 Rule 10.1

*3981   RULE010_1             long value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.1

*3982   RULE010_1             long value returned from int %s().\\
*MISRA-C:2004 Rule 10.1

*3983   RULE010_1             long value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 10.1

*3984   RULE010_1             long value returned from unsigned long %s().\\
*MISRA-C:2004 Rule 10.1

*3985   RULE010_1             long value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*3986   RULE010_1             long value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*3987   RULE010_1             long value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*3988   RULE006_1             unsigned long value returned from char %s().\\
*MISRA-C:2004 Rule 6.1

*3989   RULE010_1             unsigned long value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.1

*3990   RULE010_1             unsigned long value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.1

*3991   RULE010_1             unsigned long value returned from short %s().\\
*MISRA-C:2004 Rule 10.1

*3992   RULE010_1             unsigned long value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.1

*3993   RULE010_1             unsigned long value returned from int %s().\\
*MISRA-C:2004 Rule 10.1

*3994   RULE010_1             unsigned long value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 10.1

*3995   RULE010_1             unsigned long value returned from long %s().\\
*MISRA-C:2004 Rule 10.1

*3996   RULE010_1             unsigned long value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*3997   RULE010_1             unsigned long value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*3998   RULE010_1             unsigned long value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*3999   RULE010_2             float value returned from char %s().\\
*MISRA-C:2004 Rule 10.2

*4000   RULE010_2             float value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.2

*4001   RULE010_2             float value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.2

*4002   RULE010_2             float value returned from short %s().\\
*MISRA-C:2004 Rule 10.2

*4003   RULE010_2             float value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.2

*4004   RULE010_2             float value returned from int %s().\\
*MISRA-C:2004 Rule 10.2

*4005   RULE010_2             float value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 10.2

*4006   RULE010_2             float value returned from long %s().\\
*MISRA-C:2004 Rule 10.2

*4007   RULE010_2             float value returned from unsigned long %s().\\
*MISRA-C:2004 Rule 10.2

*4010   RULE010_2             double value returned from char %s().\\
*MISRA-C:2004 Rule 10.2

*4011   RULE010_2             double value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.2

*4012   RULE010_2             double value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.2

*4013   RULE010_2             double value returned from short %s().\\
*MISRA-C:2004 Rule 10.2

*4014   RULE010_2             double value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.2

*4015   RULE010_2             double value returned from int %s().\\
*MISRA-C:2004 Rule 10.2

*4016   RULE010_2             double value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 10.2

*4017   RULE010_2             double value returned from long %s().\\
*MISRA-C:2004 Rule 10.2

*4018   RULE010_2             double value returned from unsigned long %s().\\
*MISRA-C:2004 Rule 10.2

*4019   RULE010_2             double value returned from float %s().\\
*MISRA-C:2004 Rule 10.2

*4021   RULE010_2             long double value returned from char %s().\\
*MISRA-C:2004 Rule 10.2

*4022   RULE010_2             long double value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.2

*4023   RULE010_2             long double value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.2

*4024   RULE010_2             long double value returned from short %s().\\
*MISRA-C:2004 Rule 10.2

*4025   RULE010_2             long double value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.2

*4026   RULE010_2             long double value returned from int %s().\\
*MISRA-C:2004 Rule 10.2

*4027   RULE010_2             long double value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 10.2

*4028   RULE010_2             long double value returned from long %s().\\
*MISRA-C:2004 Rule 10.2

*4029   RULE010_2             long double value returned from unsigned long %s().\\
*MISRA-C:2004 Rule 10.2

*4030   RULE010_2             long double value returned from float %s().\\
*MISRA-C:2004 Rule 10.2

*4031   RULE010_2             long double value returned from double %s().\\
*MISRA-C:2004 Rule 10.2

*4032   RULE003_1             char value returned from long long %s().\\
*MISRA-C:2004 Rule 3.1

*4033   RULE003_1             char value returned from unsigned long long %s().\\
*MISRA-C:2004 Rule 3.1

*4034   RULE010_1             unsigned char value returned from long long %s().\\
*MISRA-C:2004 Rule 10.1

*4037   RULE010_1             signed char value returned from unsigned long long %s().\\
*MISRA-C:2004 Rule 10.1

*4039   RULE010_1             short value returned from unsigned long long %s().\\
*MISRA-C:2004 Rule 10.1

*4040   RULE010_1             unsigned short value returned from long long %s().\\
*MISRA-C:2004 Rule 10.1

*4043   RULE010_1             int value returned from unsigned long long %s().\\
*MISRA-C:2004 Rule 10.1

*4044   RULE010_1             unsigned int value returned from long long %s().\\
*MISRA-C:2004 Rule 10.1

*4047   RULE010_1             long value returned from unsigned long long %s().\\
*MISRA-C:2004 Rule 10.1

*4048   RULE010_1             unsigned long value returned from long long %s().\\
*MISRA-C:2004 Rule 10.1

*4050   RULE006_1             long long value returned from char %s().\\
*MISRA-C:2004 Rule 6.1

*4051   RULE010_1             long long value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.1

*4052   RULE010_1             long long value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.1

*4053   RULE010_1             long long value returned from short %s().\\
*MISRA-C:2004 Rule 10.1

*4054   RULE010_1             long long value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.1

*4055   RULE010_1             long long value returned from int %s().\\
*MISRA-C:2004 Rule 10.1

*4056   RULE010_1             long long value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 10.1

*4057   RULE010_1             long long value returned from long %s().\\
*MISRA-C:2004 Rule 10.1

*4058   RULE010_1             long long value returned from unsigned long %s().\\
*MISRA-C:2004 Rule 10.1

*4059   RULE010_1             long long value returned from unsigned long long %s().\\
*MISRA-C:2004 Rule 10.1

*4060   RULE010_1             long long value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*4061   RULE010_1             long long value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*4062   RULE010_1             long long value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*4063   RULE006_1             unsigned long long value returned from char %s().\\
*MISRA-C:2004 Rule 6.1

*4064   RULE010_1             unsigned long long value returned from signed char %s().\\
*MISRA-C:2004 Rule 10.1

*4065   RULE010_1             unsigned long long value returned from unsigned char %s().\\
*MISRA-C:2004 Rule 10.1

*4066   RULE010_1             unsigned long long value returned from short %s().\\
*MISRA-C:2004 Rule 10.1

*4067   RULE010_1             unsigned long long value returned from unsigned short %s().\\
*MISRA-C:2004 Rule 10.1

*4068   RULE010_1             unsigned long long value returned from int %s().\\
*MISRA-C:2004 Rule 10.1

*4069   RULE010_1             unsigned long long value returned from unsigned int %s().\\
*MISRA-C:2004 Rule 10.1

*4070   RULE010_1             unsigned long long value returned from long %s().\\
*MISRA-C:2004 Rule 10.1

*4071   RULE010_1             unsigned long long value returned from unsigned long %s().\\
*MISRA-C:2004 Rule 10.1

*4072   RULE010_1             unsigned long long value returned from long long %s().\\
*MISRA-C:2004 Rule 10.1

*4073   RULE010_1             unsigned long long value returned from float %s().\\
*MISRA-C:2004 Rule 10.1

*4074   RULE010_1             unsigned long long value returned from double %s().\\
*MISRA-C:2004 Rule 10.1

*4075   RULE010_1             unsigned long long value returned from long double %s().\\
*MISRA-C:2004 Rule 10.1

*4076   RULE010_2             float value returned from long long %s().\\
*MISRA-C:2004 Rule 10.2

*4077   RULE010_2             float value returned from unsigned long long %s().\\
*MISRA-C:2004 Rule 10.2

*4078   RULE010_2             double value returned from long long %s().\\
*MISRA-C:2004 Rule 10.2

*4079   RULE010_2             double value returned from unsigned long long %s().\\
*MISRA-C:2004 Rule 10.2

*4080   RULE010_2             long double value returned from long long %s().\\
*MISRA-C:2004 Rule 10.2

*4081   RULE010_2             long double value returned from unsigned long long %s().\\
*MISRA-C:2004 Rule 10.2

4100	Config	Illegal user error number %1s

4101   RULE012_6             Both operands of & operator are 'Boolean' expressions.\\
MISRA-C:2004 Rule 12.6; REFERENCE - ISO:C90-6.3.10 Bitwise AND Operator

4102   RULE012_6             Both operands of | operator are 'Boolean' expressions.\\
MISRA-C:2004 Rule 12.6; REFERENCE - ISO:C90-6.3.12 Bitwise Inclusive OR Operator

4103   RULE012_6             Both operands of arithmetic or bitwise operator are 'Boolean' expressions.\\
MISRA-C:2004 Rule 12.6

4104   RULE012_6             Left hand operand of arithmetic or bitwise operator is a 'Boolean' expression.\\
MISRA-C:2004 Rule 12.6

4105   RULE012_6             Right hand operand of arithmetic or bitwise operator is a 'Boolean' expression.\\
MISRA-C:2004 Rule 12.6

4106   RULE012_6             Both operands of && operator are arithmetic or bitwise expressions.\\
MISRA-C:2004 Rule 12.6; REFERENCE - ISO:C90-6.3.13 Logical AND Operator

4107   RULE012_6             Both operands of || operator are arithmetic or bitwise expressions.\\
MISRA-C:2004 Rule 12.6; REFERENCE - ISO:C90-6.3.14 Logical OR Operator

4108   RULE012_6             Left hand operand of logical operator is an arithmetic or bitwise expression.\\
MISRA-C:2004 Rule 12.6

4109   RULE012_6             Right hand operand of logical operator is an arithmetic or bitwise expression.\\
MISRA-C:2004 Rule 12.6

4110   RULE012_6             Operand of ! operator is an arithmetic or bitwise expression.\\
MISRA-C:2004 Rule 12.6; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators

4111   RULE012_6             Right hand operand of relational operator is a 'Boolean' expression.\\
MISRA-C:2004 Rule 12.6

4112   RULE012_6             Left hand operand of relational operator is a 'Boolean' expression.\\
MISRA-C:2004 Rule 12.6; REFERENCE - ISO:C90-6.3.8 Relational Operators

4113   RULE012_6             Both operands of relational operator are 'Boolean' expressions.\\
MISRA-C:2004 Rule 12.6; REFERENCE - ISO:C90-6.3.8 Relational Operators

4114   RULE012_6             Operand of ~ operator is a 'Boolean' expression.\\
MISRA-C:2004 Rule 12.6; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators

4115   RULE012_6             Operand of logical && or || operator is not an 'effectively Boolean' expression.\\
MISRA-C:2004 Rule 12.6; REFERENCE - ISO:C90-6.3.13 Logical AND Operator, ISO:C90-6.3.14 Logical OR Operator

4116   RULE012_6             Operand of logical ! operator is not an 'effectively Boolean' expression.\\
MISRA-C:2004 Rule 12.6; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators

4117	RULE010_1	Result of integer division operation implicitly converted to a floating type.

4118	Maj_Operations	Result of integer division operation cast to a floating type.
* shall be deactivated in the personality

4119	Maj_Operations	Result of floating point operation cast to an integral type.\\
* shall be deactivated in the personality

*4120   RULE010_1             Implicit conversion: complex expression of integral type to wider type.\\
*MISRA-C:2004 Rule 10.1

*4121   RULE010_3             Cast of complex expression of integral type to wider type.\\
*MISRA-C:2004 Rule 10.3

*4123   RULE010_2             Implicit conversion: complex expression of type float to type double.\\
*MISRA-C:2004 Rule 10.2

*4124   RULE010_2             Implicit conversion: complex expression of type float to type long double.\\
*MISRA-C:2004 Rule 10.2

*4125   RULE010_2             Implicit conversion: complex expression of type double to type long double.\\
*MISRA-C:2004 Rule 10.2

*4126   RULE010_4             Cast of complex expression of type float to type double.\\
*MISRA-C:2004 Rule 10.4

*4127   RULE010_4             Cast of complex expression of type float to type long double.\\
*MISRA-C:2004 Rule 10.4

*4128   RULE010_4             Cast of complex expression of type double to type long double.\\
*MISRA-C:2004 Rule 10.4

*4130   RULE012_7             Bitwise operations on signed data will give implementation defined results.\\
*MISRA-C:2004 Rule 12.7; REFERENCE - ISO:C90-6.3 Expressions

*4131   RULE012_7             Left shift operation on signed operand.\\
*MISRA-C:2004 Rule 12.7

4139	Maj_Pointers	Address of local static object exported in function return value.

4140   RULE017_6             Address of automatic object exported in function return value.\\
MISRA-C:2004 Rule 17.6; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

4150	Min_Ident	The identifier '%s' may cause confusion because it contains only the letter 'l' and and the number '1'.

4151	Min_Ident	The identifier '%s' may cause confusion because it contains only the letter 'O' and the number '0'.

4152	Min_Ident	The identifier '%s' may cause confusion because the letter 'l' and the number '1' are adjacent.

4153	Min_Ident	The identifier '%s' may cause confusion because the letter 'O' and the number '0' are adjacent.

4301	Maj_Casts	An expression of 'essentially Boolean' type (%1s) is being cast to character type '%2s'.

4302	Maj_Casts	An expression of 'essentially Boolean' type (%1s) is being cast to enum type '%2s'.

4303	Maj_Casts	An expression of 'essentially Boolean' type (%1s) is being cast to signed type '%2s'.

4304	Maj_Casts	An expression of 'essentially Boolean' type (%1s) is being cast to unsigned type '%2s'.

4305	Maj_Casts	An expression of 'essentially Boolean' type (%1s) is being cast to floating type '%2s'.

4310	Maj_Casts	An expression of 'essentially character' type (%1s) is being cast to Boolean type, '%2s'.

4312	Maj_Casts	An expression of 'essentially character' type (%1s) is being cast to enum type, '%2s'.

4315	Maj_Casts	An expression of 'essentially character' type (%1s) is being cast to floating type, '%2s'.

4320	Maj_Casts	An expression of 'essentially enum' type (%1s) is being cast to Boolean type, '%2s'.

4322	Maj_Casts	An expression of 'essentially enum' type (%1s) is being cast to a different enum type, '%2s'.

4325	Maj_Casts	An expression of 'essentially enum' type (%1s) is being cast to floating type, '%2s'.

4330	Maj_Casts	An expression of 'essentially signed' type (%1s) is being cast to Boolean type '%2s'.

4332	Maj_Casts	An expression of 'essentially signed' type (%1s) is being cast to enum type, '%2s'.

4340	Maj_Casts	An expression of 'essentially unsigned' type (%1s) is being cast to Boolean type '%2s'.

4342	Maj_Casts	An expression of 'essentially unsigned' type (%1s) is being cast to enum type '%2s'.

4350	Maj_Casts	An expression of 'essentially floating' type (%1s) is being cast to Boolean type '%2s'.

4351	Maj_Casts	An expression of 'essentially floating' type (%1s) is being cast to character type '%2s'.

4352	Maj_Casts	An expression of 'essentially floating' type (%1s) is being cast to enum type, '%2s'.

4390	RULE010_3	A composite expression of 'essentially signed' type (%1s) is being cast to a wider signed type, '%2s'.

4391	RULE010_3	A composite expression of 'essentially unsigned' type (%1s) is being cast to a wider unsigned type, '%2s'.

4392	RULE010_4	A composite expression of 'essentially floating' type (%1s) is being cast to a wider floating type, '%2s'.

4393	RULE010_3	A composite expression of 'essentially signed' type (%1s) is being cast to a different type category, '%2s'.

4394	RULE010_3	A composite expression of 'essentially unsigned' type (%1s) is being cast to a different type category, '%2s'.

4395	RULE010_4	A composite expression of 'essentially floating' type (%1s) is being cast to a different type category, '%2s'.

4397	RULE010_5	An expression which is the result of a ~ or << operation has not been cast to its essential type.

4398	RULE010_5	An expression which is the result of a ~ or << operation has been cast to a different essential type category.

4399	RULE010_5	An expression which is the result of a ~ or << operation has been cast to a wider type.

4401	RULE006_1	An expression of 'essentially Boolean' type (%1s) is being converted to character type, '%2s' on assignment.

4402	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being converted to enum type, '%2s' on assignment.

4403	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being converted to signed type, '%2s' on assignment.

4404	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being converted to unsigned type, '%2s' on assignment.

4405	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being converted to floating type, '%2s' on assignment.

4410	RULE010_1	An expression of 'essentially character' type (%1s) is being converted to Boolean type, '%2s' on assignment.

4412	RULE010_1	An expression of 'essentially character' type (%1s) is being converted to enum type, '%2s' on assignment.

4413	RULE006_2	An expression of 'essentially character' type (%1s) is being converted to signed type, '%2s' on assignment.

4414	RULE010_1	An expression of 'essentially character' type (%1s) is being converted to unsigned type, '%2s' on assignment.

4415	RULE010_1	An expression of 'essentially character' type (%1s) is being converted to floating type, '%2s' on assignment.

4420	RULE010_1	An expression of 'essentially enum' type (%1s) is being converted to Boolean type, '%2s' on assignment.

4421	RULE010_1	An expression of 'essentially enum' type (%1s) is being converted to character type, '%2s' on assignment.

4422	RULE010_1	An expression of 'essentially enum' type (%1s) is being converted to a different enum type, '%2s' on assignment.

4423	RULE010_1	An expression of 'essentially enum' type (%1s) is being converted to signed type, '%2s' on assignment.

4424	RULE010_1	An expression of 'essentially enum' type (%1s) is being converted to unsigned type, '%2s' on assignment.

4425	RULE010_1	An expression of 'essentially enum' type (%1s) is being converted to floating type, '%2s' on assignment.

4430	RULE010_1	An expression of 'essentially signed' type (%1s) is being converted to Boolean type, '%2s' on assignment.

4431	RULE010_1	An expression of 'essentially signed' type (%1s) is being converted to character type, '%2s' on assignment.

4432	RULE010_1	An expression of 'essentially signed' type (%1s) is being converted to enum type, '%2s' on assignment.

4434	RULE010_1	A non-constant expression of 'essentially signed' type (%1s) is being converted to unsigned type, '%2s' on assignment.

4435	RULE010_1	A non-constant expression of 'essentially signed' type (%1s) is being converted to floating type, '%2s' on assignment.

4436	RULE010_1	A constant expression of 'essentially signed' type (%1s) is being converted to unsigned type, '%2s' on assignment.

4437	RULE010_1	A constant expression of 'essentially signed' type (%1s) is being converted to floating type, '%2s' on assignment.

4440	RULE010_1	An expression of 'essentially unsigned' type (%1s) is being converted to Boolean type, '%2s' on assignment.

4441	RULE010_1	An expression of 'essentially unsigned' type (%1s) is being converted to character type, '%2s' on assignment.

4442	RULE010_1	An expression of 'essentially unsigned' type (%1s) is being converted to enum type, '%2s' on assignment.

4443	RULE010_1	A non-constant expression of 'essentially unsigned' type (%1s) is being converted to a wider signed type, '%2s' on assignment.

4445	RULE010_1	An expression of 'essentially unsigned' type (%1s) is being converted to floating type, '%2s' on assignment.

4446	RULE010_1	A non-constant expression of 'essentially unsigned' type (%1s) is being converted to signed type, '%2s' on assignment.

4447	RULE010_1	A constant expression of 'essentially unsigned' type (%1s) is being converted to signed type, '%2s' on assignment.

4450	RULE010_2	An expression of 'essentially floating' type (%1s) is being converted to Boolean type, '%2s' on assignment.

4451	RULE010_1	An expression of 'essentially floating' type (%1s) is being converted to character type, '%2s' on assignment.

4452	RULE010_2	An expression of 'essentially floating' type (%1s) is being converted to enum type, '%2s' on assignment.

4453	RULE010_2	An expression of 'essentially floating' type (%1s) is being converted to signed type, '%2s' on assignment.

4454	RULE010_2	An expression of 'essentially floating' type (%1s) is being converted to unsigned type, '%2s' on assignment.

4460	RULE010_1	A non-constant expression of 'essentially signed' type (%1s) is being converted to narrower signed type, '%2s' on assignment.

4461	RULE010_1	A non-constant expression of 'essentially unsigned' type (%1s) is being converted to narrower unsigned type, '%2s' on assignment.

4462	RULE010_2	A non-constant expression of 'essentially floating' type (%1s) is being converted to narrower floating type, '%2s' on assignment.

4463	RULE010_1	A constant expression of 'essentially signed' type (%1s) is being converted to narrower signed type, '%2s' on assignment.

4464	RULE010_1	A constant expression of 'essentially unsigned' type (%1s) is being converted to narrower unsigned type, '%2s' on assignment.

4465	RULE010_2	A constant expression of 'essentially floating' type (%1s) is being converted to narrower floating type, '%2s' on assignment.

4470	RULE010_1	A non-constant expression of 'essentially signed' type (%1s) is being passed to a function parameter of wider signed type, '%2s'.

4471	RULE010_1	A non-constant expression of 'essentially unsigned' type (%1s) is being passed to a function parameter of wider unsigned type, '%2s'.

4472	RULE010_2	A non-constant expression of 'essentially floating' type (%1s) is being passed to a function parameter of wider floating type, '%2s'.

4480	RULE010_1	A non-constant expression of 'essentially signed' type (%1s) is being returned from a function defined with a wider signed return type, '%2s'.

4481	RULE010_1	A non-constant expression of 'essentially unsigned' type (%1s) is being returned from a function defined with a wider unsigned return type, '%2s'.

4482	RULE010_2	A non-constant expression of 'essentially floating' type (%1s) is being returned from a function defined with a wider floating return type, '%2s'.

4490	RULE010_1	A composite expression of 'essentially signed' type (%1s) is being converted to wider signed type, '%2s' on assignment.

4491	RULE010_1	A composite expression of 'essentially unsigned' type (%1s) is being converted to wider unsigned type, '%2s' on assignment.

4492	RULE010_2	A composite expression of 'essentially floating' type (%1s) is being converted to wider floating type, '%2s' on assignment.

4498	RULE010_5	An expression which is the result of a ~ or << operation has been converted to a different essential type category on assignment.

4499	RULE010_5	An expression which is the result of a ~ or << operation has been converted to a wider essential type on assignment.

4500	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being used as an array subscript.

4501	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being used as the %2s operand of this arithmetic operator (%3s).

4502	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being used as the %2s operand of this bitwise operator (%3s).

4503	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being used as the left-hand operand of this shift operator (%2s).

4504	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being used as the right-hand operand of this shift operator (%2s).

4505	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being used as the %2s operand of this relational operator (%3s).

4507	RULE010_1	An expression of 'essentially Boolean' type (%1s) is being used as the operand of this increment/decrement operator (%2s).

4510	RULE006_1	An expression of 'essentially character' type (%1s) is being used as an array subscript.

4511	RULE006_1	An expression of 'essentially character' type (%1s) is being used as the %2s operand of this arithmetic operator (%3s).

4512	RULE006_1	An expression of 'essentially character' type (%1s) is being used as the %2s operand of this bitwise operator (%3s).

4513	RULE006_1	An expression of 'essentially character' type (%1s) is being used as the left-hand operand of this shift operator (%2s).

4514	RULE006_1	An expression of 'essentially character' type (%1s) is being used as the right-hand operand of this shift operator (%2s).

4517	RULE006_1	An expression of 'essentially character' type (%1s) is being used as the operand of this increment/decrement operator (%2s).

4518	RULE006_1	An expression of 'essentially character' type (%1s) is being used as the %2s operand of this logical operator (%3s).

4519	RULE006_1	An expression of 'essentially character' type (%1s) is being used as the first operand of this conditional operator (%2s).

4521	Maj_Operands	An expression of 'essentially enum' type (%1s) is being used as the %2s operand of this arithmetic operator (%3s).

4522	Maj_Operands	An expression of 'essentially enum' type (%1s) is being used as the %2s operand of this bitwise operator (%3s).

4523	Maj_Operands	An expression of 'essentially enum' type (%1s) is being used as the left-hand operand of this shift operator (%2s).

4524	Maj_Operands	An expression of 'essentially enum' type (%1s) is being used as the right-hand operand of this shift operator (%2s).

4527	Maj_Operands	An expression of 'essentially enum' type is being used as the operand of this increment/decrement operator.

4528	RULE013_2	An expression of 'essentially enum' type (%1s) is being used as the %2s operand of this logical operator (%3s).

4529	RULE013_2	An expression of 'essentially enum' type (%1s) is being used as the first operand of this conditional operator (%2s).

4532	RULE012_7	An expression of 'essentially signed' type (%1s) is being used as the %2s operand of this bitwise operator (%3s).

4533	RULE012_7	An expression of 'essentially signed' type (%1s) is being used as the left-hand operand of this shift operator (%2s).

4534	Maj_Operands	An expression of 'essentially signed' type (%1s) is being used as the right-hand operand of this shift operator (%2s).

4538	RULE013_2	An expression of 'essentially signed' type (%1s) is being used as the %2s operand of this logical operator (%3s).

4539	RULE013_2	An expression of 'essentially signed' type (%1s) is being used as the first operand of this conditional operator (%2s).

4542	Min_Operands	A non-negative constant expression of 'essentially signed' type (%1s) is being used as the %2s operand of this bitwise operator (%3s).

4543	Min_Operands	A non-negative constant expression of 'essentially signed' type (%1s) is being used as the left-hand operand of this shift operator (%2s).

4544	Min_Operands	A non-negative constant expression of 'essentially signed' type (%1s) is being used as the right-hand operand of this shift operator (%2s).
* shall be deactivated in the personality

4548	RULE013_2	A non-negative constant expression of 'essentially signed' type (%1s) is being used as the %2s operand of this logical operator (%3s).

4549	RULE013_2	A non-negative constant expression of 'essentially signed' type (%1s) is being used as the first operand of this conditional operator (%2s).

4558	RULE013_2	An expression of 'essentially unsigned' type (%1s) is being used as the %2s operand of this logical operator (%3s).

4559	RULE013_2	An expression of 'essentially unsigned' type (%1s) is being used as the first operand of this conditional operator (%2s).

4568	RULE013_2	An expression of 'essentially floating' type (%1s) is being used as the %2s operand of this logical operator (%3s).

4569	RULE013_2	An expression of 'essentially floating' type (%1s) is being used as the first operand of this conditional operator (%2s).

4570	Min_Operands	The operand of this ~ operator has an 'essential type' which is narrower than type 'int'.
* shall be deactivated in the personality

4571	Min_Operands	The left-hand operand of this << operator has an 'essential type' which is narrower than type 'int'.
* shall be deactivated in the personality

4600   RULE020_1             The macro '%1s' is also defined in '<%2s>'.\\
MISRA-C:2004 Rule 20.1; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4601   RULE020_1             The macro '%1s' is the name of an identifier in '<%2s>'.\\
MISRA-C:2004 Rule 20.1; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4602   RULE020_2             The identifier '%1s' is declared as a macro in '<%2s>'.\\
MISRA-C:2004 Rule 20.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4603   RULE020_2             The object/function '%1s'is being defined with the same name as an ordinary identifier defined in '<%2s>'.\\
MISRA-C:2004 Rule 20.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4604   RULE020_2             The object/function '%1s' is being declared with the same name as an ordinary identifier defined in '<%2s>'.\\
MISRA-C:2004 Rule 20.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4605   RULE020_2             The typedef '%1s' is also defined in '<%2s>'.\\
MISRA-C:2004 Rule 20.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4606   RULE020_2             The typedef '%1s' has the same name as another ordinary identifier in '<%2s>'.\\
MISRA-C:2004 Rule 20.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4607   RULE020_2             The enum constant '%1s' has the same name as another ordinary identifier in '<%2s>'.\\
MISRA-C:2004 Rule 20.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4608   RULE020_2             The tag '%1s' is also defined in '<%2s>'.\\
MISRA-C:2004 Rule 20.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4620	Min_Ident	The macro '%1s' may also be defined as a macro in '<%2s>'.\\
REFERENCE - ISO:C99-7.8 Format conversion of integer types <inttypes.h>, ISO:C99-Integer types <stdint.h>
* shall be deactivated in the personality

4621	Min_Ident	The macro '%1s' may also be defined as a typedef in '<%2s>'.\\
REFERENCE - ISO:C99-Integer types <stdint.h>
* shall be deactivated in the personality

4622	Min_Ident	The identifier '%1s' may be defined as a macro in '<%2s>'.\\
REFERENCE - ISO:C99-7.8 Format conversion of integer types <inttypes.h>, ISO:C99-Integer types <stdint.h>
* shall be deactivated in the personality

4623	Min_Ident	The typedef '%1s' may also be defined in '<%2s>'.\\
REFERENCE - ISO:C99-Integer types <stdint.h>
* shall be deactivated in the personality

4624	Min_Ident	The ordinary identifier '%1s' may be defined as a typedef in '<%2s>'.\\
REFERENCE - ISO:C99-Integer types <stdint.h>
* shall be deactivated in the personality

4640	Min_Ident	The macro '%1s' could conflict in the future with the name of a macro in '<%2s>'.\\
REFERENCE - ISO:C90-7.13 Future Library Directions, ISO:C99-7.26 Future Library Directions
* shall be deactivated in the personality

4641	Min_Ident	The identifier '%1s' could conflict in the future with the name of a macro in '<%2s>'.\\
REFERENCE - ISO:C90-7.13 Future Library Directions, ISO:C99-7.26 Future Library Directions
* shall be deactivated in the personality

4642	Min_Ident	The macro '%1s' could conflict in the future with the name of a function in '<%2s>'.\\
REFERENCE - ISO:C90-7.13 Future Library Directions, ISO:C99-7.26 Future Library Directions
* shall be deactivated in the personality

4643	Min_Ident	The identifier '%1s' could conflict in the future with the name of a function in '<%2s>'.\\
REFERENCE - ISO:C90-7.13 Future Library Directions, ISO:C99-7.26 Future Library Directions
* shall be deactivated in the personality

4644	Min_Ident	The macro '%1s' could conflict in the future with the name of a typedef in '<%2s>'.\\
REFERENCE - ISO:C90-7.13 Future Library Directions, ISO:C99-7.26 Future Library Directions
* shall be deactivated in the personality

4645	Min_Ident	The identifier '%1s' could conflict in the future with the name of a typedef in '<%2s>'.\\
REFERENCE - ISO:C90-7.13 Future Library Directions, ISO:C99-7.26 Future Library Directions
* shall be deactivated in the personality

4700	Metrics	Metric value out of threshold range: %s.

4800	local	The identifier '%1s' does not conform to the name rule

5013   RULE006_3             Use of basic type '%s'.\\
MISRA-C:2004 Rule 6.3

* not available in v8.1 any more: 5069   RULE016_1             Functions shall not be defined with a variable number of arguments.\\
* MISRA-C:2004 Rule 16.1

5087   RULE019_1             #include statements in a file should only be preceded by other preprocessor directives or comments.\\
MISRA-C:2004 Rule 19.1

* not available in v8.1 any more: 5102   RULE017_5             The declaration of objects should contain no more than 2 levels of pointer indirection.\\
* MISRA-C:2004 Rule 17.5

5118   RULE020_4             Dynamic heap memory allocation shall not be used.\\
MISRA-C:2004 Rule 20.4

5119   RULE020_5             The error indicator errno shall not be used.\\
MISRA-C:2004 Rule 20.5

5120   RULE020_6             The macro offsetof, in library <stddef.h>, shall not be used.\\
MISRA-C:2004 Rule 20.6

5122   RULE020_7             The setjmp macro and the longjmp function shall not be used.\\
MISRA-C:2004 Rule 20.7

5123   RULE020_8             The signal handling facilities of <signal.h> shall not be used.\\
MISRA-C:2004 Rule 20.8

5124   RULE020_9             The input/output library <stdio.h> shall not be used in production code.\\
MISRA-C:2004 Rule 20.9

5125   RULE20_10             The library functions atof, atoi and atol from library <stdlib.h> shall not be used.\\
MISRA-C:2004 Rule 20.10

5126   RULE20_11             The library functions abort, exit, getenv and system from library <stdlib.h> shall not be used.\\
MISRA-C:2004 Rule 20.11

5127   RULE20_12             The time handling functions of library <time.h> shall not be used.\\
MISRA-C:2004 Rule 20.12

6000   NCC_VAR_LOC           Conti NamingConventions for local pointers violated.\\
<Datatype>_<Name>  (Datatype -> Prefix = p; Name -> Variable name (any letters, numbers and underscores are allowed))

6001   NCC_VAR_LOC           Conti NamingConventions for local unsigned variables violated.\\
<Datatype>_<Name>  (Datatype -> Prefix = u; Name -> Variable name (any letters, numbers and underscores are allowed))

6002   NCC_VAR_LOC           Conti NamingConventions for local signed variables violated.\\
<Datatype>_<Name>  (Datatype -> Prefix = s; Name -> Variable name (any letters, numbers and underscores are allowed))

6003   NCC_VAR_LOC           Conti NamingConventions for local array variables violated.\\
<Datatype>_<Name>  (Datatype -> Prefix = a; Name -> Variable name (any letters, numbers and underscores are allowed))

6004   NCC_VAR_LOC           Conti NamingConventions for local float variables violated.\\
<Datatype>_<Name>  (Datatype -> Prefix = f; Name -> Variable name (any letters, numbers and underscores are allowed))

6010   NCC_VAR_GLOB          Conti NamingConventions for private global pointer variables violated.\\
<Datatype>_<Name>  (Datatype -> Prefixes = p; Name -> Variable name (any letters, numbers and underscores are allowed))

6011   NCC_VAR_GLOB          Conti NamingConventions for private global unsigned variables violated.\\
<Datatype>_<Name>  (Datatype -> Prefixes = u; Name -> Variable name (any letters, numbers and underscores are allowed))

6012   NCC_VAR_GLOB          Conti NamingConventions for private global signed variables violated.\\
<Datatype>_<Name>  (Datatype -> Prefixes = s; Name -> Variable name (any letters, numbers and underscores are allowed))

6013   NCC_VAR_GLOB          Conti NamingConventions for private global array variables violated.\\
<Datatype>_<Name>  (Datatype -> Prefixes = a; Name -> Variable name (any letters, numbers and underscores are allowed))

6014   NCC_VAR_GLOB          Conti NamingConventions for private global float variables violated.\\
<Datatype>_<Name>  (Datatype -> Prefixes = f; Name -> Variable name (any letters, numbers and underscores are allowed))

6020   NCC_VAR_GLOB          Conti NamingConventions for public global pointer variables violated.\\
<Package indication>_<Datatype>_<Name>  (Package indication -> (2..10 characters in upper cases); Datatype -> Prefixes = p; Name -> Variable name (any letters, numbers and underscores are allowed))

6021   NCC_VAR_GLOB          Conti NamingConventions for public global unsigned variables violated.\\
<Package indication>_<Datatype>_<Name>  (Package indication -> (2..10 characters in upper cases); Datatype -> Prefixes = u; Name -> Variable name (any letters, numbers and underscores are allowed))

6022   NCC_VAR_GLOB          Conti NamingConventions for public global signed variables violated.\\
<Package indication>_<Datatype>_<Name>  (Package indication -> (2..10 characters in upper cases); Datatype -> Prefixes = s; Name -> Variable name (any letters, numbers and underscores are allowed))

6023   NCC_VAR_GLOB          Conti NamingConventions for public global array variables violated.\\
<Package indication>_<Datatype>_<Name>  (Package indication -> (2..10 characters in upper cases); Datatype -> Prefixes = a; Name -> Variable name (any letters, numbers and underscores are allowed))

6024   NCC_VAR_GLOB          Conti NamingConventions for public global float variables violated.\\
<Package indication>_<Datatype>_<Name>  (Package indication -> (2..10 characters in upper cases); Datatype -> Prefixes = f; Name -> Variable name (any letters, numbers and underscores are allowed))

6030   NCC_FCT               Conti NamingConventions for private functions violated.\\
<Datatype>_<Function name>  (Datatype -> Prefixes (p, a, u, s, f, v, r); Name -> Variable name (any letters, numbers and underscores are allowed))

6040   NCC_FCT               Conti NamingConventions for public functions violated.\\
<Package indication>_<Datatype>_<Function name>  (Package indication -> (2..10 characters in upper cases); Datatype -> Prefixes (p, a, u, s, f, v, r); Name -> Variable name (any letters, numbers and underscores are allowed))

7001   HIS_METRICS_STCDN     HIS metrics check: comment density violated.\\
HIS metrics 1.1:             comment to code ratio has to be >= than 80 \%

7002   HIS_METRICS_STPTH     HIS metrics check: amount of non-cyclic paths - minimum number of necessary test cases.\\
HIS metrics 1.2:             STPTH has to be in range of 1 - 80.
* shall be deactivated in the personality

7003   HIS_METRICS_STGTO     HIS metrics check: number of goto-statements.\\
HIS metrics 1.3:             STGTO must not be > 0.

7004   HIS_METRICS_STCYC     HIS metrics check: cyclomatic complexitiy.\\
HIS metrics 1.4:             STCYC has to be in range of 1 - 20.

7005   HIS_METRICS_STM29     HIS metrics check: number of calling functions.\\
HIS metrics 1.5:             STM29 must not be > 5.
* shall be deactivated in the personality

7006   HIS_METRICS_STCAL     HIS metrics check: number of called functions.\\
HIS metrics 1.6:             STCAL must not be > 7.
* shall be deactivated in the personality

7007   HIS_METRICS_STPAR     HIS metrics check: number of function parameters.\\
HIS metrics 1.7:             STPAR must not be > 10.
* shall be deactivated in the personality

7009   HIS_METRICS_STMIF     HIS metrics check: function nesting level.\\
HIS metrics 1.9:             STMIF must not be > 8.
* shall be deactivated in the personality

7010   HIS_METRICS_STM19     HIS metrics check: number of exit points.\\
HIS metrics 1.10:             STM19 must not be > 1.
* shall be deactivated in the personality

7011   HIS_METRICS_STNRA     HIS metrics check: Call graph recursions.\\
HIS metrics 1.11:             STNRA must not be > 0.

7012   METRICS_STXLN         Info: number of executable lines per function.\\
HIS metrics 1.12:             STXLN must not be > 100.

7013   METRICS_STTPP         Info: number of executable lines per file.\\
HIS metrics 1.13:             STTPP must not be > 750.
