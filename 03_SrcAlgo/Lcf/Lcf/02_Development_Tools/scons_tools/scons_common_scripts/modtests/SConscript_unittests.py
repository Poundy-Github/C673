"""
Filename                  : scons_common_scripts\modtests\SConscript_unittests.py
Description               : SConscript to build Cantata unit tests and generate reports. 
"""
#***************************************************************************************************
# COMPANY: Continental AG, ADAS, A.D.C. GmbH
#
# PROJECT: ETK/SCT_Sconstools
#
# COMPONENT: scons_common_scripts
#
# MODULE NAME: modtests\SConscript_unittests.py
#
# DESCRIPTION: SConscript to build Cantata unit tests and generate reports. 
#
# INITIAL AUTHOR: Hendra.Sasmito-EXT (uidw1406)
#
# CREATION DATE: 2013/10/07
#
# LAST CHANGE:      $Date: 2021/12/13 19:06:14CET $
#                   $Author: Wang, David (Wangd3) $
#
# CURRENT VERSION:  $Revision: 1.1 $
#############################################################################
# CHANGES:                   $Log: SConscript_unittests.py  $
# CHANGES:                   Revision 1.1 2021/12/13 19:06:14CET Wang, David (Wangd3) 
# CHANGES:                   Initial revision
# CHANGES:                   Member added to project /ADAS/Projects/MFC5xx/MFC5J3/06_Algorithm/DPU/04_Engineering/02_Development_Tools/scons_tools/scons_common_scripts/modtests/project.pj
# CHANGES:                   Revision 1.55 2017/05/30 13:55:21CEST Bhagawati, Tridip (uidr2134) 
# CHANGES:                   GSCons update for Mainstream
# CHANGES:                   Revision 1.54 2017/04/27 16:06:35CEST Singh, Vishal (uidj9083) 
# CHANGES:                   Updated for mainstream
# CHANGES:                   Revision 1.53 2016/08/02 06:52:38CEST Annashamachar, Shwetha (uidj8746) 
# CHANGES:                   Error and Exception handled in GSCons
# CHANGES:                   Revision 1.52 2016/07/27 11:20:00CEST Annashamachar, Shwetha (uidj8746) 
# CHANGES:                   Scons -c not cleaning results generated by xxx_ide_unittests
# CHANGES:                   Revision 1.51 2016/07/12 06:36:16CEST Annashamachar, Shwetha (uidj8746) 
# CHANGES:                   Error and Exception handled in GSCons.
# CHANGES:                   Revision 1.50 2016/07/01 06:15:29CEST Annashamachar, Shwetha (uidj8746) 
# CHANGES:                   File header added
# CHANGES:                   Revision 1.49 2016/06/17 06:50:05CEST Bhagawati, Tridip (uidr2134) 
# CHANGES:                   Cannot open Cantata Test Script in MSVC GUI - Invalid path in SCons-generated MSVC project file
# CHANGES:                   Revision 1.48 2016/05/25 12:05:59CEST Bhagawati, Tridip (uidr2134) 
# CHANGES:                   Generic SCons: To generate stand alone Cantata project - Remove unwanted print statements and warnings
# CHANGES:                   Revision 1.47 2016/05/05 07:47:29CEST Bhagawati, Tridip (uidr2134) 
# CHANGES:                   Generic Scons: To generate stand alone Cantata project
# CHANGES:                   Revision 1.46 2016/04/05 10:43:06CEST Bhagawati, Tridip (uidr2134) 
# CHANGES:                   same as 1.44 and 1.42
# CHANGES:                   Revision 1.45 2016/04/04 11:38:39CEST Bhagawati, Tridip (uidr2134) 
# CHANGES:                   same as version 1.43
# CHANGES:                   Revision 1.44 2016/04/04 08:55:46CEST Bhagawati, Tridip (uidr2134) 
# CHANGES:                   Added the contents of 1.42
# CHANGES:                   Revision 1.43 2016/03/31 06:44:43CEST Bhagawati, Tridip (uidr2134) 
# CHANGES:                   Generic SCons: To generate stand alone Cantata project
# CHANGES:                   Revision 1.42 2015/09/25 11:19:07CEST Fischer-EXT, Andre (uidg5297) 
# CHANGES:                   check-in required by Andreas Jahnke
# CHANGES:                   fix for deleted source files and problem with html-report generation
# CHANGES:                   - Added comments -  uidg5297 [Sep 25, 2015 11:19:07 AM CEST]
# CHANGES:                   Change Package : 380505:1 http://mks-psad:7002/im/viewissue?selection=380505
# CHANGES:                   Revision 1.41 2015/06/26 08:53:56CEST Palanisamy-EXT, Lenin (uidr0826) 
# CHANGES:                   Add revision label with module description for all GSCons files (Issue 320651)
# CHANGES:                   --- Added comments ---  uidr0826 [Jun 26, 2015 8:53:56 AM CEST]
# CHANGES:                   Change Package : 350940:1 http://mks-psad:7002/im/viewissue?selection=350940

#***************************************************************************************************

# SConscript to build unit tests 

#-------------------------
# import
#-------------------------
import os, operator, SCons, glob, shutil, exceptions, sys, re
from fnmatch import fnmatch
Import("skip_ide_generation","exception_handler_file_list","exception_handler","scons_arguments", "component_name", "build_from_ide", "thread_number", "env", "algo_name", "algo_name_list", "variant", "variant_list", "generate_ide", "help_dict", "profile", "SconscriptTimesTable")

execfile(File("#../GSCons_project_config.scfg").abspath)
if profile:
    execfile(File(development_tools_path_from_sconstruct + "scons_tools/scons_adas_extensions/profile.py").abspath)
    StartSconscriptEntry('2')

#-------------------------
# read configuration file
#-------------------------
# read file list containing source files and include paths
execfile(File(development_tools_path_from_sconstruct + "scons_tools/scons_common_config/common_config.scfg").abspath)
# We want to use the compiler settings already set up for the 
# PC sim target. Therefore we source the configuration settings
# for the sim.
sconscript_dir = os.path.dirname((lambda x:x).func_code.co_filename)
execfile(sconscript_dir + "/unit_test.scfg")
execfile(File("#../" + component_name + "_sim/sim_swc_" + component_name + "/sim_swc_config.scfg").abspath)
execfile(File(development_tools_path_from_sconstruct + "scons_tools/scons_adas_extensions/help_menu.py").abspath)

# read gscons_exception_handler
execfile(File(scons_adas_extensions_path + "gscons_exception_handler.py").abspath)	

# get relative path of a file
relpath = os.path.relpath(sconscript_dir,os.path.dirname(os.path.dirname(os.path.dirname(sconscript_dir))))
msg="in "+relpath+"\unit_test.scfg"

try:
    generate_html_use_data_option
except NameError,e:
    exception_warning(e,exception_handler,msg)
    generate_html_use_data_option = 1
    cantata_ide_path = build_dir + "/algo/" + component_name + "_unittests/" + "/workspace"

try:
    use_msvc
except NameError,e:
    exception_warning(e,exception_handler,msg)
    use_msvc = 1

try:
    utprograms_source_included_in_test_script
except NameError,e:
    exception_warning(e,exception_handler,msg)	
# ========================
# unit_test
# ========================

#-------------------------------
# CONSTRUCTION ENVIRONMENT SETUP
#-------------------------------
ut_env = env.Clone()
# Add absolute paths so that VS can access them easily
ut_env.Append(CPPPATH=[Dir(kernel_path).abspath, Dir(framework_path).abspath, Dir(common_path).abspath, Dir(rte_path).abspath])
for paths in sim_swc_cpp_path:
    ut_env.Append(CPPPATH=Dir(paths).abspath)
ut_env['ECLIPSE_EXE'] = "cantpp"


###################
# SOURCE FILE LISTS
###################

program_src = {}
side_effects = {}
program_src_for_ide = {}
program_headers_for_ide = {}
linked_resources = {}
# source file extensions of FUT
ut_source_exts = {}


###################
# IDE PROJECT LISTS
###################
projects = []
eclipseProjects = []
runfiles = {}

###################
# TEST RESULT LISTS
###################
failedTests = []
successfulTests = []

###############
# BUILD CONTROL
###############
testScriptAlreadyGenerated = {}
previousUnitTest = None

###########
# FUNCTIONS
###########

###############################################################################
# CopyAdditionalFilesToExecDir
# Copies files *.<file_pattern> from unit test source directory
# to unit test execution directory and VS debugger working directory
###############################################################################
def CopyAdditionalFilesToExecDir(utprogram, file_pattern):

    # unit test execution directory
    destination_dir = os.path.join(Dir(".").abspath, utprogram) + '\\'
    # VS debugger working directory
    debug_dir = Dir(workspace_dir).abspath + '\\algo\\' + component_name + '\\'
    # source directory
    source_dir = os.path.join(Dir(unit_test_path).abspath, utprogram) + '\\'

    try:
        if not os.path.exists(destination_dir):
            os.makedirs(destination_dir)
        if os.path.exists(destination_dir):
            file_list = []
            file_search_result = os.listdir(source_dir)
            for fr in file_search_result:
                if fnmatch(fr, file_pattern):
                    file_name = fr
                    file_list.append(file_name)
            for fl in file_list:
                source_file = source_dir +  fl
                dest_file = destination_dir +  fl
                shutil.copyfile(source_file, dest_file)
                dest_file = debug_dir + fl
                shutil.copyfile(source_file, dest_file)
        else:
            print "CopyAdditionalFilesToExecDir: " + destination_dir + " does not exist"
    except exceptions.IOError, e:
      print e.strerror + ' ' + e.filename
    except:
        print sys.exc_info()
        print sys.exc_traceback


####################################################################
# CopyAdditionalFilesToSourceDir
# Copies files *.<file_pattern> from unit test execution directory
# back to unit test source directory.
# This can be used for verifying output data
# if your Cantata test script creates some custom output files.
#####################################################################
def CopyAdditionalFilesToSourceDir(utprogram, file_pattern):

    # unit test execution directory
    source_dir = os.path.join(Dir(".").abspath, utprogram) + '\\'
    # source directory of utprogram
    destination_dir = os.path.join(Dir(unit_test_path).abspath, utprogram) + '\\'

    try:
      if os.path.exists(source_dir):
          file_list = []
          file_search_result = []
          try:
              file_search_result = os.listdir(source_dir)
          except:
              return
          for fr in file_search_result:
              if fnmatch(fr, file_pattern):
                  file_name = fr
                  file_list.append(file_name)
          for fl in file_list:
              source_file = source_dir +  fl
              dest_file = destination_dir +  fl
              # delete file if existing
              try:
                  if os.path.exists(dest_file):
                      os.chmod(dest_file, 0666)
                      os.remove(dest_file)
              except:
                  pass
              # copy file
              try:
                  shutil.copyfile(source_file, dest_file)
              except:
                  print "Error copying file from " + source_file + " to " + dest_file
      else:
          print "CopyAdditionalFilesToSourceDir: " + destination_dir + " does not exist"
    except exceptions.IOError, e:
      print e.strerror + ' ' + e.filename
    except exceptions.OSError, eosr:
      print eosr.strerror + ' ' + eosr.filename
    except:
      print sys.exc_info()
      print sys.exc_traceback

########################################################
# ReadFileExtenstion
# Read file extensions from file sysstems
########################################################
def ReadFileExtenstion(utprogram,use_test_dir_for_src):

    abs_kernel_path = Dir(kernel_path).abspath + "\\"
    abs_test_path = Dir(unit_test_path).abspath + "\\"

    for sext in source_ext_list:
        if use_test_dir_for_src:
            chec_path_ext = abs_test_path + dummy_src_dir + utprogram + sext
        else:
            chec_path_ext = abs_kernel_path + "\\" + utprogram + sext
        if os.path.exists(chec_path_ext):
            ut_source_exts[utprogram] = sext
            break
    # ------------------------------------------------------
    # Andre.Fischer-Ext (uidg5297), ITK Engineering:
    # ------------------------------------------------------
    # The variable "ut_source_exts" is a dictionary mapping the sources for test to the corresponding file extensions.
    # In case a unittest is set in unit_test.scfg, which does not exist (any more), there is, of course, no file extension, 
    # i.e. calling "ut_source_exts[utprogram]" causes a KeyError further down and no targets are built at all, even those which are not 
    # related to testing!
    # ------------------------------------------------------
    # Workaround: In case this happens "ut_source_exts[utprogram]" is set to "", such that everything else
    # can be built and for unittests a warning message is displayed.
    # ------------------------------------------------------
    try:
        ut_source_exts[utprogram]
    except exceptions.KeyError, e:
        print "WARNING: The key " + str(e) + " is missing in python dictionary 'ut_source_exts'!!"
        print "         ut_source_exts[" + utprogram + "] is set to '' , so corresponding cantata unittest " + str(e) + " will not build!"
        print "         Please check unit_test.scfg and/or if the sources for the test are present in the project!\n"
        ut_source_exts[utprogram] = ""

########################################################
# _CopyCoverageFiles
# Checks for one or more coverage files in the 
# given cantataOutputFileSource directory and copies
# them to the cantataOutputFileDestinations directory.
########################################################
def _CopyCoverageFiles(cantataOutputFileSource, cantataOutputFileDestination):
    for covFile in glob.glob(cantataOutputFileSource + "\\*.cov"):
	# Maintain the timestamps on the files copied by using
	# copy2 instead of copy. This is important as we don't want to
	# load out of date coverage files unintentionally.
        shutil.copy2(covFile, cantataOutputFileDestination)

########################################################
# _GatherTestResults
# Checks for the existence of a .passed file in each
# unit test directory and builds two lists of tests,
# a list of successful tests and a list of failed tests. 
########################################################
def _GatherTestResults(utprogram, utprogram_without_path, buildDir):
    passedFile = buildDir+'\\'+utprogram+'\\'+utprogram_without_path+'.passed'

    if (os.path.exists(passedFile) and 
        os.path.isfile(passedFile) and
        os.access(passedFile, os.R_OK)):
        successfulTests.append(utprogram)
    else:
        failedTests.append(utprogram)
	

########################################################
# _PrintTestResults
# Prints a summary report of the test results to stdout.
########################################################
def _PrintTestResults():

    print ""
    print "******************"
    print "** TEST RESULTS **"
    print "******************"
    print ""

    if len(successfulTests) > 0:
        print "The following tests passed:"
	for test in successfulTests:
	    print test 
    else:
        print "There were no tests that passed."
    print ""

    if len(failedTests) > 0:
        print "The following tests failed:"
	for test in failedTests:
	    print test 
    else:
        print "There were no tests that failed."
    print ""


########################################################
# Actions
# Builds actions for the _CopyCoverageFiles,
# _GatherTestResults and _PrintTestResults functions.
########################################################
CopyCoverageFiles = \
    SCons.Action.ActionFactory(_CopyCoverageFiles,
		               lambda cantataOutputFileSource,
			              cantataOutputFileDestination : '')

GatherTestResults = \
    SCons.Action.ActionFactory(_GatherTestResults, 
                               lambda utprogram, utprogram_without_path, buildDir: '')
PrintTestResults = \
    SCons.Action.ActionFactory(_PrintTestResults, 
                               lambda : '')

########################################################
# CleanedSideEffect
# Declares a side effect for the given target and
# ensures the side effect is cleaned on a -c command.
########################################################
def CleanedSideEffect(utprogram, sideEffect, target):

    sideEffectTarget = ut_env.SideEffect(sideEffect, target)
    ut_env.Clean(utprogram, sideEffectTarget)
    ut_env.Clean(unit_test_target, sideEffectTarget)

########################################################
# SetupUnitTestSources
# Builds a number of list dictionaries, containing the
# sources to be built for each unit test. Also builds
# lists of sources for the MSVC and Eclipse IDEs.
########################################################
def SetupUnitTestSources(utprogram, utprogram_without_path, use_test_dir_for_src):

    relative_framework_headers = []    
    test_source_file = 'test_' + utprogram_without_path + ut_source_exts[utprogram]
    test_ctr_file = 'test_' + utprogram_without_path + '.ctr'
    abs_kernel_path = Dir(kernel_path).abspath + "\\"
    abs_test_path = Dir(unit_test_path).abspath + "\\"
    local_source_include_flag = source_included_in_test_script

    # calculate path depths
    path_depth_num = utprogram.count('/')
    reverse_depth_num = utprogram.count('../')
    # for example utprogram is placed in 00_Custom folder
    if reverse_depth_num > 0:
      path_depth_num = path_depth_num - reverse_depth_num - 1
    path_depth = "../" * path_depth_num

    # setup paths to Framework headers
    for header in framework_headers:
       rh_file = path_depth + ide_relative_framework_path + header
       relative_framework_headers.append(rh_file)

    # setup paths to source files
    if use_test_dir_for_src:
        source_file = dummy_src_dir + utprogram + ut_source_exts[utprogram]		
	source_file_for_ide = path_depth + ide_relative_unit_test_path + dummy_src_dir+ utprogram + ut_source_exts[utprogram]
	linked_file = abs_test_path + dummy_src_dir+ utprogram + ut_source_exts[utprogram]
    else:
        source_file = os.path.normpath(relative_kernel_path_ut + utprogram) + ut_source_exts[utprogram]
        source_file_for_ide = path_depth + os.path.normpath(relative_kernel_path + '\\' + utprogram + ut_source_exts[utprogram])
        linked_file = abs_kernel_path + utprogram + ut_source_exts[utprogram]

    # including FUT into Cantata test script can be configured for each test script now
    try:
      if utprogram in utprograms_source_included_in_test_script:
          local_source_include_flag = utprograms_source_included_in_test_script[utprogram]
          print utprogram + " source_include_in_test_script=" + str(local_source_include_flag)
      else:
          local_source_include_flag = source_included_in_test_script
          print utprogram + " source_include_in_test_script=" + str(local_source_include_flag) + " (default)"
    except exceptions.NameError, e:
        local_source_include_flag = source_included_in_test_script

    if local_source_include_flag:
        program_src[utprogram] = [utprogram+'\\'+ test_source_file]
    else:
        program_src[utprogram] = [utprogram+'\\'+ test_source_file, 
                                  source_file]

    program_src_for_ide[utprogram] = \
         [path_depth + ide_relative_unit_test_path+utprogram + "\\" + test_source_file,
          path_depth + ide_relative_unit_test_path+utprogram + "\\" + test_ctr_file,
          path_depth + ide_relative_unit_test_path+utprogram + "\\ipg.cop",
          source_file_for_ide]

    headers = list(relative_framework_headers)
    headers.append(path_depth + os.path.normpath(relative_kernel_path+utprogram) + '.h')
    program_headers_for_ide[utprogram] = list(headers)

    linked_resources[utprogram] = list([Dir(framework_path).abspath])
    linked_resources[utprogram].append(linked_file)
    linked_resources[utprogram].append(abs_kernel_path+utprogram+'.h')

    testScriptAlreadyGenerated[utprogram] = FindFile(test_source_file,
    		                                     unit_test_path + utprogram)

    # Save the source in the environment for later use in 
    # subsequent calls to this SConscript.
    env.Append(PROGRAM_SRC = program_src)
    env.Append(TEST_SCRIPT_ALREADY_GENERATED = testScriptAlreadyGenerated)


########################################################
# ProcessUnitTestOutput
# Copies the files created by running a unit test from
# the build directory to the appropriate Eclipse
# unittest project directory, so Cantata can correctly
# display the results. Also, gathers a summary of the
# test results for later use.
########################################################
def ProcessUnitTestOutput(utprogram, utprogram_without_path, unitTest):

    cantataOutputFileSource = \
        Dir(".").abspath + '\\' + utprogram + '\\test_'+utprogram_without_path
    cantataOutputFileDestination = \
        Dir(unit_test_path + utprogram).abspath + '\\test_'+utprogram_without_path

    cantataCtgFile = cantataOutputFileSource + ".ctg"
    cantataCtrFile = cantataOutputFileSource + ".ctr"

    cantataCtgFileDest = cantataOutputFileDestination + ".ctg"
    cantataCtrFileDest = cantataOutputFileDestination + ".ctr"

    # Copy the results to the Cantata project directory so Cantata can 
    # load them.

    # clean ut program from any relative path to create valid dummy directories
    cleaned_ut_program = re.sub(r'^(\.\.[\\\/])+', '', utprogram)

    # Note we copy all coverage files that may exist
    # as a testscript may produce multiple coverage files.
    cpCommand = \
        ut_env.Command('dummyCopyCoverageFilesFor_' + cleaned_ut_program, [], 
                       CopyCoverageFiles(Dir(".").abspath + '\\' + utprogram,
                                         Dir(unit_test_path + utprogram).abspath))
    ut_env.Depends(unit_test_target, cpCommand)
    ut_env.Depends(utprogram_target, cpCommand)
    ut_env.Depends(cpCommand, unitTest)
    # Ensure the results are always copied, otherwise Cantata will 
    # complain the timestamps of the results are incompatible with 
    # the .csi file.
    ut_env.AlwaysBuild(cpCommand)

    cpCommand = ut_env.Command(target_prefix + "DummyBinaryResultsCopyFor_" + cleaned_ut_program,
		            cantataCtgFile,
			    Copy(cantataCtgFileDest, "$SOURCE"))
    ut_env.Depends(unit_test_target, cpCommand)
    ut_env.Depends(utprogram_target, cpCommand)
    ut_env.Depends(cantataCtgFile, unitTest)
    # Ensure the results are always copied, otherwise Cantata will 
    # complain the timestamps of the results are incompatible with 
    # the .csi file.
    ut_env.AlwaysBuild(cpCommand)
    CleanedSideEffect(utprogram_target, cantataCtgFile, unitTest)

    cpCommand = ut_env.Command(target_prefix + "DummyTextResultsCopyFor_" + cleaned_ut_program,
		            cantataCtrFile,
			    Copy(cantataCtrFileDest, "$SOURCE"))
    ut_env.Depends(unit_test_target, cpCommand)
    ut_env.Depends(utprogram_target, cpCommand)
    ut_env.Depends(cantataCtrFile, unitTest)
    # Ensure the results are always copied, otherwise Cantata will 
    # complain the timestamps of the results are incompatible with 
    # the .csi file.
    ut_env.AlwaysBuild(cpCommand)
    CleanedSideEffect(utprogram_target, cantataCtrFile, unitTest)

    results = \
        ut_env.Command(target_prefix + 'dummyGatherTestResultsfor'+utprogram_without_path,
                       unitTest,
                       GatherTestResults(utprogram,
                                         utprogram_without_path,
                                         ut_env.Dir(".").abspath))
    ut_env.Depends(unit_test_target, results)
    ut_env.Depends(utprogram_target, results)
    # Ensure the results are always copied, otherwise Cantata will 
    # complain the timestamps of the results are incompatible with 
    # the .csi file.
    ut_env.AlwaysBuild(results)
    
    if generate_html_reports:
        ########################################################
        ## Generate Test Report in 02_Report/
        report_generator="com.ipl.products.eclipse.cantpp.cdt.TestReportGenerator"
        project_path=relative_ut_path_scons + utprogram
        generate_report_command=ut_env['ECLIPSE_EXE'] + " -application " + \
                                report_generator + " -noSplash " + \
                                " -data " + Dir(cantata_ide_path).abspath + " " + \
                                project_path + " HTML_DETAILED_REPORT" 
    
        reportCommand = \
            ut_env.Command(target_prefix + 'GenerateHTMLResultsFor'+utprogram_without_path,
                           unitTest,
                           generate_report_command)
        ut_env.Depends(unit_test_target, reportCommand)    
        ut_env.Depends(utprogram_target, reportCommand)
        ut_env.AlwaysBuild(reportCommand)
    
        ## Copy Test Report to 02_Reports/
        if not os.path.exists(Dir(unit_test_report_path).abspath + "/" + path_prefix + utprogram):
            os.makedirs(Dir(unit_test_report_path).abspath + "/" + path_prefix + utprogram)
        report_destination = Dir(unit_test_report_path).abspath + "/" + \
			     path_prefix + utprogram + "/" + \
			     utprogram_without_path + "_test_report.html"
        report_source =  unit_test_path + utprogram + \
                         "/Cantata Output/test_report.html"

        cpCommand = \
            ut_env.Command(target_prefix + 'CopyHTMLDetailedReportFor' + utprogram_without_path,
                           report_source,
                           Copy(report_destination, "$SOURCE"))
        ut_env.Depends(unit_test_target, cpCommand)
        ut_env.Depends(utprogram_target, cpCommand)
        ut_env.AlwaysBuild(cpCommand)
        ut_env.NoClean(cpCommand)


########################################################
# GenerateReports
# Generates an HTML report for all the executed test
# test scripts. Also generates a summary report to
# stdout.
def GenerateReports(lastBuildAction):

    # HTML report
    # decide whether to use -data option
    local_generate_html_use_data_option = 0
    # root directory where to create summary HTML report
    report_generator="com.ipl.products.eclipse.cantpp.cdt.TestReportGenerator"
    generate_report_command=ut_env['ECLIPSE_EXE'] + " -application " + \
                            report_generator + " -noSplash " + \
                            relative_ut_path_scons + " HTML_SUMMARY_REPORT"

    try:
       local_generate_html_use_data_option = generate_html_use_data_option
       if local_generate_html_use_data_option == 1:
          generate_report_command=ut_env['ECLIPSE_EXE'] + " -application " + \
                                  report_generator + " -noSplash " + \
                                  " -data " + Dir(cantata_ide_path).abspath + " " + \
                                  Dir(unit_test_path).abspath + " HTML_SUMMARY_REPORT"
    except NameError,e:
      exception_warning(e,exception_handler,msg)
      generate_report_command=ut_env['ECLIPSE_EXE'] + " -application " + \
                              report_generator + " -noSplash " + \
                              Dir(unit_test_path).abspath + " HTML_SUMMARY_REPORT"
    
    reportCommand = ut_env.Command('GenerateHTMLResults',
                                    lastBuildAction,
                                    generate_report_command)
    ut_env.Depends(unit_test_target, reportCommand)    
    # Ensure the results are always copied, otherwise Cantata will 
    # complain the timestamps of the results are incompatible with 
    # the .csi file.
    ut_env.AlwaysBuild(reportCommand)
    
    report_destination = Dir(unit_test_report_path).abspath + "/" + \
		         path_prefix + "Cantata_test_report.html"
    report_source = Dir(unit_test_path).abspath + \
		    "/Cantata Output/test_report.html"

    # Copy Test Report to correct location
    cpCommand = ut_env.Command(target_prefix + 'CopyHTMLSummaryReport',
		               report_source,
                               Copy(report_destination, "$SOURCE"))
    ut_env.Depends(unit_test_target, cpCommand)
    ut_env.AlwaysBuild(cpCommand)

    # Summary report of tests results to stdout
    resultsReport = ut_env.Command('dummyPrintResults', [], PrintTestResults())
    ut_env.Depends(unit_test_target, resultsReport)
    ut_env.Depends(resultsReport, lastBuildAction)
    ut_env.AlwaysBuild(resultsReport)


########################################################
# SetupIDE
# Builds the IDEs for MSVC and Cantata Eclipse.
# One MSVC and one Eclipse project is built for each
# unit test. Then the projects are gather into a single
# MSVC solution and an Eclipse workspace.
########################################################
def SetupIDE():

    cantataNature = 'com.ipl.products.eclipse.cantpp.cdt.CantataCDTNature'

    for utprogram in utprograms:

        utprogram = utprogram.strip('$')
        utprogram_without_path = os.path.basename(utprogram)

        # check existance of unit test source
        # see MKS Issue #348427
        if ut_source_exts[utprogram] == "":
            print "WARNING: SetupIDE: target " + utprogram + " not found"
            continue

        if len(algo_name_list) == 1:
            ide_variants = [local_variant[0] for local_variant in variant_list]
            ide_targets = [utprogram_without_path + "_ut_" + local_variant[0] for local_variant in variant_list]
            ide_runfiles = [Dir('.').abspath + '\\' + \
                            runfiles[utprogram] for local_variant in variant_list]
	    ide_rundirs = [Dir('#').abspath] * len(variant_list)
	    ide_runargs = [''] * len(variant_list)
	    ide_environment = [{}] * len(variant_list)
        else:
            ide_variants = [algo_name + "_" + local_variant[0] for local_variant in variant_list for algo_name in algo_name_list]
            ide_targets = [algo_name + "_" + utprogram_without_path + "_ut_" + local_variant[0] for local_variant in variant_list for algo_name in algo_name_list]
            ide_runfiles = [Dir('.').abspath + '\\..\\' + algo_name + '\\' + \
                            runfiles[utprogram] for local_variant in variant_list for algo_name in algo_name_list]
	    ide_rundirs = [Dir('#').abspath] * (len(variant_list) * len(algo_name_list))
	    ide_runargs = [''] * (len(variant_list) * len(algo_name_list))
	    ide_environment = [{}] * (len(variant_list) * len(algo_name_list))

        eclipseProject = \
            ut_env.EclipseProject(target_name = utprogram_without_path,
                               target_dir =  unit_test_path +
                                             utprogram + '/',
                               variants = ide_variants,
                               scons_targets = ide_targets,
			       cplusplus = ut_source_exts[utprogram] == '.cpp',
			       linked_resources = linked_resources[utprogram],
			       additional_includes = [catd+"\\inc"],
                               additional_natures = cantataNature,
                               scons = scons_cmd)

        eclipseProjects.append(eclipseProject)
        ut_env.Clean("all",eclipseProjects)		
        
        if use_msvc == 1:
          # Add Cantat include paths so that Cantata specific macros can be easiliy accessed
          ut_env.Append(CPPPATH=catd+"\\inc")
  
          project = ut_env.MSVSProject(target = unit_test_path + utprogram + '\\' +
                                             utprogram_without_path + ut_env['MSVSPROJECTSUFFIX'],
                                    srcs = program_src_for_ide[utprogram],
                                    incs = program_headers_for_ide[utprogram],
                                    buildtarget = ide_targets,
                                    variant = ide_variants,
  		                  auto_build_solution=0,
                                    runfile = ide_runfiles,
  		                  MSVSSCONS = ut_env['IDE_SCONS_CMD'],
  		                  SCONS_DIR = Dir("#").abspath,
  		                  SCONS_ARGUMENTS = ut_env['SCONS_ARGUMENTS'])

          generate_alias(component_name + "_ide_unittests", project, component_name + ':ide:unittests', ['MSVC & Cantata Eclipse projects', ' for unit test'])
          generate_alias(component_name + "_ide", project, component_name + ':ide')

          projects.append(utprogram+'/'+utprogram_without_path+ut_env.subst('$MSVSPROJECTSUFFIX'))

          projectDbg = ut_env.MSVSProjectDebug(project,
                                          variant = ide_variants,
                                          runfile = ide_runfiles,
                                          rundir = ide_rundirs,
                                          runargs = ide_runargs,
                                          environment = ide_environment)
          generate_alias(component_name + "_ide_unittests", projectDbg, component_name + ':ide:unittests', ['MSVC & Cantata Eclipse projects', ' for unit test'])
          generate_alias(component_name + "_ide", projectDbg, component_name + ':ide')

          ut_env.AlwaysBuild([project, projectDbg])
          ut_env.Clean("all",project)
          ut_env.Clean("all",projectDbg)


    # Single eclipse workspace containing all unit test projects
    if use_msvc == 1:
      ut_env.EclipseWorkspace(target_dir = cantata_ide_path,
                           projects=eclipseProjects,
                           preferences= unit_test_path+
                                        "CantataWorkspacePreferences.epf")
    else:
      ut_env.EclipseWorkspace(target_dir = cantata_ide_path,
                           projects=eclipseProjects,
                           preferences= unit_test_path+
                                        "CantataWorkspacePreferencesGcc.epf")

    generate_alias(component_name + "_ide_unittests", cantata_ide_path, component_name + ':ide:unittests', ['MSVC & Cantata Eclipse projects', ' for unit test'])
    generate_alias(component_name + "_ide", cantata_ide_path, component_name + ':ide')
    ut_env.Depends(cantata_ide_path, eclipseProjects)

    # Directories not cleaned by default. Force removal of workspace directory
    # on clean.
    ut_env.Clean(component_name + "_ide_unittests", cantata_ide_path)
    ut_env.Clean(component_name + "_ide", cantata_ide_path)    
    ut_env.Clean("all", cantata_ide_path)    
    

    # Single MSVC solution file containing all unit test projects
    if use_msvc == 1:
      solution = ut_env.MSVSSolution(target = unit_test_path + unit_test_dir +
                                         ut_env['MSVSSOLUTIONSUFFIX'],
                                projects = projects,
                                variant = ide_variants)

      # Ensure .ncb and .suo files are cleaned
      CleanedSideEffect(component_name + "_ide_unittests", unit_test_path + unit_test_dir + ".ncb", solution)
      CleanedSideEffect(component_name + "_ide", unit_test_path + unit_test_dir + ".ncb", solution)
      CleanedSideEffect(component_name + "_ide_unittests", unit_test_path + unit_test_dir + ".suo", solution)
      CleanedSideEffect(component_name + "_ide", unit_test_path + unit_test_dir + ".suo", solution) 
      ut_env.Clean("all",solution)
      CleanedSideEffect("all",unit_test_path + unit_test_dir + ".suo",solution)
      CleanedSideEffect("all",unit_test_path + unit_test_dir + ".ncb",solution)
    
      # Force generation of the solution when the "ide" directory is built.
      generate_alias(component_name + "_ide_unittests", solution, component_name + ':ide:unittests', ['MSVC & Cantata Eclipse projects', ' for unit test'])
      generate_alias(component_name + "_ide", solution, component_name + ':ide')

########################################################
# BuildAndRunUnitTest
# If a test script already exists:
#   Builds and runs the given unit test.
# else:
#   Builds the object file for unit under test. This
#   also generates the Cantata .csi file which can
#   then be used to generate a test script in the 
#   Cantata IDE.
#
# Due to the reliance on the ipg.cop file for each unit
# test being copied to the root scons directory, the
# tests are forcibly serialised to prevent the use of
# the wrong ipg.cop file.
########################################################
def BuildAndRunUnitTest(utprogram, utprogram_without_path):
    global previousUnitTest

    objFiles = []

    for srcFile in program_src[utprogram]:
        [root, ext] = os.path.splitext(srcFile)
	objFile = root + object_ext
	obj = ut_env.Object(srcFile)
        objFiles.append(obj)

    if use_msvc == 0:
        #print "CC=" + str(ut_env['CC'])
        #print "CCCOM=" + str(ut_env['CCCOM'])
        #print "CXX=" + str(ut_env['CXX'])
        #print "CXXCOM=" + str(ut_env['CXXCOM'])
        #print "SHLINK=" + str(ut_env['SHLINK'])
        #print "LINK=" + str(ut_env['LINK'])
        #print "LINKCOM=" + str(ut_env['LINKCOM'])
        #print "LINKFLAGS=" + str(ut_env['LINKFLAGS'])
        #print "LIBS=" + str(ut_env['LIBS'])
        #print "$_LIBDIRFLAGS=" + str(ut_env['_LIBDIRFLAGS'])
        #print "_LIBFLAGS=" + str(ut_env['_LIBFLAGS'])
        if ut_source_exts[utprogram] == '.cpp':
            ut_env['LINK']='$CXX'
            #LINKCOM_str = "ipg_comp --optfile " + Dir(unit_test_path).abspath + '\\' + utprogram + '\\ipg.cop --link ' + str(ut_env['CXX']) + " -o " + str(ut_env['TARGET']) + " " + str(ut_env['LINKFLAGS']) + " " + str(ut_env['__RPATH ']) + " " + str(ut_env['SOURCES']) + " " + str(ut_env['_LIBDIRFLAGS']) + " " + str(ut_env['_LIBFLAGS'])
            #print LINKCOM_str
            ut_env['LINKCOM']="ipg_comp --optfile " + Dir(unit_test_path).abspath + '\\' + utprogram + '\\ipg.cop --link ' +  '$CXX -o $TARGET $LINKFLAGS $__RPATH $SOURCES $_LIBDIRFLAGS $_LIBFLAGS'
#            print str(ut_env['LINKCOM'])
        if ut_source_exts[utprogram] == '.c':
            ut_env['LINK']='$CC'
            #LINKCOM_str = "LINKCOM = ipg_comp --optfile " + Dir(unit_test_path).abspath + "\\" + utprogram+ "\\ipg.cop --link " + str(ut_env['CC']) + " -o " + str(ut_env['TARGET']) + " " + str(ut_env['LINKFLAGS']) + " " + str(ut_env['__RPATH']) + " " + str(ut_env['SOURCES']) + " " + str(ut_env['_LIBDIRFLAGS']) + " " + str(ut_env['_LIBFLAGS'])
            #print LINKCOM_str            
            ut_env['LINKCOM']='ipg_comp --optfile ' + Dir(unit_test_path).abspath + "\\" + utprogram+ '\\ipg.cop --link ' +  '$CC -o $TARGET $LINKFLAGS $__RPATH $SOURCES $_LIBDIRFLAGS $_LIBFLAGS'
#            print str(ut_env['LINKCOM'])

    if use_msvc == 1:
      [unitTestProgram, unitTestResult] = \
          ut_env.addUnitTest(target = utprogram + "\\" + utprogram_without_path,
                          source = objFiles,
                          alias = unit_test_target,
                          PDB = utprogram + "\\" + utprogram_without_path +".pdb")
    else:
      [unitTestProgram, unitTestResult] = \
          ut_env.addUnitTest(target = utprogram + "\\" + utprogram_without_path,
                          source = objFiles,
                          alias = unit_test_target,
                          PDB = utprogram + "\\" + utprogram_without_path +".pdb")

    generate_alias(utprogram_target, unitTestResult)# - To display all the sub aliases use this ->(utprogram_target, unitTestResult , unit_test_target + ':' + utprogram_target)
    # workaround: store information on aliases which are set in unittest.py
    generate_alias(unit_test_target, [], unit_test_target, ['unit tests in ' + variant + ' mode' + '\n' + '\t\t\t\t\t\t' + ' please use ' + '<unittest>_ut_'  + variant  + '\n' + '\t\t\t\t\t\t' + ' for individual unittests'])

    # Ensure side effects are cleanable.
    for srcFile in program_src[utprogram]:
        [root, ext] = os.path.splitext(srcFile)
        csi_file =  unit_test_path + utprogram + "\\" + os.path.basename(root) + ".csi"
        CleanedSideEffect(utprogram, root + ".ti", unitTestProgram)
        CleanedSideEffect(utprogram, root + ".ii", unitTestProgram)
        CleanedSideEffect(utprogram, csi_file, unitTestProgram)

    ProcessUnitTestOutput(utprogram, utprogram_without_path, unitTestResult)

    # Copy custom result files (generated by test script) back to source directory.
    try:
      for resf in ut_res_file_exts:
        CopyAdditionalFilesToSourceDir(utprogram, "*" + resf)
    except NameError,e:
      exception_warning(e,exception_handler,msg)
      pass

    # The copy of the ipg.cop file cannot be done by defining the same
    # target for each unit test - this simply results in a scons error:
    # "multiple ways to build target". Instead we use a dummy target
    # constructed from the name of the unit test and add an explicit
    # dependency to force it to be executed.
    # Ensure that the permissions on the destination are set to writeable
    # so further copies do not fail due to permission problems.
    cpCommand = ut_env.Command("dummyIgpCopTarget"+utprogram_without_path,
                            unit_test_path + utprogram + '\\ipg.cop',
                            [Copy("ipg.cop", "$SOURCE"),
                             Chmod("ipg.cop", 0755)])

    if unit_test_target in COMMAND_LINE_TARGETS:
        if previousUnitTest:
            # Serialise tests - needed as we have to copy the unit tests
            # specific ipg.cop file into the directory from which scons was
	    # executed to ensure Cantata is enabled for the build.
            # Note that the ipg.cop file also contains configuration options
            # specific to the unit test being executed.
            Depends(cpCommand, previousUnitTest)

    # Place a specific dependency from the object files that make up the
    # test executable to the ipg.cop copy command. Using the executable
    # target is insufficient as this is evaluated at link time and thus too
    # late.
    for objFile in objFiles:
        Depends(objFile, cpCommand)
        Depends(objFile, unit_test_path + utprogram + '\\ipg.cop')

    # Ensure Cantata is disabled after each unit test is built and run
    # otherwise we end up instrumenting non-unit-test builds, which
    # inevitably fails. To do this, the ipg.cop file must be deleted
    # from the root scons execution directory.
    ut_env.AddPostAction(unitTestResult, Delete(Dir("#").abspath+"\\ipg.cop"))

    previousUnitTest = unitTestResult

    return unitTestResult

########################################################
# _GenerateIpgCop
# Creates a default ipg.cop file for the given unit 
# test. Contains specification of coverage level. Also
# forces the generation of the .csi file to the
# Cantata Eclipse project directory of the given unit
# test (otherwise it is created in the scons root
# directory).
########################################################
def _GenerateIpgCop(utprogram, utprogram_without_path):
    instrOptions = ""
    defaultIpgCopFile = ""

    if ut_source_exts[utprogram] == '.cpp':
        instrOptions = \
         '"--ci:--no_instr:all"\n' \
         '"--ci:--instr:stmt;decn;log#C_'+utprogram_without_path+'::*"\n'

    if use_msvc == 1:
      defaultIpgCopFile = \
          ("#\n" 
           "# Cantata++ Project-Level Options\n"
           "#\n" 
           "# The options set in this file will be inherited by each test in the project.\n"
           "#\n"
           "# WARNING: Do not alter this file manually.\n"
           "#\n"
           "#tool.use=true\n"
           "#tool.version=2\n"
           '"--analyse"\n'
           '"--ci:--instr:stmt;decn;log;"\n'
           '"--parse:--line_directives"\n'
           '"--parse:-W2"\n'
           '"--sm:--call_seq_code"\n'
           '"--comp:x86-Win32-5.x-msvc8"\n'
           "\n"
           "#User Section\n"
           '"--ci:--static_info_file:'+relative_ut_path_scons+utprogram+'"\n') + instrOptions
    else:
      if ut_source_exts[utprogram] == '.cpp':
        defaultIpgCopFile = \
            ("#\n" 
             "# Cantata++ Project-Level Options\n"
             "#\n" 
             "# The options set in this file will be inherited by each test in the project.\n"
             "#\n"
             "# WARNING: Do not alter this file manually.\n"
             "#\n"
             "#tool.use=true\n"
             "#tool.version=2\n"
             '"--analyse"\n'
             '"--ci:--instr:stmt;decn;log;"\n'
             '"--parse:--line_directives"\n'
             '"--parse:-W2"\n'
             '"--sm:--call_seq_code"\n'
             '"--comp:')
        defaultIpgCopFile = defaultIpgCopFile + compiler_section_gpp + '"\n'
        defaultIpgCopFile = defaultIpgCopFile + ("\n"
             "#User Section\n"
             '"--ci:--static_info_file:'+relative_ut_path_scons+utprogram+'"\n') + instrOptions
      if ut_source_exts[utprogram] == '.c':
        defaultIpgCopFile = \
            ("#\n" 
             "# Cantata++ Project-Level Options\n"
             "#\n" 
             "# The options set in this file will be inherited by each test in the project.\n"
             "#\n"
             "# WARNING: Do not alter this file manually.\n"
             "#\n"
             "#tool.use=true\n"
             "#tool.version=2\n"
             '"--analyse"\n'
             '"--ci:--instr:stmt;decn;log;"\n'
             '"--parse:--line_directives"\n'
             '"--parse:-W2"\n'
             '"--sm:--call_seq_code"\n'
             '"--comp:')
        defaultIpgCopFile = defaultIpgCopFile + compiler_section_gcc + '"\n'
        defaultIpgCopFile = defaultIpgCopFile + ("\n"
             "#User Section\n"
             '"--ci:--static_info_file:'+relative_ut_path_scons+utprogram+'"\n') + instrOptions


    ipgCopFile = open(File(unit_test_path+utprogram+"\\ipg.cop").abspath,'w')
    ipgCopFile.write(defaultIpgCopFile)
    ipgCopFile.close()
    return 0
    
########################################################
# Action
# Creates an action for the _GenerateIpgCop function. 
########################################################
GenerateIpgCop = \
    SCons.Action.ActionFactory \
        (_GenerateIpgCop,
         lambda utprogram, utprogram_without_path: 'Writing default ipg.cop for %s' % utprogram_without_path)

########################################################
# GenerateCopAndCsi
# Creates the ipg.cop and .csi files for the given unit 
# test so a test script can be generated with the 
# Cantata IDE.
########################################################
def GenerateCopAndCsi(utprogram, utprogram_without_path, use_test_dir_for_src):

    if use_test_dir_for_src:
        source_file = dummy_src_dir + utprogram

    else:
        source_file = relative_kernel_path_ut + utprogram

    ipgCopCommand = ut_env.Command(unit_test_path+utprogram+"\\ipg.cop",
                                [],
                                GenerateIpgCop(utprogram, utprogram_without_path))

    # Once an ipg.cop file has been created, prevent it from being removed
    # by a clean, as it can be updated manually by the user.
    ut_env.NoClean(ipgCopCommand)

    # Compile the SUT to generate the .csi file from which a test script
    # can be generated by Cantata.
    sutObject = ut_env.Object(source_file + ut_source_exts[utprogram])

    # Ensure side effects are cleanable.
    CleanedSideEffect(utprogram,
                      source_file + ".ti",
                      sutObject)

    preAction = ut_env.AddPreAction(sutObject,
                                 Copy(Dir('#').abspath + "\\ipg.cop",
                                 Dir(unit_test_path).abspath + "\\" +
                                     utprogram+"\\ipg.cop"))

    ut_env.Depends(preAction, ipgCopCommand)
    ut_env.Depends(unit_test_target, sutObject) 
    ut_env.Alias(utprogram_target, sutObject)

    return sutObject


########################################################
# MAIN
########################################################



ide_scons_cmd = (r"cd $SCONS_DIR && scons.bat -Q -j " + 
                 str(thread_number) + r" $SCONS_ARGUMENTS")

# Check for installed version of Cantata

catd = None
        
for dir in cantata_tool_dir:
    dir_abspath = Dir(dir).abspath
    if FindFile("cantpp.exe", dir_abspath):
        catd = os.path.dirname(File(FindFile("cantpp.exe", dir_abspath)).abspath)
        break

if catd is not None:
    ut_env.AppendENVPath('PATH', catd)
    ut_env.AppendENVPath('PATH', catd+"\\bin")

try:
    ut_env.AppendENVPath('LSFORCEHOST', os.environ['LSFORCEHOST'])
except:
    print "WARNING! LSFORCEHOST environment variable not set."
    print "Cantata based unit tests will not build."

if use_msvc == 1:
  arflags = str(ut_env['ARFLAGS'])
  # We need a console application. If a windows application is defined
  # remove it. Then add the console application. We don't do a straight
  # replace of WINDOWS with CONSOLE as WINDOWS may not be specified.
  arflags = arflags.replace('/SUBSYSTEM:WINDOWS', '')
  ut_env.Replace(ARFLAGS=arflags)
  ut_env.Append(ARFLAGS=' /SUBSYSTEM:CONSOLE')
  linkflags = str(ut_env['LINKFLAGS'])
  linkflags = linkflags.replace('/SUBSYSTEM:WINDOWS', '')
  linkflags = linkflags.replace('/DLL', '')
  ut_env.Replace(LINKFLAGS=linkflags)
  ut_env.Append(LINKFLAGS=' /SUBSYSTEM:CONSOLE')
else:
  if catd is not None:
    ut_env.Append(CCFLAGS = "-I"+catd+"\\inc")
ut_env['IDE_SCONS_CMD']=ide_scons_cmd
ut_env['SCONS_ARGUMENTS']=scons_arguments



if catd is None:

    if ((component_name + "_ide" in COMMAND_LINE_TARGETS) or
        (component_name + "_ide_unittests" in COMMAND_LINE_TARGETS)):
        print "WARNING! No Cantata installation found, unit test IDE generation/cleaning disabled."
    if component_name + "_unittests" in COMMAND_LINE_TARGETS:
        print "WARNING! No Cantata installation found, unit test build/execution/cleaning disabled."

elif utprograms:
    
    # ------------------------------------
    # Andre.Fischer-Ext (uidg5297) - 2014-09-12:
    # ------------------------------------
    # In case a variable which is required by GenericScons in unit_test.scfg is missing, 
    # a try/except clause is introduced in order to be able to build all non-cantata-related targets,
    # see MKS Issue #263831.
    # ------------------------------------
    try:
        # Workaround for Cantata problem. The default CXXCOM specifies /Fo$TARGET.
        # When Cantata sees /Fo<some_path>\<some_file>.obj it forces the output
        # to the source directory, regardless of what is specified for <some_path>.
        # However, if Cantata sees /Fo<some_path>, ie. no specific object file
        # given, then the object file is written in <some_path> correctly.
        if use_msvc == 1:
            ut_env['CXXCOM']='$CXX /Fo${TARGET.dir} /c $SOURCES $CXXFLAGS $CCFLAGS $_CCCOMCOM'
        else:
            ut_env['CXXCOM']="ipg_comp --optfile " + Dir('#').abspath + "\\ipg.cop " + '--comp $CXX -o ${TARGET.path} -c -fmessage-length=0 $SOURCES $CXXFLAGS $CCFLAGS $_CCCOMCOM  $_CXXCOMCOM'
#            print str(ut_env['CXXCOM'])
#            try:
#                CXXCOM_str = "ipg_comp --comp --optfile " + Dir('#').abspath + "\\ipg.cop " + str(ut_env['CXX']) + " -o ${TARGET.path} -c " + str(ut_env[SOURCES]) + " " + str(ut_env['CXXFLAGS'])  + " " + str(ut_env['CCFLAGS']) + " " + str(ut_env['_CXXCOMCOM'])
#                print CXXCOM_str
#            except:
#                print str(ut_env['CXXCOM'])
            ut_env['CCCOM']="ipg_comp --optfile " + Dir('#').abspath + "\\ipg.cop " + '--comp $CC -o ${TARGET.path} -c -fmessage-length=0 $SOURCES $CCFLAGS $_CCCOMCOM'
#            print str(ut_env['CCCOM'])
#            try:
#                CCCOM_str = "ipg_comp --comp --optfile " + Dir('#').abspath + "\\ipg.cop " +  str(ut_env['CC']) + " -o ${TARGET.path} -c " + str(ut_env['SOURCES']) + " " + str(ut_env['CCFLAGS']) + " " + str(ut_env['_CCCOMCOM'])
#                print CCCOM_str
#            except:
#                print ut_env['CCCOM']

        for utprogram in utprograms:
            use_test_dir_for_src = False
            utprogram_bak = utprogram
            if utprogram.startswith('$'):
                utprogram = utprogram.strip('$')
                use_test_dir_for_src = True
            else:
                use_test_dir_for_src = False
            ReadFileExtenstion(utprogram,use_test_dir_for_src)

            # check existance of unit test source
            # see MKS Issue #348427
            if ut_source_exts[utprogram] == "":
              print "WARNING: target " + utprogram_bak + " not found! Skipping."
              print "         Please update 05_Testing/05_Test_Environment/algo/modtests/cantata_tests/" + component_name + "/unit_test.scfg."
              print "         Cantata based unit tests will not build!!"
              continue

        unit_test_target = unit_test_target + "_" + variant

        if component_name == algo_name:
            target_prefix = ""
            path_prefix = ""
        else:
            target_prefix = algo_name + "_"
            path_prefix = algo_name + "/" 

        if generate_ide:        
            for utprogram in utprograms:
                use_test_dir_for_src = False
                utprogram_bak = utprogram
                if utprogram.startswith('$'):
                    utprogram = utprogram.strip('$')
                    use_test_dir_for_src = True
                else:
                    use_test_dir_for_src = False

                # check existance of unit test source
                # see MKS Issue #348427
                if ut_source_exts[utprogram] == "":
                  print "WARNING: target " + utprogram_bak + " not found! Skipping."
                  print "         Please update 05_Testing/05_Test_Environment/algo/modtests/cantata_tests/" + component_name + "/unit_test.scfg."
                  print "         Cantata based unit tests will not build!!"
                  continue

                utprogram_without_path = os.path.basename(utprogram)
                runfiles[utprogram] = utprogram + "\\" + utprogram_without_path + ".exe"
                SetupUnitTestSources(utprogram, utprogram_without_path, use_test_dir_for_src)
            SetupIDE()
        else:
            # Restore the program source from the environment
            program_src = env['PROGRAM_SRC']	
            testScriptAlreadyGenerated = env['TEST_SCRIPT_ALREADY_GENERATED']

            for utprogram in utprograms:
                utprogram_bak = utprogram
                if utprogram.startswith('$'):
                    utprogram = utprogram.strip('$')
                    use_test_dir_for_src = True
                else:
                    use_test_dir_for_src = False

                # check existance of unit test source
                # see MKS Issue #348427
                if ut_source_exts[utprogram] == "":
                  print "WARNING: target " + utprogram_bak + " not found! Skipping."
                  print "         Please update 05_Testing/05_Test_Environment/algo/modtests/cantata_tests/" + component_name + "/unit_test.scfg."
                  print "         Cantata based unit tests will not build!!"
                  continue

                utprogram_without_path = os.path.basename(utprogram)
                utprogram_target = target_prefix + utprogram_without_path + "_ut_" + variant
                if testScriptAlreadyGenerated[utprogram]:
                    # copy other test input files to module test execution directory
                    try:
                      for ext in ut_ref_file_exts:
                          CopyAdditionalFilesToExecDir(utprogram, "*" + ext)
                    except NameError,e:
                      exception_warning(e,exception_handler,msg)
                      pass
                    # run unit tests
                    lastBuildAction = BuildAndRunUnitTest(utprogram, utprogram_without_path)
                else:
                    lastBuildAction = GenerateCopAndCsi(utprogram, utprogram_without_path, use_test_dir_for_src)
    
            if generate_html_reports:
                GenerateReports(lastBuildAction) 
            
    except NameError,e:
        exception_warning(e,exception_handler,"in "+relpath+"\unit_test.scfg\nCantata based unit tests will not build!!")                        
        
if profile:
    FinishSconscriptEntry()
